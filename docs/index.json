{
  "software/netmf/tutorials/digital-inputs.html": {
    "href": "software/netmf/tutorials/digital-inputs.html",
    "title": "Digital Inputs",
    "keywords": "Digital Inputs Digital inputs sense if the state of its pin is high or low based on the voltage. Every pin has a maximum & minimum supported voltages. For example, the typical minimum voltage on most pins is 0 volts -- a negative voltage may damage the pin or the processor. Also, the maximum that can be supplied to most pins must be less than the processor power source voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V; however, some processors that are powered by 3.3V are 5V tolerant and are capable of accepting up to 5V on their inputs. Check the product's or the processor's manual for the tolerance level. Warning 5V-tolerant doesn't mean the processor can be powered by 5V. Only the input pins can tolerate 5V. InputPort An InputPort object is used to handle digital input pins. Most pins on the processor can be input or output. Unconnected input pins are \"floating\". When a pin is an input and is not connected, it is open for any surrounding noise, which can make the pin high or low. To take care of this issue, modern processors include internal weak pull-down or pull-up resistors, that are usually controlled by software. Enabling the pull-up resistor will pull the pin high. Note that the pull-up resistor doesn't make a pin high but it pulls it high. If nothing is connected then the pin is high by default. External resistors can be added as well. In this example, a button is connected between ground and the input pin. We will also enable the pull-up resistor. This means that the pin will be high (pull-up) when button is not pressed and low (connected to ground) when the button is pressed. We will read the status of the button and pass its state to the LED. Note that the pin is high when the button is not pressed (pulled-high) and it is low when the button is pressed. This means the LED will turn off when the button is pressed. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the device schematics or manuals for the proper pin numbers. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; InputPort Button; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); Button = new InputPort(Cpu.Pin.GPIO_Pin2, false, Port.ResistorMode.PullUp); while (true) { LED.Write(Button.Read()); Thread.Sleep(10); } } } Interrupt Port In the previous example, the program just looped, and looped, and looped -- each time checking the status of the pin attached to the button. The pin is checked maybe a million times before/after the button is pressed! Interrupt ports allows us to set a method that will be executed when the button is pressed (when pin is low for example). We can set the interrupt to fire (call the method) on many state changes on the pin: when a pin is low or maybe when it is high. The most common use is the \"on change.\" The change from low to high or high to low creates a signal edge. The rising edge occurs when the signal rises from low to high. The falling edge happen when the signal falls from high to low. For a more in-depth understanding of the difference between the \"change\" interrupt versus a \"level\" interrupt, use wikipedia -- the two articles of relevance are found by searching for \"Interrupt Port\" and \"edge level transition.\" In the example below, we are using the low edge to detect a button press. \"IntButton_OnInterrupt\" will automatically run when button is pressed. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the device schematic or manual for pin numbers. using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using System; using System.Threading; public class Program { public static void Main() { InterruptPort IntButton = new InterruptPort(Cpu.Pin.GPIO_Pin1, false, Port.ResistorMode.PullUp, Port.InterruptMode.InterruptEdgeLow); IntButton.OnInterrupt += new NativeEventHandler(IntButton_OnInterrupt); // Other code can be added here // ... // We are just going to sleep in this example! Thread.Sleep(Timeout.Infinite); } static void IntButton_OnInterrupt(uint port, uint state, DateTime time) { Debug.Print(\"Button Pressed\"); } } When creating the new InterruptPort object, the second argument indicates whether the glitch filter is enabled (true) or disabled (false). This is typically needed when using the interrupt feature to debounce the button. Not enabling this feature may cause the button to trigger more than one event, even though the button is pressed once. Tip In the event handler, like the one above : ...OnInterrupt(uint port, uint state..., the state argument is the state of the Pin after the edge transition. I.e. on a low to high edge, state will be high (true); likewise for high to low transitions. Tristate Port If we want a pin to be an input and output, what can we do? A pin can never be in and out simultaneously but we can make it output to set something and then make it input to read a response back. One way is to \"Dispose\" of the pin. We make an output port, use it and then dispose it; then we can make the pin input and read it. NETMF supports a better option called a Tristate port. Tristate means three states -- input, output low and output high. One minor issue about tristate pins is that if a pin is set to output and then you set it to output again an exception will occur. One common work-around for this is to check the direction of the pin before changing it. The direction of the pin is in its property \"Active\" where false means input and true is output. The code below requires the Microsoft.SPOT.Hardware assembly. Tip Due to internal design, TristatePorts will only work with interrupt capable digital pins. Warning Be careful not to have the pin connected to a switch then set the pin to output. using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { static void MakePinOutput(TristatePort port) { if (port.Active == false) port.Active = true; } static void MakePinInput(TristatePort port) { if (port.Active == true) port.Active = false; } public static void Main() { TristatePort TriPin = new TristatePort(Cpu.Pin.GPIO_Pin6, false, false, Port.ResistorMode.PullUp); MakePinOutput(TriPin); TriPin.Write(true); Debug.Print(\"Write to output pin completed.\"); Debug.Print(\"Changing to input pin\"); MakePinInput(TriPin); Debug.Print(\"The input pin state is: \" + TriPin.Read().ToString()); Thread.Sleep(Timeout.Infinite); } }"
  },
  "software/netmf/tutorials/files.html": {
    "href": "software/netmf/tutorials/files.html",
    "title": "Files",
    "keywords": "Files The file system features in NETMF are very similar to full .NET. There are no limits on file counts or sizes other than the limits of the FAT file system itself. NETMF supports FAT16 and FAT32. With a few minor changes, NETMF file system access can be tested from within the Microsoft NETMF emulator. Changes include removing any of the GHI library dependencies. Unlike full .NET, NETMF does require mounting of media. NETMF also handles media names differently than full .NET. Media name differences are easily handled by accessing the root directory name at runtime and then using that name. Consequently, most online examples of how to use .NET to access files on PCs can be used with NETMF. In NETMF, other than differences for specific physical characteristics, usage of SD/MMC cards and USB memory devices are identical to .NET. This document splits it's examples into two sets. One for SD/MMC Card file system access and the other for USB Mass Storage. The core file operations (open, read, write, etc.) are identical between the two. Warning The file system does a lot of data buffering internally to speed up file access time and to increase the life of flash media. When you write data to a file, it is often saved somewhere in internal buffers rather than being written immediately to the media. To make sure the data is stored on the media, you need to flush the data. Flushing (or closing) a file is the only way to guarantee that the data you are trying to write is on the actual media. In addition to the file data there is other information, such as directory information, that may not be written to the media when the file is flushed. For example, if you delete a file and remove the card from the system, the file is probably not actually erased because the directory structure was not flushed. Under current versions of .NET Micro Framework, there can be a variable time delay before the buffers are actually written to the media when using the FileStream's Flush method. This delay can reportedly be as long as a minute (see: https://netmf.codeplex.com/workitem/2149 ). To guarantee that the file buffers and the meta-data are written to the media you need to flush the volume: VolumeInfo.GetVolumes()[0].FlushAll() -or- new Microsoft.SPOT.IO.VolumeInfo(\"\\SD\").FlushAll() . Ideally, you would unmount the media before it is removed from the system. This may not be always possible -- FlushAll will guarantee your data is saved Tip The SD/MMC Card examples shown below require the GHI.Hardware, Microsoft.SPOT.IO, and System.IO assemblies. Some Microsoft documentation class descriptions, such as for Directory, place the library code in the mscorlib assembly; however, it is found in the System.IO assembly. SD Card: Show Files in Root Directory This example assumes the card is already inserted; it lists all files available in the root directory. Note Some SD card sockets/interfaces have an internal switch that closes when a card is inserted or ejected. Utilizing the switch is shown in the \" SD Card: Media Detection \" example further down on this page. using System.IO; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.IO; using GHI.IO; using GHI.IO.Storage; class Program { public static void Main() { // ... // assume SD card is inserted // Create a new storage device // NETMF only allows one SD card // to be supported at a time. SDCard sd_card = new SDCard(); // this is a non-blocking call // it fires the RemovableMedia.Insert event after // the mount is finished. sd_card.Mount(); // for some cases, a simple sleep might suffice // This example just waits on the event before proceeding // (After first time firing of the event, you may want // to disable the handler or re-assign it bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (! fs_ready) { System.Threading.Thread.Sleep(50); } // Assume one storage device is available, access it through // NETMF and display the available files and folders: Debug.Print(\"Getting files and folders:\"); if (VolumeInfo.GetVolumes()[0].IsFormatted) { string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; string[] files = Directory.GetFiles(rootDirectory); string[] folders = Directory.GetDirectories(rootDirectory); Debug.Print(\"Files available on \" + rootDirectory + \":\"); for (int i = 0; i < files.Length; i++) Debug.Print(files[i]); Debug.Print(\"Folders available on \" + rootDirectory + \":\"); for (int i = 0; i < folders.Length; i++) Debug.Print(folders[i]); } else { Debug.Print(\"Storage is not formatted. \" + \"Format on PC with FAT32/FAT16 first!\"); } // Unmount when done sd_card.Unmount(); } } SD Card: Writing Files There is more than one way to open files. I will only cover FileStream objects. This example will open a file and write a string to it. Since FileStream will only take byte arrays, we need to convert our string to a byte array. using System.Threading; using System.Text; using Microsoft.SPOT; using System.IO; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { static void Main() { // if necessary, check that SD is present here... SDCard sd_card = new SDCard(); sd_card.Mount(); bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (! fs_ready ) { System.Threading.Thread.Sleep(1); } // Assume only one storage device is available // and that the media is formatted string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; FileStream FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Create); byte[] data = Encoding.UTF8.GetBytes(\"This string will go in the file!\"); FileHandle.Write(data, 0, data.Length); FileHandle.Close(); sd_card.Unmount(); } } SD Card: Reading a File Take the SD Card used in the last example, put it in a PC and you will see the file. For this example, we use the same SD Card written to by the last example. The file is opened and read to verify its contents. using System.Threading; using System.Text; using Microsoft.SPOT; using System.IO; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { static void Main() { // ... If desired, check if SD is inserted // SD Card is inserted // Create a new storage device SDCard sd_card = new SDCard(); // Mount the file system sd_card.Mount(); bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (!fs_ready) { System.Threading.Thread.Sleep(1); } // Assume one storage device is available, // access it through NETMF string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; FileStream FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Open, FileAccess.Read); byte[] data = new byte[100]; int read_count = FileHandle.Read(data, 0, data.Length); FileHandle.Close(); Debug.Print(\"The size of data read is: \" + read_count.ToString()); Debug.Print(\"Data from file:\"); Debug.Print(new string(Encoding.UTF8.GetChars(data), 0, read_count)); sd_card.Unmount(); } } SD Card: Media Detection The previous examples assumed that the card was already inserted and mostly ignored whether that media was formatted (contained a file system). The following example shows an application without such assumptions; additionally, it demonstrates the Format method. Together, InsertEventHandler , EjectEventHandler , and IsSDCardPresent are used to respond to physical card activities, which in turn are used to control mounting ( Mount , Unmount ) of the card. Once the card is mounted, the file-system can be used. using System; using System.IO; using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { // evt is used to avoid the possibility that accesses to the // mounted file system do not occur until mount() // is fully done. private static AutoResetEvent evt = new AutoResetEvent(false); //Make sure to set the pin to your sd card detect pin. private static InputPort sdCardDetect = new InputPort(Cpu.Pin.GPIO_NONE, false, Port.ResistorMode.Disabled); public static void Main() { RemovableMedia.Insert += new InsertEventHandler(RemovableMedia_Insert); RemovableMedia.Eject += new EjectEventHandler(RemovableMedia_Eject); // Start auto mounting thread new Thread(SDMountThread).Start(); evt.WaitOne(); // yield here until mounting and initializing is finished // Your program goes here // ... } // This event is fired by unmount; not neccesarily by physical ejection of media static void RemovableMedia_Eject(object sender, MediaEventArgs e) { Debug.Print(\"SD card unmounted, eject event fired\"); // as desired signal other thread(s) in application // that unmount occurred } static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Insert event fired; SD card mount is finished.\"); // insert code here for anything the program wants to do immediately // after mounting occurs... if (e.Volume.IsFormatted) { Debug.Print(\"Available folders:\"); string[] strs = Directory.GetDirectories(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); Debug.Print(\"Available files:\"); strs = Directory.GetFiles(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); } else { Debug.Print(\"SD card is not formatted. Formatting...\"); // VolumeInfo is the class that contains volume information for a specific // media. // .GetVolumes()[0] aquires the first volume on the device. Change the // index for different volumes. // .Format(\"FAT\", 0); Selects the \"FAT\" file system as the format type. VolumeInfo.GetVolumes()[0].Format(\"FAT\", 0); } evt.Set(); // proceed with other processing } public static void SDMountThread() { SDCard SD = null; const int POLL_TIME = 500; // check every 500 millisecond bool sdExists; while (true) { try { // If SD card was removed while mounting, it may throw exceptions. sdExists = sdCardDetect.Read(); // make sure it is fully inserted and stable if (sdExists) { Thread.Sleep(50); sdExists = sdCardDetect.Read(); } if (sdExists && SD == null) { SD = new SDCard(); SD.Mount(); } else if (!sdExists && SD != null) { SD.Unmount(); SD.Dispose(); SD = null; } } catch { if (SD != null) { SD.Dispose(); SD = null; } } Thread.Sleep(POLL_TIME); } } } USB Mass Storage Devices USB mass storage devices, such as memory sticks and card readers are supported by GHI's NETMF devices. If you compare the following example with those above for SD Cards, you will see how easy it is to program for one, the other, or both with virtually identical code. using System; using System.Threading; using System.IO; using Microsoft.SPOT; using System.Text; using Microsoft.SPOT.IO; using GHI.Usb; using GHI.Usb.Host; using GHI.IO.Storage; public class Program { // evt is used to avoid the possibility that accesses to the // mounted file system do not occur until mount() // is fully done. private static AutoResetEvent evt = new AutoResetEvent(false); private static MassStorage usb_storage; private static string rootDirectory; public static void Main() { RemovableMedia.Insert += new InsertEventHandler(RemovableMedia_Insert); RemovableMedia.Eject += new EjectEventHandler(RemovableMedia_Eject); // Unlike SD Card detection, the USB Host Controller sends an // event when a Mass Storage device is plugged-in. Controller.MassStorageConnected += (sender, massStorage) => { usb_storage = massStorage; usb_storage.Mount(); // fires the insert event when finished }; Controller.Start(); evt.WaitOne(); // yield here until mounting and initializing is finished byte[] data; // write using (var FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Create)) { data = Encoding.UTF8.GetBytes(\"This string will go in the file!\"); FileHandle.Write(data, 0, data.Length); } // read int read_count; using (var FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Open, FileAccess.Read)) { data = new byte[100]; read_count = FileHandle.Read(data, 0, data.Length); } Debug.Print(\"The size of data we read is: \" + read_count.ToString()); Debug.Print(\"Data from file:\"); Debug.Print(new string(Encoding.UTF8.GetChars(data), 0, read_count)); usb_storage.Unmount(); } // This event is fired by unmount static void RemovableMedia_Eject(object sender, MediaEventArgs e) { Debug.Print(\"USB unmounted, eject event fired\"); } static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Insert event fired; USB Storage mount is finished.\"); if (e.Volume.IsFormatted) { rootDirectory = e.Volume.RootDirectory; Debug.Print(\"Available folders:\"); string[] strs = Directory.GetDirectories(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); Debug.Print(\"Available files:\"); strs = Directory.GetFiles(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); } else { Debug.Print(\"Media is not formatted. Formatting...\"); e.Volume.Format(\"FAT\", 0); rootDirectory = e.Volume.RootDirectory; } evt.Set(); // proceed with other processing } } Warning Media formatted as FAT12 will not work. This shouldn't be an issue since FAT12 is no longer in use."
  },
  "software/netmf/tutorials/firmware-update.html": {
    "href": "software/netmf/tutorials/firmware-update.html",
    "title": "Firmware Update",
    "keywords": "Firmware Update Note If you need to update the loader, it should always be done before updating the firmware. See your device's developers' guide or manual for more detail on updating the loader. Connect your device to your PC. Launch FEZ Config and click on Check device for update button. This will show the version numbers on the PC and what is loaded on the device. Note Fez Config is installed when you install the NETMF SDK . To proceed with updating TinyCLR, click on the Firmware Updater button on the left and follow the instructions. After FEZ Config selects the firmware and the default configuration files, click Next . Click OK to proceed when the dialog appears asking if you are having issues. As the update occurs, the steps and progress are shown. When it is finished, the module is ready to be flashed with NETMF applications."
  },
  "software/netmf/tutorials/usb-host.html": {
    "href": "software/netmf/tutorials/usb-host.html",
    "title": "USB Host",
    "keywords": "USB Host There is usually a lot of confusion between USB host and USB client. USB host is the system that connects to multiple USB clients. For example, the PC is a USB host and it can connect to multiple USB clients like mice, keyboards, and mass storage devices. Implementing a USB client is rather simple but implementing a host is far more complicated. USB host is an exclusive feature from GHI Electronics. With this feature, you can connect almost any USB device to GHI's NETMF products. This feature opens new possibilities for embedded systems. Your product can now connect to a standard USB keyboard and can also access files on a USB thumb drive. USB is a hot pluggable system which means any device can be connected or disconnected at any time. Events are generated when devices are connected or disconnected. The program that you write should subscribe to these events and handle them accordingly. With USB hub support, devices can be connected directly to the USB host port or the user may connect multiple USB devices through a USB hub. Getting Started When working with USB host, you interact with the Controller. You subscribe to the connected event for various devices and then start the controller. When a device connected, you receive an object representing that device as the event arguments. You can subscribe to the Disconnect event on that device to do any clean up you might need. The below code requires the GHI.Usb and GHI.Hardware assemblies and shows you briefly how to handle device connections and disconnections. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.DeviceConnectFailed += Controller_DeviceConnectFailed; Controller.KeyboardConnected += Controller_KeyboardConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_DeviceConnectFailed(object sender, EventArgs e) { Debug.Print(\"Failed.\"); } private static void Controller_KeyboardConnected(object sender, Keyboard keyboard) { Debug.Print(\"Keyboard connected.\"); keyboard.Disconnected += keyboard_Disconnected; } private static void keyboard_Disconnected(BaseDevice sender, EventArgs e) { Debug.Print(\"Keyboard disconnected.\"); } } Mice, keyboards, and joysticks Once you receive a connect event and the associated object for a mouse, keyboard, or joystick, you can subscribe to various events on those objects to receive data from the device. The below code simply prints out when a button or key is pressed. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.KeyboardConnected += Controller_KeyboardConnected; Controller.MouseConnected += Controller_MouseConnected; Controller.JoystickConnected += Controller_JoystickConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_KeyboardConnected(object sender, Keyboard keyboard) { Debug.Print(\"Keyboard connected.\"); keyboard.KeyUp += keyboard_KeyUp; keyboard.KeyDown += keyboard_KeyDown; } private static void Controller_MouseConnected(object sender, Mouse mouse) { Debug.Print(\"Mouse connected.\"); mouse.ButtonChanged += mouse_ButtonChanged; mouse.CursorMoved += mouse_CursorMoved; mouse.WheelMoved += mouse_WheelMoved; } private static void Controller_JoystickConnected(object sender, Joystick joystick) { Debug.Print(\"Joystick connected.\"); joystick.ButtonChanged += joystick_ButtonChanged; joystick.CursorMoved += joystick_CursorMoved; joystick.HatSwitchPressed += joystick_HatSwitchPressed; } private static void keyboard_KeyUp(Keyboard sender, Keyboard.KeyboardEventArgs e) { Debug.Print(\"Up: \" + e.Which.ToString()); } private static void keyboard_KeyDown(Keyboard sender, Keyboard.KeyboardEventArgs e) { Debug.Print(\"Down: \" + e.Which.ToString()); } private static void mouse_ButtonChanged(Mouse sender, Mouse.ButtonChangedEventArgs e) { Debug.Print(e.State.ToString() + \" \" + e.Which); } private static void mouse_CursorMoved(Mouse sender, Mouse.CursorMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString()); } private static void mouse_WheelMoved(Mouse sender, Mouse.WheelMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString()); } private static void joystick_ButtonChanged(Joystick sender, Joystick.ButtonChangedEventArgs e) { Debug.Print(e.State.ToString() + \" \" + e.Which); } private static void joystick_CursorMoved(Joystick sender, Joystick.CursorMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString() + \" \" + e.Which.ToString()); } private static void joystick_HatSwitchPressed(Joystick sender, Joystick.HatSwitchPressedEventArgs e) { Debug.Print(e.Direction.ToString()); } } Serial Serial (UART) communication is a very common interface. There are many companies that create chips that convert USB to serial. GHI currently supports chipsets from FTDI. Their FT232 is known to work, though others may as well. USB chipsets are made to be somewhat customized. A company can use an FTDI chip to make their product run on USB and they will change the strings in USB descriptors so that when you plug in their device to a PC you will see the company name and not FTDI. They can also change the USB VID/PID, vendor ID and product ID. Many of the interface products on the market use the FTDI chipset. A few other USB-Serial manufacturers, like Prolific, are included, but they are deprecated and not supported by us. The below example simply echoes any data received back out to the sender and prints it to the debug output. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.UsbSerialConnected += Controller_UsbSerialConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_UsbSerialConnected(object sender, UsbSerial usbSerial) { Debug.Print(\"UsbSerial connected.\"); usbSerial.DataReceived += usbSerial_DataReceived; } private static void usbSerial_DataReceived(UsbSerial sender, UsbSerial.DataReceivedEventArgs e) { for (int i = 0; i < e.Data.Length; i++) Debug.Print(e.Data[i].ToString()); sender.Write(e.Data); } } Mass Storage When you connect a mass storage device, it can be accessed through the regular NETMF filesystem functions with the device root \"USB\". Once you mount the device, you need to wait for NETMF to fire the RemovableMedia.Insert event before you try accessing the filesystem. The below code simply opens or creates a file on the drive, writes \"Hello, World!\" to it, and then unmounts the device. It requires the Microsoft.SPOT.IO and System.IO assembly. using GHI.Usb.Host; using Microsoft.SPOT; using Microsoft.SPOT.IO; using System.IO; using System.Text; using System.Threading; public class Program { private static AutoResetEvent evt = new AutoResetEvent(false); public static void Main() { Controller.MassStorageConnected += Controller_MassStorageConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_MassStorageConnected(object sender, MassStorage massStorage) { RemovableMedia.Insert += RemovableMedia_Insert; massStorage.Mount(); evt.WaitOne(); using (var fs = new FileStream(\"\\\\USB\\\\Hello.txt\", FileMode.OpenOrCreate)) fs.Write(Encoding.UTF8.GetBytes(\"Hello, World!\"), 0, 13); massStorage.Unmount(); } private static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Inserted.\"); evt.Set(); } } Warning Under current versions of NETMF, the Flush method of FileStream will eventually write the buffers; unfortunately, there is a delay (sometimes up to a minute) from when Flush is called to when the data is actually flushed. See Files and Folders for more details. Webcams You can also connect a webcam and stream images from it. Webcams only support certain image formats and sizes so you need to query the formats supported and tell the camera to stream images using that format. We support cameras that support the YUV2 color format. The below code requires the Microsoft.SPOT.Graphics and Microsoft.SPOT.TinyCore assemblies. It looks for a format that has a size of 320x240 and starts to stream it. When a new image is available an event is raised and we draw the received image to the bitmap that represents our screen and then flush it. Make sure you have a display properly configured. using GHI.Usb.Host; using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using System.Threading; public class Program { private static Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); public static void Main() { Controller.WebcamConnected += Controller_WebcamConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_WebcamConnected(object sender, Webcam webcam) { webcam.ImageAvailable += webcam_ImageAvailable; foreach (Webcam.ImageFormat i in webcam.SupportedFormats) { if (i.Width == 320 && i.Height == 240) { webcam.StartStreaming(i); break; } } } private static void webcam_ImageAvailable(Webcam sender, EventArgs e) { sender.GetImage(lcd); lcd.Flush(); } } Unknown Devices If your device is not recognized by our libraries, the UnknownDeviceConnected event will be triggered. This event will give you the USB parameters of the device that you can use to \"force\" the creation of a specific type. This method is not guaranteed to work with every unknown device, however. The below code illustrates how to do this with a usb to serial device. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { private static UsbSerial serial; public static void Main() { Controller.UnknownDeviceConnected += Controller_UnknownDeviceConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_UnknownDeviceConnected(object sender, Controller.UnknownDeviceConnectedEventArgs e) { Debug.Print(\"Unknown device connected.\"); serial = new UsbSerial(e.Id, e.InterfaceIndex, e.VendorId, e.ProductId, e.PortNumber, BaseDevice.DeviceType.SerialProlific); serial.DataReceived += serial_DataReceived; } private static void serial_DataReceived(UsbSerial sender, UsbSerial.DataReceivedEventArgs e) { for (int i = 0; i < e.Data.Length; i++) Debug.Print(e.Data[i].ToString()); sender.Write(e.Data); } }"
  },
  "software/tinyclr/downloads.html": {
    "href": "software/tinyclr/downloads.html",
    "title": "Downloads",
    "keywords": "Downloads This page includes different download types for individual boards. See individual product pages for details on what to download. See Release notes here . Software status legend: Status Meaning Production Ready to be used commercially. Preview Preview of the next release, not quite ready for production use. Alpha Bleeding edge development that will frequently change. Major changes to come. Visual Studio Project System The extension is what gets loaded on Visual Studio to allow it to communicate with a TinyCLR OS device. It also includes project templates. File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview 049923C25A981EF84E2CFB25CFB87855 v0.12.0 2018-07-05 Alpha 6E101D4D4A31CD9B3C174B849A41F84B v0.11.0 2018-05-10 Alpha ECED507FCAF84B7104A8470126769F48 v0.10.0 2018-04-05 Alpha 5C98F6BF930FFF5BB050903381858327 v0.9.0 2018-03-01 Alpha 7E5FAFA73FA9BF75EBAEB370092902D2 v0.8.0 2018-02-01 Alpha 14DD9177FF89D6F400AD4E0E62AEDB2B v0.7.0 2018-01-04 Alpha 20CDDE5FE6C5B0FDD41ECE39BCD0C967 v0.6.0 2017-08-31 Alpha 68E94D0720CCDAC1A3E9BDEF7704FAAA v0.5.0 2017-07-07 Alpha 58542CEB7DAF6445AD10083ABA73D834 v0.4.0 2017-05-10 Alpha 4D463EA5991EA7698110B79EF4DB6B8B v0.3.0 2017-04-06 Alpha 6094565340EDF8F5445106C2A9B1441C v0.2.0 2017-03-07 Alpha A9CB8E88011AFF28AD88656E86C73A31 v0.1.0 2016-12-16 Alpha D93A8FF13900362FB4528F8036D46612 Libraries Libraries are hosted though a local NuGet feed for now as we are a lot of changes still. These libraries will be hosted on http://www.nuget.org/ in the future. File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview DF7DAB3754DE092D787D48ECBE42B82B v0.12.0 2018-07-05 Alpha EC7C4190984C5B26FF59874713B80B93 v0.11.0 2018-05-10 Alpha 041ED0458AC82595BD33C34284BF6661 v0.10.0 2018-04-05 Alpha A0A227517C9D58B28279336FF759AB9D v0.9.0 2018-03-01 Alpha 7892A8269D0D586301CDA76D9FC02F01 v0.8.0 2018-02-01 Alpha C7B0B05EEB173AE2B16F6F8B079ED8EE v0.7.0 2018-01-04 Alpha 62E4255D2534545937B5AFA5C19F15D2 v0.6.0 2017-08-31 Alpha CA9275032B3A2EA403738497C2C0C280 v0.5.0 2017-07-07 Alpha C1768FF218AB1790BD902E52561C0CE5 v0.4.0 2017-05-10 Alpha 1A8B0E28431927FA4716B44B774FDF90 v0.3.0 2017-04-06 Alpha 21D3E9AD37285B231B1E6E605B7CA709 v0.2.0 2017-03-07 Alpha 7CDE2D7ADDD3E490344B1DA8DB342F8D v0.1.0 2016-12-16 Alpha 9E843638A8A4793814D76B522F8CBF1A TinyCLR Config TinyCLR Config is a tool used to update and configure your TinyCLR device. File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview 1FD781BADFFB37E7593FFF98673D95AA v0.12.0 2018-07-05 Alpha CD3CA5ADED595A26B12AAF6A0C2FC69D v0.11.0 2018-05-10 Alpha 1A481327C13700FA6CC0D1B329AF1BCF v0.10.0 2018-04-05 Alpha 2FAA549946AC90A301F5310CE115A964 v0.9.0 2018-03-01 Alpha 23BCC9B648484C77F166B00383558715 v0.8.0 2018-02-01 Alpha 5F5E8835C81D43894582A6B755F28875 v0.7.0 2018-01-04 Alpha 329D4A24BA66423DD5D655202873B38C v0.6.0 2017-08-31 Alpha 75743E33D1B98E6999BDCC9936479C14 Firmwares The Firmware is the TinyCLR OS that lives on your hardware. The firmware version loaded on the hardware must match the version number of the extension and the libraries. This will be easier managed once the libraries are hosted on http://www.nuget.org/ FEZCLR This is the reference firmware for TinyCLR OS. File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview A98A9C45C368C5C3211829DD1BC7DF53 v0.12.0 2018-07-05 Alpha 26B63FE03DB65A3EC3D23E6E3A6220DE v0.11.0 2018-05-10 Alpha A63A1BE64712A5F7C661B68F79F5DF8F v0.10.0 2018-04-05 Alpha 038BB3074D55DC37700FC27FD3DC7ACD v0.9.0 2018-03-01 Alpha 137B142B2A278A8AC62F2ED88B9E25A8 v0.8.0 2018-02-01 Alpha 1C219C675CF6F7CE28B3F3971E9385BF v0.7.0 2018-01-04 Alpha A0D3B8449C6D5D03E3CA4259AD94204A v0.6.0 2017-08-31 Alpha 3D66C9FF460591AA2DD4B002DE6D9B9A v0.5.0 2017-07-07 Alpha 93094FF58D78DEB36D22FD9450737362 UC2550 File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview 99D87C4B379A51313191494CD8A606CF v0.12.0 2018-07-05 Alpha 8C0E42F0D5CC4E834DBAB88599C9CCBE v0.11.0 2018-05-10 Alpha 0D1379DE4C8CB705B69EF8DC694C5B30 v0.10.0 2018-04-05 Alpha 4C265BD5A6889CAEB1DFFCBC7675AE60 UC5550 File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview AFD0FF5599985FA96D6150D3A3F3CE76 v0.12.0 2018-07-05 Alpha 17BC60B9C16E3F13294E76A193B0BFB6 v0.11.0 2018-05-10 Alpha 153E4DD63FEB7A414D499AF5AB32F047 v0.10.0 2018-04-05 Alpha 789EA25CF38545DCE49964295D6AD581 G30 File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview B7BBB3D880BFB1DF3F37F41E83F5C04D v0.12.0 2018-07-05 Alpha F6B0FD4AE45D1284D064FC09FB003CB2 v0.11.0 2018-05-10 Alpha 4AEA0719E2AE90F7B8EE5F3FB7AAC176 v0.10.0 2018-04-05 Alpha 872C7C2A18275E299E8509F0805E05A9 v0.9.0 2018-03-01 Alpha 1074127871598866EDA520D2C453829F v0.8.0 2018-02-01 Alpha E6406D0BE2324897119EEBC7BAD5451F v0.7.0 2018-01-04 Alpha 38F66032AB3F0728BED99EB3F204CD39 v0.6.0 2017-08-31 Alpha 6AF63423B229CF5A30B6B7E83D877FF9 v0.5.0 2017-07-07 Alpha 4A8479E0D431868ED047CB7C482511CE v0.4.0 2017-05-10 Alpha FCBACDAB7C02E1A855375BF776EEE2FB v0.3.0 2017-04-06 Alpha 59A994B1F4F60FB3AE6CD8F91AB01650 v0.2.0 2017-03-07 Alpha 6E5BB699634D78DD64FFFB69D547A58F v0.1.0 2016-12-16 Alpha 6347B73E93FF9BF7D52ECE142D9F2ECB G80 File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview D438734607EA7AA1D155B1572BE224B8 v0.12.0 2018-07-05 Alpha 180E35FCDA9340D81B64DA8A2C52E2B5 v0.11.0 2018-05-10 Alpha 0395E13C8CA849DCF7D6E1A2CCEBF601 v0.10.0 2018-04-05 Alpha A2F66C80A28E41D3B9D7D60C77C7456B v0.9.0 2018-03-01 Alpha C534FE85640A2898AAE6319C1BAC8C5E v0.8.0 2018-02-01 Alpha C4F546807FF741F19D8A318E36FEA158 v0.7.0 2018-01-04 Alpha 3873B974BD1871CE81B94CA0C9759C0A v0.6.0 2017-08-31 Alpha 61759AB6015BD2B2FE1D9D5B4209BC6A v0.5.0 2017-07-07 Alpha E9256BDB4A0FA61A30BF9B5294354618 v0.4.0 2017-05-10 Alpha E6EB8C753C4CE9A6197EC06F3C4CB848 v0.3.0 2017-04-06 Alpha EDB489B34BC8E249D47160EA3AFE466C v0.2.0 2017-03-07 Alpha 4EAA86216B6FFCDE937D1CCFD9558356 v0.1.0 2016-12-16 Alpha 5C93CCA961904F25BB56A9B9AD7C501A G120 File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview 21D96730FDECB36462CD86BA1836B475 v0.12.0 2018-07-05 Alpha C53219F2626408D51D50D479337902E9 v0.11.0 2018-05-10 Alpha 08C6674D5B1C403ABDD6BD423D68BE40 v0.10.0 2018-04-05 Alpha DF63957F4F27848BDEAE3F35B0322053 v0.9.0 2018-03-01 Alpha 5DC107B08E72658A5A06AF729DAA5F2C v0.8.0 2018-02-01 Alpha 53277EBA90E4966F1AB1EB484F987B38 v0.7.0 2018-01-04 Alpha 54F03A598791E8062096EE67ACA8C25A v0.6.0 2017-08-31 Alpha 9418A57C0B5F655F3FD35CBED0CEC16F v0.4.0 2017-05-10 Alpha 1C09A3C7D5305B03F0FF51884ACBD2F2 v0.3.0 2017-04-06 Alpha 57836246074A8E729EE3D6C6BCF76F55 v0.2.0 2017-03-07 Alpha 66EAA71A4A7D1B96AC9CD7C892DAA3CE G400 File Date Status MD5 v1.0.0-preview1 2018-08-15 Preview 35F33ECA41C54281497691EFC79F8CB0 v0.12.0 2018-07-05 Alpha F24B1B0D20556474375080956BF0E564 v0.11.0 2018-05-10 Alpha 008CD3C2A35B9C529ECFAAE3BA073475 v0.10.0 2018-04-05 Alpha F158C930D47E6E6820341CF42A2A4CBD v0.9.0 2018-03-01 Alpha 0816EABCEAF523ACDA5BF7ED53A58C8A v0.8.0 2018-02-01 Alpha 7CC4E057095FA9BCD7D99523BC90839C v0.7.0 2018-01-04 Alpha B70F85903208040DB50C7862ACBE5A7D v0.6.0 2017-09-13 Alpha 81F063028D379699ECE969F45757C801 v0.4.0 2017-05-10 Alpha 03859F270F8B16CE4D40245918065E88 v0.3.0 2017-04-06 Alpha 8AA7E83ED7A62A94F0833569A6A12FEE EMX File Date Status MD5 v0.12.0 2018-07-05 Alpha 19CA3E16199EBC7AFAD84DEBAB6BFDA1 v0.11.0 2018-05-10 Alpha 1BAF6CE1B9DC64403CB7A44199434272 v0.10.0 2018-04-05 Alpha D4BB6A5092FD4990E1E6F7FE3654ECE4 v0.9.0 2018-03-01 Alpha 678D3063595F07F9B0CEED62EDA3D646 v0.8.0 2018-02-01 Alpha 6A9638C2EE1B4E90A2FA08B7E16B61AF v0.7.0 2018-01-04 Alpha 2565650A2A476D61FF49EBC37BA6842B v0.6.0 2017-08-31 Alpha EA9C0E782CB3AA34EE4852E7538F6138 Embedded Master File Date Status MD5 v0.12.0 2018-07-05 Alpha A67F6D961E09BEBC49AD0B6EFC24222C v0.11.0 2018-05-10 Alpha C8D21E64C453B6172781467CB90D09A2 v0.10.0 2018-04-05 Alpha 4F83A28F864C03A45CA2A6B36E50FBCB v0.9.0 2018-03-01 Alpha 2A1C1A19418DF5CB6D3021D75FC617C0 v0.8.0 2018-02-01 Alpha CB254215C3D9499ABA58847324F55351 v0.7.0 2018-01-04 Alpha FDC1B41FA77A70FFF4DEDD696007F72F v0.6.0 2017-08-31 Alpha AD4E022B7F493B60BEEA3EBE685AB525 USBizi File Date Status MD5 v0.12.0 2018-07-05 Alpha DD20913A2CE20306BD3A22C33AB79F79 v0.11.0 2018-05-10 Alpha 074718553670F3ACC4B5BD03F493C737 v0.10.0 2018-04-05 Alpha D5633D66C1B0A4B4419C8E2D867F8FCF v0.9.0 2018-03-01 Alpha FF725F65D9B0024086D84CAF0818CF77 v0.8.0 2018-02-01 Alpha 7F738C57B223709B18E935BD6EC586A5 v0.7.0 2018-01-04 Alpha 7165508B530FE2C004B98B1AC9C6FB4B v0.6.0 2017-08-31 Alpha 20748AD886D5C20C8EF7B93AD8C522E9 Cerb File Date Status MD5 v0.12.0 2018-07-05 Alpha 8D57D8F7D619341482FE91FF96E8F34C v0.11.0 2018-05-10 Alpha E6612AD359CBFF44BFF0818B5250775A v0.10.0 2018-04-05 Alpha 9211446AB2556D7A16058429E9F36D1F v0.9.0 2018-03-01 Alpha 1AF970DD7ACC5924412D3A7655482C38 v0.8.0 2018-02-01 Alpha CA45384A7AB32DBAA393577D713FB639 v0.7.0 2018-01-04 Alpha 3DA2F43F1791051EAB92816AFCF7F0A9 v0.6.0 2017-08-31 Alpha 92BB5C076086AB581A1C64B40248297D v0.5.0 2017-07-07 Alpha 4F8C039EC6D0206D7FC97083E8765EC7 FEZ Hydra File Date Status MD5 v0.12.0 2018-07-05 Alpha 9D6680EC1ECE160703E4E8E3409F3647 v0.11.0 2018-05-10 Alpha D4D96DF5B1EFAB50EAB5A62C53A10F10 v0.10.0 2018-04-05 Alpha 1004BB46DA7A34FCBADD52C7226D687C v0.9.0 2018-03-01 Alpha 0050DA256930588E758ED6170177CEC7 v0.8.0 2018-02-01 Alpha 027E3CF379D81D9BE76B719FD470D52A"
  },
  "software/tinyclr/loaders/stm32-bootloader.html": {
    "href": "software/tinyclr/loaders/stm32-bootloader.html",
    "title": "The STM32 Bootloader",
    "keywords": "The STM32 Bootloader The STM32 Bootloader lives on all STM32 chips. The bootloader is used to load files (bootloaders and/or firmware) onto the chip. Several TinyCLR OS supported boards use this bootloader. These instructions apply to all STM32 chips with built in USB and DFU features. Loading the GHI Bootloader v2 The bootloader often comes pre-installed on our devices. It only needs to be installed once. It does not need to be reinstalled unless it becomes erased or corrupted. Download and save the latest bootloader file (v2.x.x). Download and install the DfuSe USB device firmware upgrade software from STMicroelectronics (click on the blue Get Software button). Run the DfuSeDemo program installed in the previous step. It should appear in the programs menu under STMicroelectronics . Put your board in DFU (Device Firmware Upgrade) mode. Instructions for putting your device in DFU mode are found on the documents page for the board you are using. STM Device in DFU Mode should now appear under Available DFU Devices at the upper left of the DfuSe Demo program screen. Near the bottom of the DfuSe Demo program window click on the Choose... button. Find the bootloader file you saved in step 1 (...Bootloader v2.x.x.dfu), click on it and click on the Open button. Now click on the upgrade button. If a dialog box appears with Your device was plugged in DFU mode... click the Yes button. You should see a message at the bottom of the DfuSe Demo window saying the upgrade was successful. Now reset the your device or click on the Leave DFU mode button. Congratulations! You have successfully installed the GHI STM32 bootloader! Creating a DFU file The DfuSe upgrade software only accepts DFU file types. You can create DFU files from .hex or .bin files using the DFU file manager software which is part of the DfuSe USB device firmware upgrade software download from step 2 of the above instructions. If you haven't already, download the DfuSe USB device firmware upgrade software from STMicroelectronics (click on the blue Get Software button). The instructions are slightly different depending on whether you are starting with a .hex or .bin file. From .hex files Find and open the \"Dfu file manager\" program. It should appear in the programs menu under STMicroelectronics . Select I want to generate a DFU file . Click on the S19 or Hex... button to select the .hex file. Click Generate... You now have a DFU file! From .bin files Find and open the \"Dfu file manager\" program. It should appear in the programs menu under STMicroelectronics . Select I want to generate a DFU file . Click on Multi BIN... button to select the .bin file. Change the address to 08000000 Click on the Add to list >> button then click the OK button. Click Generate... You now have a DFU file! Uploading DFU Files To set the STM32 chip in DFU mode, BOOT1 pin (if available) needs to be low and and BOOT0 needs to be high when the system powers up. If your system has a BOOT1 or BOOTA button, just hold the button down while powering the system up. The device manager will see a device called STM Device in DFU Mode . Find and open the DfuSe Demo program (from the ST download higher in this page). Under Upgrade and Verify Action , click the Choose... button and select the firmware DFU file you want to load. Click the Upgrade button. Click the Leave DFU mode button or reset the device. Congratulations, your board is now running the loaded firmware!"
  },
  "software/tinyclr/loaders/upgrading-v1-to-v2.html": {
    "href": "software/tinyclr/loaders/upgrading-v1-to-v2.html",
    "title": "Upgrading GHI Bootloader v1 to v2",
    "keywords": "Upgrading GHI Bootloader v1 to v2 Some of our devices come shipped with Bootloader v1 installed. These devices included Embedded Master, EMX, G120, G120E, and USBizi. Use the following instructions to upgrade devices from Bootloader v1 to Bootloader v2. To update using USB Download the bootloader file . Put your device in boot mode (instructions are found on each product's documentation page). The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! To update using serial (for Embedded Master and EMX) Connect your PC to COM1 on the device, pins 5 and 6 (through RS232 converter or a USB-Serial TTL cable). Set the down and select pins low on Embedded Master or the LMODE pin low on EMX. Follow the above steps starting at step 4 to load the firmware."
  },
  "hardware/fez/shields/pololu-zumo-robot.html": {
    "href": "hardware/fez/shields/pololu-zumo-robot.html",
    "title": "Pololu Zumo Robot",
    "keywords": "Pololu Zumo Robot The Pololu Zumo Robot from Pololu is one of our favorites, especially the pre-assembled version. Drop your FEZ on top of the Zumo Robot, or any other Arduino-compatible board, and you are ready to make the robot follow lines and dance around. The driver is found here . You are now ready for some serious dancing! public static void Main() { bool state = false; while (!ZumoBot.ButtonIsPressed()) { state = !state; ZumoBot.SetLed(state); ZumoBot.Beep(); Thread.Sleep(500); } Thread.Sleep(300); ZumoBot.SetLed(false); Thread.Sleep(300); ZumoBot.SetLed(true); Thread.Sleep(300); ZumoBot.SetLed(false); Thread.Sleep(300); ZumoBot.SetLed(true); while (true) { long left = ZumoBot.Reflectors.GetLevel(0); long right = ZumoBot.Reflectors.GetLevel(5); //Debug.WriteLine(\">\" + ZumoBot.Reflectors.GetLevel(0)); //System.Diagnostics.Debug.WriteLine(\"l: \" + left + \" r: \" + right); if (left < 8000 && right < 8000) { ZumoBot.Motors.Move(40, 40); } else { // backup and turn ZumoBot.Motors.MoveBackward(); Thread.Sleep(500); ZumoBot.Motors.Stop(); Thread.Sleep(1000); ZumoBot.Motors.TurnLeft(); Thread.Sleep(500); ZumoBot.Motors.Stop(); Thread.Sleep(1000); } Thread.Sleep(30); } }"
  },
  "hardware/gadgeteer/fez-cerbot.html": {
    "href": "hardware/gadgeteer/fez-cerbot.html",
    "title": "FEZ Cerbot",
    "keywords": "FEZ Cerbot A robot with reflective sensors and tons of LEDs. Gadgeteer sockets are used as an easy way to add features. Resources Schematic Software For information on programming the FEZ Cerbot, please go to the FEZ Cerberus page."
  },
  "hardware/gadgeteer/fez-cobra-ii.html": {
    "href": "hardware/gadgeteer/fez-cobra-ii.html",
    "title": "FEZ Cobra II Eco and Wi-Fi",
    "keywords": "FEZ Cobra II Eco and Wi-Fi FEZ Cobra II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Cobra II is the G120 System on Module (SoM). Resources Schematic Cobra II Extender schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Follow the instructions on the G120 page Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, press and hold the LDR0 button while resetting the board. Download the G120 firmware and follow Loading the Firmware steps."
  },
  "hardware/gadgeteer/fez-hydra.html": {
    "href": "hardware/gadgeteer/fez-hydra.html",
    "title": "FEZ Hydra",
    "keywords": "FEZ Hydra FEZ Hydra is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS TinyCLR is our own operating system and provides a means of programming embedded devices using .NET and Visual Studio. Visual Studio is widely regarded as one of the best (if not the best) integrated development environments available. The free Community version of Visual Studio can be downloaded here: Visual Studio Downloads . For information on setting up TinyCLR to work in Visual Studio please click here: TinyCLR Introduction Loading Bootloader v2 Download the bootloader file . Enter SAM-BA mode by connecting SPI1_MISO pin to ground and reset the board. Wait three seconds and remove the connection between SPI1_MISO and ground. SPI1_MISO is pin 8 on socket 3, and ground is pin 10. On later revisions of the board, you can hold down the small button labelled S1 near the processor instead. Open up the Device Manager, look under Ports, and find a COM port similar to \"Bossa Program Port\" or \"GPS Detect\". Follow the steps for the SAM-BA bootloader , connecting to the COM port in the previous step. The FEZ Hydra is based on the AT91SAM9RL64-EK. You may get a warning saying that external RAM access is required to run applets. Click yes that you do want to continue anyway. Gadgeteer Socket: Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 (socket 3, pin 3) signal low while resetting the board. Download the FEZHydra firmware and follow Loading the Firmware steps."
  },
  "hardware/scm/g120.html": {
    "href": "hardware/scm/g120.html",
    "title": "G120",
    "keywords": "G120 G120 and G120E are .NET Micro Framework (NETMF) System on Modules. Datasheet Pricing, purchasing and other information can be found on the G120 Page on our main website. Getting Started Options for programming the G120 include the following: Microsoft's .NET Micro Framework (NETMF) We discourage the use of NETMF software on our products in favor of TinyCLR OS. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. TinyCLR OS TinyCLR provides a way to program the G120 in C# or Visual Basic using Microsoft Visual Studio. To get started you must first install the bootloader and firmware on the G120 (instructions below) and then go to the TinyCLR Getting Started page for instructions on setting up the host computer and writing and deploying programs. Loading Bootloader v2 The G120 comes with Bootloader v1 pre-installed. To upgrade to Bootloader v2, follow the instructions on our Upgrading GHI Bootloader v1 to v2 page. To put the G120 into boot mode, set the LDR0 and LDR1 signals low while resetting the board. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 signal low while resetting the board. Download the G120 firmware and follow Loading the Firmware steps. G120 Development Board The development system used for evaluating the G120 SoM. Schematic TinyCLR lets you program our devices (and others) in C# or Visual Basic using Microsoft's Visual Studio -- and it's all free! Learn more... . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/scm/g120e.html": {
    "href": "hardware/scm/g120e.html",
    "title": "G120E",
    "keywords": "G120E Please see our G120 Page ."
  },
  "hardware/ucm/development-options.html": {
    "href": "hardware/ucm/development-options.html",
    "title": "UCM Development Options",
    "keywords": "UCM Development Options These options are provided to speed the development of your product and make it possible to start programming your application within minutes without designing or building new hardware. UCM Dev Board Schematic The UCM Dev Board is the fastest and easiest way to start using our Universal Compute Modules. This board provides a socket for the UCM, standard connectors for input/output, and three 40 pin socket headers for connecting peripherals and a display. Peripheral connectors include external power, Ethernet, CAN, USB host and client, RTC backup battery, DCMI interface and an SD card slot. It also has a buzzer, LEDs, a reset button, and user programmable boot buttons. Our display modules have mating 40 pin headers. The headers allow you to mount the display directly to the Dev Board or mount the display remotely using a standard IDE hard drive cable. To start development using the UCM Dev Board, just plug a UCM into the socket on the board and connect the board to a host computer using a micro USB cable. Go to the documentation page for the particular UCM you are using ( UC2550 , UC5550 or G400D ) for instructions on loading the latest bootloader and firmware and setting up your host computer. Then, start programming! UCM Breakout Board Schematic The UCM Breakout Board provides a socket for UCMs, and both through hole and surface mount edge connections for soldering the Breakout Board to your own circuit board. You can solder pin headers to the Breakout Board and use traditional breadboarding techniques to build your prototype as well. The breakout board also provides a reset button, four user programmable boot buttons, and a micro SD card slot. This board makes it easier to use UCMs in prototypes or products without the need to solder the fine pitch 200 pin SO-DIMM socket. The Breakout Board also provides a USB connector for connecting to a host computer. It does not, however, have a 3.3 volt regulator. 5 volts from the USB connector is available on a pad on the board (5V USB). You can wire your own regulator between this pad and the 3V3 pad to power this board over USB. These pads and a ground (GND) pad are conveniently located in close proximity at one corner of the board (see picture below). To get started using the Through Hole Module, it is only necessary to provide a 3.3 volt source and connect the module to a host computer using a micro USB cable. Then update your device with the latest bootloader and firmware and start coding! Go to the documentation page for the particular UCM you are using ( UC2550 , UC5550 or G400D ) for instructions on loading the latest bootloader and firmware and setting up your host computer. Displays These display boards are designed for use with the UCM Dev Board and UCM Breakout Board. They have a 40 pin male header connector that mates with the UCM Dev and Breakout boards directly or through a standard 40 pin IDE hard drive cable. If you want to mount the display board directly to the dev board, matching mounting holes are provided. To see sample code used to write to these displays please visit the Parallel TFT Displays section of our TinyCLR tutorials. UD435 Schematic Display Module: ER-TFT043-3 The UD435 supports either a 4.3 inch or 5 inch capacitive LCD touch screen. UD700 Schematic Display Module: ER-TFT070-4 The UD700 supports a 7 inch capacitive LCD touch screen. Designing your own circuit boards You can design your own circuit boards for UCMs by incorporating the correct SO-DIMM socket into your design. SO-DIMM stands for Small Outline Dual Inline Memory Module. Our UCMs use the 200 pin DDR2 SO-DIMM socket. There are two different 200 pin SO-DIMM sockets, those made for DDR memory and those made for DDR2 memory. They are identical except for the orientation notch which is in a slightly different position. These sockets are not interchangeable. There is also a 204 pin SO-DIMM socket for DDR3 memory with the notch positioned closer to the center of the module. Our UCMs are only compatible with DDR2 type 200 pin SO-DIMM sockets. Here is a link to the manufacturer's web page for the connector we use on our boards: EMBOSS ASSY DDR2 SODIMM SOCKET 200P 5.2H Need a solution for harsh or high vibration environments? Check out our SCMs . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/ucm/g400d.html": {
    "href": "hardware/ucm/g400d.html",
    "title": "G400D",
    "keywords": "G400D Overview The G400D System on Module (SoM) is the first of the Universal Compute Modules (UCMs) . Originally running .NET Micro Framework exclusively, it is now used with other platforms including TinyCLR. Pricing, purchasing and other information can be found on the G400D Page on our main website. Getting Started The UCM development options can greatly simplify the process of building a product or prototype using the G400D. Options include a development board and displays which can get you programming in minutes. Please refer to the Development Options page for more information. There are several options available for programming the G400D which are described below. Using Microsoft's .NET Micro Framework (NETMF) We discourage the use of NETMF software on our products in favor of TinyCLR OS. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Using TinyCLR OS TinyCLR provides a way to program the G400D in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the bootloader and firmware on the G400D (instructions below) and then go to the TinyCLR Getting Started page for instructions on setting up the host computer and writing and deploying programs. Loading Bootloader Version 2 Download the G400 bootloader file . Go to the SAMBA section of the Bootloaders Introduction page for instructions on loading the bootloader. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 signal low while resetting the board. On the UCM Dev board and UCM Breakout board, hold down the BOOT B button, press the RESET button and then release BOOT B. Download the G400 firmware and follow Loading the Firmware steps. Setup the Host Computer and Start Coding Now that you have installed the bootloader and firmware on the G400D, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Datasheet The G400D datasheet can be found here . Specifications Spec Value Processor Atmel AT91SAM9X35 ARM 926 Speed 400 MHz Internal RAM 32 KByte (SRAM) Internal Flash 0 KByte External RAM 128 MByte (DDR2 SDRAM) External Flash 4 MByte (SPI) Peripherals Peripheral UCM Standard Overall* UART 1 5 (including HS) UART HS 1 1 I2C 1 1 SPI 1 1 CAN 1 2 SDIO 1 1 ADC 8 8 PWM 4 4 GPIO 12 70 IRQ 4 70 USB Client Supported Supported USB Host 1 2 LCD Supported (16bpp) Supported (16bpp) Ethernet PHY Supported Supported Wi-Fi Not supported Not supported DCMI Not supported Not supported VBAT Supported Supported JTAG Full JTAG Full JTAG * The \"Overall\" column includes peripherals that fall outside of the UCM standard definition. Using these peripherals may reduce code portability with our other UCM models. Also, as many of these non-standard peripherals share I/O pins, not all of them will be available to your application. Pinout SO-DIMM Pin UCM Standard Function Name 1 AGND GND 2 Ethernet TX- ETH PHY TX- 3 Module Specific 1 4 Ethernet TX+ ETH PHY TX+ 5 Analog VREF- GND 6 Ethernet RX- ETH PHY RX- 7 Reserved 8 Ethernet RX+ ETH PHY RX+ 9 Reserved 10 Indicator A ETH PHY LED SPEED 11 Indicator B ETH PHY LED LINK 12 Reserved 13 GND GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND GND 28 PWM E 29 PWM F 30 PWM G 31 PWM H 32 Analog VREF+ 3.3V 33 Reserved 34 5V 35 Module Specific 4 PB3 36 Module Specific 5 PB4 (DNP) 37 Module Specific 6 PB5 38 Module Specific 7 PB6 39 Module Specific 8 PB7 40 GND GND 41 GND GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND GND 52 Module Specific 9 PB1 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A PD18 58 IRQ B PD17 59 IRQ C PD16 60 3.3V 3.3V 61 IRQ D PD15 62 GPIO A PD14 63 GPIO B PD13 64 GPIO C PD12 65 GND GND 66 GPIO D PD11 67 GPIO E PD10 68 GPIO F PD9 69 GPIO G PD8 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX 76 UART C RX 77 UART D TX 78 UART D RX 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX 90 UART B RX 91 ADC A PB8, ADC9 92 GPIO H PD2 93 SPI B MISO 94 SPI B MOSI 95 GND GND 96 SPI B SCK 97 ADC B PB11, ADC0 98 CAN A TD PA5, UART3 TX, CAN2 TX 99 CAN A RD PA6, UART3 RX, CAN2 RX 100 CAN B TD 101 CAN B RD 102 UART HS A TX PA0, UART2 TX 103 UART HS A RX PA1, UART2 RX 104 ADC C PB12, ADC1 105 PWM A PC18, PWM0 106 3.3V 3.3V 107 Bootstrap A SPI1 MISO 108 Module Specific 2 SPI1 MOSI 109 Module Specific 3 SPI1 SCK 110 ADC D PB17, ADC6 111 Bootstrap C PA4, LDR1 112 PWM B PC19, PWM1 113 GND GND 114 ADC E PB16, ADC5 115 I2C A SDA PA30, I2C SDA 116 I2C A SCL PA31, I2C SCL 117 UART A RX PA9, UART1 RX, CAN1 RX 118 UART A TX PA10, UART1 TX, CAN1 TX 119 GPIO I PC24 120 UART HS A RTS PA2, UART2 RTS 121 UART HS A CTS PA3, UART2 CTS 122 GPIO J PD7 123 SD Card D0 PA15, SD D0 124 3.3V 3.3V 125 SD Card CMD PA16, SD CMD 126 SD Card CLK PA17, SD CLK 127 SD Card D1 PA18, SD D1 128 SD Card D2 PA19, SD D2 129 SD Card D3 PA20, SD D3 130 PWM C PC21, PWM3 131 GND GND 132 GPIO K PC26 133 PWM D PC20, PWM2 134 Bootstrap B PA24 135 Bootstrap D PA25 136 GPIO L PA26 137 Module Specific 10 PA27 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX PC16, UART6 TX 141 UART HS B RX PC17, UART6 RX 142 3.3V 3.3V 143 LCD VSYNC PC27, LCD VSYNC 144 LCD HSYNC PC28, LCD HSYNC 145 LCD CLK PC30, LCD CLK 146 LCD DE PC29, LCD DE 147 Module Specific 11 PD3 148 SD Card CD PD4 149 Module Specific 12 PD5 150 Reserved 151 GND GND 152 LCD B3 PC0, LCD B3 153 LCD B4 PC1, LCD B4 154 LCD B5 PC2, LCD B5 155 LCD B6 PC3, LCD B6 156 LCD B7 PC4, LCD B7 157 ADC F PB13, ADC2 158 ADC G PB14, ADC3 159 ADC H PB15, ADC4 160 3.3V 3.3V 161 LCD G2 PC5, LCD G2 162 LCD G3 PC6, LCD G3 163 LCD G4 PC7, LCD G4 164 LCD G5 PC8, LCD G5, UART5 TX 165 LCD G6 PC9, LCD G6, UART5 RX 166 Module Specific 13 PD1 167 Indicator C PA8, UART4 RX 168 LCD R7 PC15, LCD R7 169 GND GND 170 LCD G7 PC10, LCD G7 171 LCD R3 PC11, LCD R3 172 LCD R4 PC12, LCD R4 173 LCD R5 PC13, LCD R5 174 LCD R6 PC14, LCD R6 175 SPI A SCK PA23, SPI2 SCK 176 SPI A MISO PA21, SPI2 MISO 177 Module Specific 14 WKUP 178 SPI A MOSI PA22, SPI2 MOSI 179 Module Specific 15 SHDN 180 3.3V 3.3V 181 Module Specific 16 PWR EN 182 Module Specific 17 USB H2+ 183 VBAT VBAT 184 Module Specific 18 USB H2- 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ USB H1+ 189 JTAG RTCK RTCK 190 USB Host D- USB H1- 191 JTAG TDO TDO 192 3.3V 3.3V 193 JTAG NTRST NTRST 194 USB Device D+ USB D+ 195 JTAG TDI TDI 196 USB Device D- USB D- 197 JTAG TCK (SWCLK) TCK 198 GND GND 199 JTAG TMS (SWDIO) TMS 200 Indicator D PA7, UART4 TX G400 Based products G400 Development Board The development system used for evaluating the G400 SoM. Schematic Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/tutorials/adc.html": {
    "href": "software/tinyclr/tutorials/adc.html",
    "title": "ADC",
    "keywords": "ADC Unlike digital input pins, which can only read high or low; analog pins can read a range of voltage levels. Microcontrollers based on 3.3V can typically read voltages anywhere between zero and 3.3V. Analog inputs connect internally to a Analog to Digital Converter (ADC) that converts the analog voltage level on the pin to a digital value. The resolution of the ADC determines its accuracy. An 8bit ADC has 256 steps to work with, 3.3V/256=0.013V. This means an increase of 0.013V will increase the value by one. In other words, a voltage change of less than 0.013V has no effect. The ADC on FEZ is 12bit and should fit most needs. Tip Note that the analog channel number is not the pin number. We have these easily enumerated for FEZ but you need to determine the channel number on a specific pin using your system's documentation. This example will read the ratio, that is 0 to 1, of an analog input. After running the program, connect a wire from the analog pin to ground and you should see a zero or something really close to zero. Connect to 3.3V and you will see 1 or something close, like 0.99. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { AdcController ADC = AdcController.GetDefault(); AdcChannel analog = ADC.OpenChannel(FEZ.AdcChannel.A0); while(true) { double d = analog.ReadRatio(); Debug.WriteLine(\"An-> \" + d.ToString(\"N2\")); Thread.Sleep(100); } } }"
  },
  "software/netmf/tutorials/usb-client.html": {
    "href": "software/netmf/tutorials/usb-client.html",
    "title": "USB Client",
    "keywords": "USB Client By default, all of GHI's NETMF devices use USB for deploying and debugging. You may optionally use the USB client (not the host) for something other than debugging. This is actually supported by NETMF and GHI adds more functionality making it even easier to use. Say you are making a device that that reads temperature and humidity and logs all of this data on an SD card. This device can be configured to set the time or give file names and you want this configuration to happen over USB, perhaps in the field. So when your device plugs into a USB port, you want it to show as a virtual serial port. This way, anyone can open a terminal software (like TeraTerm) to connect to your device and configure it. Using the USB client, there is no need to add the extra cost of additional RS232 serial ports or USB<->serial chipsets. The built-in USB client port can be configured to act as a CDC device, a virtual COM port. However, you still need to connect the PC to your device for debugging and deploying applications. Since the USB client port is used by your end application, you need to debug and deploy using a serial connection. You only need the serial interface in the development and deployment stage. Setting Up Debugging and deploying serially is specific to each device so you may want to consult your device's manual or Developers' Guide. Once the device is configured for the serial interface, remember to select the proper transport in Visual Studio. Tip The examples shown below require the Microsoft.SPOT.Hardware.Usb and GHI.Usb assemblies. Mouse The following example tells your device to act as a mouse and send random commands to your computer. You could use this to prank others and send their computer fake mouse commands or to have a second mouse for your own computer. using System; using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start Mouse Mouse mouse = new Mouse(); Controller.ActiveDevice = mouse; // Move pointer in a swirl const int ANGLE_STEP_SIZE = 15; const int MIN_CIRCLE_DIAMETER = 50; const int MAX_CIRCLE_DIAMETER = 200; const int CIRCLE_DIAMETER_STEP_SIZE = 1; int diameter = MIN_CIRCLE_DIAMETER; int diameterIncrease = CIRCLE_DIAMETER_STEP_SIZE; int angle = 0; int factor; Random rnd = new Random(); int i = 0; while (true) { // we want to do it every sometime randomely i = rnd.Next(5000) + 5000;//between 5 and 10 seconds Debug.Print(\"Delaying for \" + i + \" ms\"); Thread.Sleep(i); i = rnd.Next(200) + 100;//do it for a short time Debug.Print(\"Looping \" + i + \" times!\"); while (i-- > 0) { // Check if connected to PC if (Controller.State == UsbController.PortState.Running) { // Note Mouse X, Y are reported as change in position // (relative position, not absolute) factor = diameter * ANGLE_STEP_SIZE * (int)System.Math.PI / 180 / 2; int dx = (-1 * factor * (int)Microsoft.SPOT.Math.Sin(angle) / 1000); int dy = (factor * (int)Microsoft.SPOT.Math.Cos(angle) / 1000); angle += ANGLE_STEP_SIZE; diameter += diameterIncrease; if (diameter >= MAX_CIRCLE_DIAMETER || diameter <= MIN_CIRCLE_DIAMETER ) diameterIncrease *= -1; // report mouse position mouse.SendRawData(dx, dy, 0,Buttons.None); } Thread.Sleep(10); } } } } Keyboard Emulating a keyboard is as very similar to emulating a mouse. The following example will create a USB Keyboard and send \"Hello world!\" to a computer every second. using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start keyboard Keyboard kb = new Keyboard(); Controller.ActiveDevice = kb; Debug.Print(\"Waiting to connect to PC...\"); // Send \"Hello world!\" every second while (true) { // Check if connected to PC if ( Controller.State == UsbController.PortState.Running) { // We need shift down for capital \"H\" kb.Press(Key.LeftShift); kb.Stroke(Key.H); kb.Release(Key.LeftShift); // Now \"ello world\" kb.Stroke(Key.E); kb.Stroke(Key.L); kb.Stroke(Key.L); kb.Stroke(Key.O); kb.Stroke(Key.Space); kb.Stroke(Key.W); kb.Stroke(Key.O); kb.Stroke(Key.R); kb.Stroke(Key.L); kb.Stroke(Key.D); // The \"!\" kb.Press(Key.LeftShift); kb.Stroke(Key.D1); kb.Release(Key.LeftShift); // Send an enter key kb.Stroke(Key.Enter); } Thread.Sleep(1000); } } } CDC - Virtual Serial Port Serial ports are the most common interface, especially in the embedded system world. It is an ideal solution for devices to transfer data between computers and embedded devices NETMF products. To combine the popularity and usefulness of USB with the ease of serial, we have virtual USB devices. To Windows' applications or devices, a virtual serial port works just like a serial port but it is actually a USB port. To use CDC, you need the USB Drivers that come with the GHI Electronics NETMF and Gadgeteer SDK (2016 R1 and later). This will only work if you use the default constructor of the Cdc class. If you do not and you provide different Vendor and Product Ids, this driver will not work and you will need to create your own. You can use the one we provide in the SDK as a model, though it will not be signed. Note: CDC drivers usually handle one transaction in every frame. The max EP size on USB is 64 bytes and there 1000 frames per second on full-speed USB. This means that the maximum transfer rate in ideal conditions for CDC is 64KB/sec. The buffer size is limited so you must be make sure to read all data quickly because there is no overflow event. The following example will create a USB CDC and send \"Hello world!\" to computer every second. using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start Cdc Cdc vsp = new Cdc(); Controller.ActiveDevice = vsp; // Send \"Hello world!\" to PC every second. (Append a new line too) byte[] bytes = System.Text.Encoding.UTF8.GetBytes(\"Hello world!\\r\\n\"); while (true) { // Check if connected to PC if (Controller.State != UsbController.PortState.Running) { Debug.Print(\"Waiting to connect to PC...\"); } else { vsp.Stream.Write(bytes, 0, bytes.Length); } Thread.Sleep(1000); } } } Mass Storage GHI's USB client supports Mass Storage Class (MSC). This allows access to connected media right from USB. For example, a data logger application that needs to save data to an SD card or USB memory. When the user is done collecting data, they can plug the USB data logger into the PC and now the PC can detect the device as a mass storage device. The user can then transfer the files using standard operating system controls. It may be helpful to think of the device as a memory card reader. We can even enhance our logger where the USB client interface can be CDC to configure the device and later dynamically switch to MSC to transfer files. Once very common question on GHI support is \"Why can't I access the media from my application while the media is also accessed externally (from windows)?\" Due to caching of file system data and/or the possibility of a write from one interface while the other is doing a read and/or a write, data on the media and/or data used by the interface will likely (and quickly) be corrupted. Note: you can easily switch back and forth between internal file system and USB MSC. This example code assumes an SD card is always plugged in. It enables MSC showing the device as a card reader. This code assumes that the USB port is NOT being used for debugging. In addition to the assemblies mentioned above in the Note, the following code requires the GHI.Hardware assembly. using System; using System.Threading; using GHI.Usb.Client; using GHI.Usb; using GHI.IO.Storage; public class Program { public static void Main() { // Start MS MassStorage ms = new MassStorage(); Controller.ActiveDevice = ms; // Assume SD card is connected SDCard sd; try { sd = new SDCard(); } catch { throw new Exception(\"SD card not detected\"); } ms.AttachLogicalUnit(sd,0, \" \", \" \"); // enable host access ms.EnableLogicalUnit(0); Thread.Sleep(Timeout.Infinite); } } HID and Custom Devices Windows and other operating systems have built in drivers for USB HID (Human Interface Devices). These drivers are ideal as they provide a simple way to transfer data between a computer and a device. HID's are usually mice and keyboards but they can also be simple data transfer devices. Although examples in codeshare may need changes for differences in SDK releases, this project provides a good example: http://www.ghielectronics.com/community/codeshare/entry/420 The GHI USB Client allows you to control the USB client in anyway you like. This feature requires advanced knowledge of USB. If you do not know what an EndPoint or a Pipe is then do not attempt to create custom devices. It is very important to have the device configured correctly the first time it is plugged into Windows since Windows stores a lot of information in its registry. If you change the configuration of your device after you had it plugged into Windows previously, Windows may not see the changes since it will be using the old configuration from its registry. Do not use USB Client Custom Devices unless you really have good reason to use them and you are knowledgeable in USB and Windows drivers."
  },
  "index.html": {
    "href": "index.html",
    "title": "GHI Electronics Documentation",
    "keywords": "GHI Electronics Documentation Here you will find GHI Electronic's product documentation. For more information visit the main website at www.ghielectronics.com . You can also visit our community forums at forums.ghielectronics.com . Note Please check back often for the latest updates to our products, documentation, and software. Product Sections UCMs (Universal Compute Modules) Interchangeable plug-in microcontroller modules suitable for a wide variety of applications. Learn More... SCMs (Surface Compute Modules) Surface mount microcontroller modules ideal for harsh or high vibration environments. Learn More... FEZ The Maker Board to Rule Them All! Learn More... TinyCLR Operating System TinyCLR OS is light weight .NET operating system for IoT and embedded devices. Learn More... NETMF The original embedded .NET upon which TinyCLR OS is based Learn More... Legacy Products Here you will find information on GHI's legacy products and longevity policy. Learn More... You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/fez/shields/seeed-grove-starter-kit.html": {
    "href": "hardware/fez/shields/seeed-grove-starter-kit.html",
    "title": "Seeed Grove Starter Kit",
    "keywords": "Seeed Grove Starter Kit Grove is a modular electronic platform for quick prototyping. Every module has one function, such as touch sensing, creating audio effects and so on. Just plug the modules you need to the base shield, then you are ready to test your ideas. We have picked the Seeed Grove Starter Kit for Arduino as a starting base but you can add additional Grove modules as well. The included Grove modules plug into the included arduino shield. This shield works with any arduino pinout compatible board, like the FEZ . You can get the drivers here . This video discusses using Seeed Studio Grove Modules with our FEZ products. This example makes some noise! Buzzer buzz = new Buzzer(FEZ.GpioPin.D4); buzz.Beep(); Thread.Sleep(5000); buzz.TurnOn(); Thread.Sleep(1000); buzz.TurnOff(); while(true) { buzz.Beep(); Thread.Sleep(1000); } This example will read the temperature TemperatureSensor temp = new TemperatureSensor(FEZ.AdcChannel.A1); while(true) { Debug.WriteLine(\"-> \" + temp.ReadTemperature()); Thread.Sleep(1000); } This example will show some text on the character display. LcdRgbBacklight lcd = new LcdRgbBacklight(); lcd.Clear(); lcd.SetBacklightRGB(100, 100, 0); lcd.BlinkBacklight(true); lcd.BlinkBacklight(false); lcd.Write(\"*** TinyCLR ***\"); Thread.Sleep(1000); lcd.SetCursor(0, 1); lcd.Write(\"Count:\"); int count = 0; while (true) { lcd.SetCursor(7, 1); lcd.Write(count.ToString()); count++; lcd.SetBacklightRGB(100, 100, (byte)count); Thread.Sleep(100); } Warning Pay attention to the 3.3V-5V switch on the shield. The rotary and temperature sensors only work with 3.3V but the RGB character display only works with 5V. Since the character display connects to I2C and only works with 5V. We have modified one of the I2C sockets to be always 5V. This allows us to keep the switch at 3.3V, leaving all other sockets at 3.3V. Warning These steps require some experience and will void your warranty! Start by cutting the power trace going to the last socket. (image) Now, add a wire from the socket directly to 5V. (image)"
  },
  "hardware/gadgeteer/fez-cobra-ii-net.html": {
    "href": "hardware/gadgeteer/fez-cobra-ii-net.html",
    "title": "FEZ Cobra II Net",
    "keywords": "FEZ Cobra II Net FEZ Cobra II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Cobra II is the G120 System on Module (SoM). Resources Schematic Cobra II Extender schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Follow the instructions on the G120 page Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, press and hold the LDR0 button while resetting the board. Download the G120 firmware and follow Loading the Firmware steps."
  },
  "hardware/gadgeteer/fez-reaper.html": {
    "href": "hardware/gadgeteer/fez-reaper.html",
    "title": "FEZ Reaper",
    "keywords": "FEZ Reaper FEZ Reaper is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Reaper is the G80 System on Chip (SoC). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 The G80 SoC ships with the Bootloader loaded and locked. No further steps are necessary. Loading the Firmware To activate bootloader v2, press and hold both LDR0 and LDR1 buttons down while resetting the board. Download the G80 firmware and follow Loading the Firmware steps."
  },
  "hardware/scm/embedded-master.html": {
    "href": "hardware/scm/embedded-master.html",
    "title": "Embedded Master",
    "keywords": "Embedded Master Embedded Master is a NETMF System on Module. Resources User Manual Using NETMF software We discourage the use of NETMF software on our products in favor of TinyCLR OS, but the choice is up to you. Embedded Master will only work with the NETMF 4.1 SDK. To find out more about NETMF, go to our NETMF Introduction Page Using TinyCLR OS The following instructions describe how to set up Embedded Master to work with TinyCLR OS. To learn more about TinyCLR check out the TinyCLR Introduction page. Loading Bootloader v2 Tip Bootloader version 1 doesn't always work with Windows version 7 and later (Error code 10). You can use the serial option to update the loader. This is a one-time procedure. You should have no issues after bootloader V2 is installed. Embedded master comes with Bootloader v1 pre-installed. To install v2 of the bootloader, follow the instructions on the Upgrading GHI Bootloader v1 to v2 page. To put your Embedded Master board into boot mode, set the up, down, and select pins (3, 7, and 53 on TFT or 43 on non-TFT) low and reset the board. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set the up pin low and then reset your board. To enter USB mode, set the select pin. Download the EMX firmware and follow Loading the Firmware steps."
  },
  "hardware/scm/emx.html": {
    "href": "hardware/scm/emx.html",
    "title": "EMX System on Module",
    "keywords": "EMX System on Module EMX is a NETMF System on Module. Resources User Manual Using NETMF software We discourage the use of NETMF software on our products in favor of TinyCLR OS, but the choice is up to you. To find out more about NETMF, go to our NETMF Introduction Page Using TinyCLR OS The following instructions describe how to set up EMX to work with TinyCLR OS. To learn more about TinyCLR check out the TinyCLR Introduction page. Loading Bootloader v2 Tip The bootloader version 1 doesn't always work with Windows 7 and newer (Error code 10). You can use the serial option to update the loader. This is a one-time procedure. You should have no issues after the bootloader V2 is loaded. EMX comes with Bootloader v1 pre-installed. To install v2 of the bootloader, follow the instructions on the Upgrading GHI Bootloader v1 to v2 page. To put EMX in boot mode, make pins 3,7 and 53 low and reset the board (Pin3=P0.4 | Pin7=P2.5 | Pin53=P2.11). Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set Pin3 low (double check) and then reset your board. Download the EMX firmware and follow Loading the Firmware steps. EMX Dev Sys The development system used for evaluating the EMX SoM. Schematic"
  },
  "hardware/scm/intro.html": {
    "href": "hardware/scm/intro.html",
    "title": "Surface Mount Compute Modules",
    "keywords": "Surface Mount Compute Modules SCMs are surface mount embedded controllers that are well suited to harsh or high vibration environments. A variety of tools and software options are available. Check the individual product documentation for details. G30 Learn more... G80 Learn more... G120 / G120E Learn more... G400S Learn more... TinyCLR lets you program our devices (and others) in C# or Visual Basic using Microsoft's Visual Studio -- and it's all free! Learn more... . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "legacy/som.html": {
    "href": "legacy/som.html",
    "title": "Legacy System on Modules",
    "keywords": "Legacy System on Modules With the rapid advance of technology it can be hard to stay current. We take pride in our support of past products while we work hard to provide our customers with the best new technology. Legacy product should not be used for new designs; however, many of our older products can still be produced (minimum order may be required). Please contact us for information on the production of legacy products or the recommended upgrade path to current or planned products."
  },
  "software/netmf/tutorials/can.html": {
    "href": "software/netmf/tutorials/can.html",
    "title": "CAN",
    "keywords": "CAN Controller Area Network (CAN) is a very common interface in industrial and automotive control. CAN is very robust and works very well in noisy environments at high speeds. All error checking and recovery methods are done automatically on the hardware. TD (Transmit Data) and RD (Receive Date) are the only two pins needed. There is no master/slave relationship in CAN. All nodes are equal and can both transmit and receive. CAN includes a protocal which easily allows for a node to claim a slice of time for its use so that collisions do not occur. You must have at least two nodes on the bus, however, or CAN will not work. There are many kinds of physical layers, but the most commonly used is a high-speed-dual wire that uses a twisted pair for noise immunity. This transceiver can run at up to 1 Mbit/s and can transfer data on very long wires if a low bit rate is used. Data can be transferred between nodes on the bus where any node can transfer at any time and all other nodes are required to successfully receive the data. All nodes must have a predefined bit timing criteria. This is much more complicated than calculating a simple baud rate for UART. For this reason, many CAN bit rate calculators are available which you can find using a simple internet search. We provide a few precalculated speeds that you can use but you can create more precise custom timings if you wish. There is an informative CAN guide in our downloads. The above image shows two CAN nodes connected over a bus with the 120 ohm resistors required on these transceivers. Tip Make sure to check the datasheet from the tranceiver. Most CAN controllers will divide the frequency by 2 before actually using it. Getting Started The code below sends a message over the CAN bus and prints out every message it receives to the debug window. It requires the GHI.Hardware assembly be added to the resources in your Visual Studio project. using GHI.IO; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { var can = new ControllerAreaNetwork(ControllerAreaNetwork.Channel.One, ControllerAreaNetwork.Speed.Kbps1000); can.ErrorReceived += can_ErrorReceived; can.MessageAvailable += can_MessageAvailable; can.Enabled = true; can.SendMessage(new ControllerAreaNetwork.Message() { Data = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 }, ArbitrationId = 0x12345678, Length = 8, IsRemoteTransmissionRequest = false, IsExtendedId = true }); Thread.Sleep(-1); } private static void can_MessageAvailable(ControllerAreaNetwork sender, ControllerAreaNetwork.MessageAvailableEventArgs e) { var received = sender.ReadMessage(); var data = string.Empty; for (int i = 0; i < received.Length; i++) data += \"0x\" + received.Data[i].ToString(\"x2\") + \" \"; Debug.Print(\" CAN Message \"); Debug.Print(\"-----------------\"); Debug.Print(\" ID: \" + received.ArbitrationId.ToString()); Debug.Print(\" Time: \" + received.TimeStamp.ToString()); Debug.Print(\" RTR: \" + received.IsRemoteTransmissionRequest.ToString()); Debug.Print(\" EID: \" + received.IsExtendedId.ToString()); Debug.Print(\"Length: \" + received.Length.ToString()); Debug.Print(\" Data: \" + data); Debug.Print(\"\"); } private static void can_ErrorReceived(ControllerAreaNetwork sender, ControllerAreaNetwork.ErrorReceivedEventArgs e) { Debug.Print(\"Error on CAN: \" + e.Error.ToString()); } }"
  },
  "hardware/mbuino.html": {
    "href": "hardware/mbuino.html",
    "title": "mBuino",
    "keywords": "mBuino The mBuino is a tiny keychain circuit. It is GHI Electronics contribution to the mbed community. Learn more here Schematic Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/netmf/tutorials/analog-out.html": {
    "href": "software/netmf/tutorials/analog-out.html",
    "title": "Analog Outputs",
    "keywords": "Analog Outputs An analog output sets the voltage on its pin anywhere between 0 and the supplied voltage (maximum voltage) which is typically 3.3 volts. The output voltage is only a signal, not meant to drive any loads. An op-amp or similar circuit can be added to drive loads, such as a speaker. The analog out on a micro has \"precision:\" the precision of a particular processor is in its manual or datasheet; consequentially, actual output values on the pin are an approximation. For example, a micro with an 8-bit (256 steps) analog out has a step precision of 3.3V/256. In NETMF, the voltage to be output is specified as a percentage called the \"level.\" So, on a processor with a maximum output of 3.3V, a level of 0.5 (50%) would output around 1.65V. NETMF has two properties for the AnalogOutput class: Scale and Offset. The final voltage on the output pin will be: Final voltage = maximum output * ( (level*Scale) + Offset)) Final voltages are clipped to fit in the range 0V to maximum pin voltage. Example The processor in this example has a maximum output of 3.3 volts. The 50% voltage (level == 0.5) by default would generate 1.65V. Because of Scale, the actual percent will be 10 (0.5 * 0.2), which results in an output voltage of about 0.33V (3.3V * 0.1). The following code requires the Microsoft.SPOT.Hardware assembly. using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //Setup Analog on the first analog output channel AnalogOutput output = new AnalogOutput( Cpu.AnalogOutputChannel.ANALOG_OUTPUT_0); output.Scale = 0.2; output.Write(0.5); //output approx. 0.33V } }"
  },
  "software/netmf/tutorials/uart.html": {
    "href": "software/netmf/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART UART transfers data between two pins TXD (transmit) and RXD (receive). Normally, the pins are on different processors. Data is sent from TXD, in a sequence, at a predefined speed. The receiver checks data on RXD. Usually systems want to send and recieve as well, so there will be a TXD and RXD on one end with another set on the other end. The connection in between is rossed so TXD on one end goes to RXD on the other end and vice versa. UART Technical Details The \" baud rate\" is number of bits are transmitted per second; standard baud rates are 9600, 119200, 115200 and others. Direct connection between TXD/RXD pins use their high/low voltages for bits (\"TTL level,\" 0V to 3.3V). NETMF supports serial ports (UART) in the same way as the full .NET framework. Serial ports on PC's and on NETMF are called \"COM ports.\" Their names start with COM1 and go up (there is no COM0). Processors usually start with UART0 not UART1 (so, COM1 is UART0... etc.) Software UART Through GHI's SignalGenerator, a system can simulate a UART data. This is beneficial as any GPIO pin can be used to send the UART data. A good example is a serial character display. These typically do not require speed and not updated frequently. If all UARTs are being used, any GPIO can be used to simulate a UART transmission. RS232 Processor pins can be set at 0 for low or at the power level for high, 3.3V for example. This means connecting outputs on a micro to inputs on another is safe. These levels are called TTL. In our case here a TTL UART levels. To overcome distances, the very old standard RS232 defined the low state to be +12V. Sounds like it is backwards but this is how it is! This port is found on many systems and found on many PCs. It has been disappearing from PCs lately but this can be easily added using a USB to serial cable. We can't connect the RS232 levels to TTL levels directly. This is easily solved by adding a small circuitry that converts the RS232 levels to TTL, like the MAX232 chip. In other words, do not connect a PC's serial port to a micro directly. Use a level converter in between. Example using UART The following program sends a counter value 10 times per second. The data is sent at 115200 baud so make sure that the receiving end is setup the same way. This program sends the data on COM1 of your NETMF device. This COM number has nothing to do with COM number on your PC. For example, you may have a USB serial port on your PC that maps to COM8 and so you need to open COM8 on your PC, not COM1. The NETMF program will still use COM1 because it uses UART0 (COM1). The data sent can be shown on a terminal program, like teraterm. Note how we ended the string with \"\\r\\n\". The \"\\r\" is code to tell the terminal to \"return\" back to the beginning of the line and \"\\n\" is to add \"new\" line. When data is received on UART, it is automatically queued a side so you wouldn't lose any data. Tip Using serial ports require the Microsoft.SPOT.Hardware.SerialPort. If your program uses the enums Parity or StopBits, the Microsoft.SPOT.Hardware assembly is needed. using System.IO.Ports; using System.Text; using System.Threading; public class Program { public static void Main() { SerialPort UART = new SerialPort(\"COM1\", 115200); int counter = 0; UART.Open(); while (true) { // create a string string counter_string = \"Count: \" + counter.ToString() + \"\\r\\n\"; // convert the string to bytes byte[] buffer = Encoding.UTF8.GetBytes(counter_string); // send the bytes on the serial port UART.Write(buffer, 0, buffer.Length); // increment the counter; counter++; //wait... Thread.Sleep(100); } } } Receiving Data This example will wait until a byte is received on the port and then print it telling you what was sent from the other end. using System.Threading; using System.IO.Ports; using System.Text; public class Program { public static void Main() { SerialPort UART = new SerialPort(\"COM1\", 115200); int read_count = 0; byte[] rx_byte = new byte[1]; UART.Open(); while (true) { // read one byte read_count = UART.Read(rx_byte, 0, 1); if (read_count > 0)// do we have data? { // create a string string counter_string = \"You typed: \" + rx_byte[0].ToString() + \"\\r\\n\"; // convert the string to bytes byte[] buffer = Encoding.UTF8.GetBytes(counter_string); // send the bytes on the serial port UART.Write(buffer, 0, buffer.Length); //wait... Thread.Sleep(10); } } } } Sending and Receiving This example is a loop-back. Connect a wire from TX to RX on your board and it will send data and make sure it is receiving it correctly. using System.IO.Ports; using System.Text; using System.Threading; using Microsoft.SPOT; public class Program { public static void Main() { SerialPort UART = new SerialPort(\"COM1\", 115200); int read_count = 0; byte[] tx_data; byte[] rx_data = new byte[10]; tx_data = Encoding.UTF8.GetBytes(\"FEZ\"); UART.ReadTimeout = 0; UART.Open(); while (true) { // flush all data UART.Flush(); // send some data UART.Write(tx_data, 0, tx_data.Length); // wait to make sure data is transmitted Thread.Sleep(100); // read the data read_count = UART.Read(rx_data, 0, rx_data.Length); if (read_count != 3) { // we sent 3 so we should have 3 back Debug.Print(\"Wrong size: \" + read_count.ToString()); } else { // the count is correct so check the values // I am doing this the easy way so the code is more clear if (tx_data[0] == rx_data[0]) { if (tx_data[1] == rx_data[1]) { if (tx_data[2] == rx_data[2]) { Debug.Print(\"Perfect data!\"); } } } } Thread.Sleep(100); } } } Tip For .NET Gadgeteer examples, see the Device to PC communications document."
  },
  "hardware/breakout/fez-rhino.html": {
    "href": "hardware/breakout/fez-rhino.html",
    "title": "FEZ Rhino",
    "keywords": "FEZ Rhino Resources Schematic Software For information about programming the FEZ Rhino, please visit our USBizi page."
  },
  "hardware/breakout/g400-th.html": {
    "href": "hardware/breakout/g400-th.html",
    "title": "G400 TH Module",
    "keywords": "G400 TH Module A through-hole version of G400. Resources Schematic Software For information on programming the G400 TH Module please refer to the G400D page."
  },
  "hardware/duino/fez-mini.html": {
    "href": "hardware/duino/fez-mini.html",
    "title": "FEZ Mini",
    "keywords": "FEZ Mini Resources Schematic Software For information on programming the FEZ Mini, please go to the USBizi page."
  },
  "hardware/duino/fez-panda.html": {
    "href": "hardware/duino/fez-panda.html",
    "title": "FEZ Panda",
    "keywords": "FEZ Panda An Arduino-pinout compatible board. Resources Schematic Software For information on programming the FEZ Panda, please go to the USBizi page."
  },
  "software/tinyclr/tutorials/gpio-change-reader.html": {
    "href": "software/tinyclr/tutorials/gpio-change-reader.html",
    "title": "Gpio Change Reader",
    "keywords": "Gpio Change Reader Gpio Change Reader works in the current release. Documentation is coming soon. var reader = new GpioChangeReader(FEZ.GpioPin.A1, GpioPinDriveMode.InputPullUp); See this for now https://old.ghielectronics.com/docs/106/signal-capture"
  },
  "software/tinyclr/tutorials/gpio-change-writer.html": {
    "href": "software/tinyclr/tutorials/gpio-change-writer.html",
    "title": "Gpio Change Writer",
    "keywords": "Gpio Change Writer Gpio Change Writer works in the current release. Documentation is coming soon. var writer = new GpioChangeWriter(FEZ.GpioPin.A1, false); See this for now https://old.ghielectronics.com/docs/24/signal-generator"
  },
  "hardware/gadgeteering.html": {
    "href": "hardware/gadgeteering.html",
    "title": "Gadgeteering",
    "keywords": "Gadgeteering Gadgeteering was meant to extend Gadgeteer beyond NETMF. We are making our hardware and software available for reference only. All material is found at this github repository Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/duino/fez-cerbuino-bee.html": {
    "href": "hardware/duino/fez-cerbuino-bee.html",
    "title": "FEZ Cerbuino Bee",
    "keywords": "FEZ Cerbuino Bee An Arduino-pinout compatible single board computer with Gadgeteer sockets. Resources Schematic Software For information on programming the FEZ Cerbuino Bee, please go to the FEZ Cerberus page."
  },
  "hardware/duino/intro.html": {
    "href": "hardware/duino/intro.html",
    "title": "Duino Intro",
    "keywords": "Duino Intro Our Duino boards offer Arduino pinout compatible sockets that will accept standard Arduino expansion boards or \"shields.\" They run TinyCLR and can be programmed in C# or Visual Basic using the Microsoft Visual Studio development environment."
  },
  "hardware/fez/mbed.html": {
    "href": "hardware/fez/mbed.html",
    "title": "Mbed",
    "keywords": "Mbed Mbed is an online compiler platform. There is nothing to install, just log in and start coding! One of the supported boards is the Nucleo-F401RE, which uses the exact same microcontroller as the FEZ. Use it as your target to build and compile to a .bin file, and then follow the instructions on the STM32 bootloader page to create a .dfu file and upload it to the FEZ. This video shows how to use Mbed to program the FEZ (The FEZ and the BrainPad share the same processor). mbed Website Nucleo-F401RE Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/fez/tinyclr.html": {
    "href": "hardware/fez/tinyclr.html",
    "title": "TinyCLR OS",
    "keywords": "TinyCLR OS TinyCLR is our own operating system and allows you to program the FEZ in C# or Visual Basic using Microsoft's Visual Studio development environment. To start using TinyCLR with the FEZ you must first: Set up your computer: Install Visual Studio, the TinyCLR OS extensions and NuGet packages. Set up your FEZ: Install the GHI bootloader (if not installed already) and latest TinyCLR firmware. Setting Up Your Computer Instructions for setting up your computer are found here on the [Getting Started]under the TinyCLR section of our documentation. Setting Up the FEZ The following instructions explain how to install the bootloader and TinyCLR firmware on the FEZ. The bootloader should be installed on the FEZ already. It does not need to be reinstalled unless it becomes deleted or corrupted. The firmware may come pre-installed on the FEZ, but it might not be the latest version. If you are having problems or just want to make sure your FEZ is up to date with the latest release, use the TinyCLR Config tool to install the latest firmware. We have also included instructions for manually installing the firmware if that's what you prefer. Loading the GHI Bootloader v2 The bootloader comes pre-installed on the FEZ and should not need to be reinstalled unless it is erased or becomes corrupted. Also, some advanced programming techniques require you to erase the bootloader (for example Mbed). If you do need to reinstall the bootloader instructions are found on the STM32 Bootloader page under Loading the GHI Bootloader v2 . When you are asked to put the FEZ in DFU mode, hold down the BOOT0 button, press and release the RESET button, and then release the BOOT0 button. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. Using TinyCLR Config Our TinyCLR Config tool includes multiple features useful for working with TinyCLR-OS-enabled devices. It simplifies the firmware update and it includes options for accessing the TinyCLR firmware at runtime. Using this tool is the recommended path; however, the instructions for manually loading the firmware are included below. Read more on the TinyCLR Config page. Manually Loading the Firmware We recommend using the TinyCLR Config tool to update the firmware. As a backup, use these instructions: Download and save the latest FEZCLR firmware Put the FEZ in bootloader mode: Hold down BTN1, press and release the RESET button, and then release BTN1. Open any terminal software, for example Tera Term , Select serial and pick the COM port associated with your board. (If unsure, check Device Manager) Press V and then enter. The FEZ will respond with the installed boot loader version number (v2.x.x) Press U and then enter to start the upload firmware procedure. Press Y to confirm then enter. The FEZ will respond with CCCC ... Go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the firmware file you downloaded in step 1. When the transfer is complete, press the RESET button on the FEZ. Check out our TinyCLR Tutorials ! Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/fez/shields/arduino-uno-click-shield.html": {
    "href": "hardware/fez/shields/arduino-uno-click-shield.html",
    "title": "MikroElektronika Arduino UNO Click Shield",
    "keywords": "MikroElektronika Arduino UNO Click Shield Through MikroElektronika's mikroBUS standard , hundreds of Mikro's Click boards can be easily connected to your board. The BrainPad has sockets for plugging in click boards. This video talks about the technology behind SPI bus, shift registers, and serial-parallel data. It uses the LED ring click on the BrainPad. The source code is found here . You can use these click boards with FEZ , or any other Arduino-pinout compatible board, through the Arduino UNO click shield . The same code used above with the BrainPad can be used with FEZ and the Arduino UNO click shield. Simply, change the pins from BrainPad to FEZ. The pins are labeled right on the shield. For example, the CS pin on socket 1 is labeled CS/D10 . The complete project is found here"
  },
  "software/tinyclr/tutorials/can.html": {
    "href": "software/tinyclr/tutorials/can.html",
    "title": "CAN",
    "keywords": "CAN Controller Area Network (CAN) bus is a two wire serial communication protocol which was originally released at the 1986 Society of Automotive Engineers (SAE) congress in Detroit. The first vehicle to use CAN reduced the weight of its wiring by over 100 pounds. While CAN was originally designed for use in cars to reduce the amount of wiring, the use of CAN has expanded and it can now be found in avionics, hospitals, assembly lines, and even some bicycles and prosthetic limbs. Some features that make CAN so popular include: High speed (up to 1 megabit/second) serial communication over inexpensive twisted pair wiring. High noise immunity due to balanced differential signaling. Built in message priority which allows higher priority messages to automatically suppress messages of lower priority without any delay in transmission of the higher priority message. Guaranteed latency time for high priority messages. Automatic synchronization of nodes without a clock signal. Communication from 40 meters at 1 megabit per second up to 5 kilometers at 10 kilobits per second (distances will vary depending on bus characteristics). Automatic bus arbitration and collision detection and correction. Automatic error detection and re-transmission. The ability to work even when different nodes have different ground potentials. Only two required processor pins (Transmit Data (TD) and Receive Data (RD)). Low cost. CAN bus is generally a two wire bus, but sometimes additional power and ground lines are included requiring four wires. High speed CAN is set up as a linear bus of 120 ohm nominal twisted pair wiring with two or more nodes. Termination resistors are used at each end of the bus as shown below. Tip Some CAN devices including our own development boards have built in termination resistors. If you are using more than two nodes on a high speed CAN bus you must disable the termination resistors on all nodes except for the two end nodes. Low speed or fault tolerant CAN uses a linear bus, star bus, or multiple star buses. Fault tolerant CAN buses are terminated differently than linear CAN buses and require a termination resistor at each node. The value of these resistors depends on the network but should equal about 100 ohms per CAN line in total. The TinyCLR CAN Interface The TinyCLR CAN API provides several methods for sending and receiving CAN messages. Configuring the bus Before you can communicate over the CAN bus, the processor needs to know the characteristics of the bus so all nodes can communicate properly. SetBitTiming() defines the CAN bus timing using the arguments listed below. Due to the complexity of CAN bus timing, CAN bit rate calculators are available online which you may find helpful. Please refer to the processor datasheet for a full description of the following parameters. The propagation argument is used to compensate for the physical delay times of the network and includes the input comparator delay, the output driver delay and the propagation delay of the bus itself (which is affected by the length of the CAN bus wiring). Propagation uses time quanta as a unit of measurement. The phase1 argument defines the length in time quanta of the phase one segment. The phase one segment can be automatically lengthened during re-synchronization. The phase2 argument defines the length in time quanta of the phase two segment. The phase two segment can be automatically shortened during re-synchronization. The baudratePrescaler argument determines the speed of the CAN system clock. The synchronizationJumpWidth defines the maximum amount of time quanta a bit period may be lengthened or shortened during each re-synchronization. When true, useMultiBitSampling will cause the bus to be sampled three times for each bit. Its use is recommended for low to medium speed buses to filter noise on the bus line. For high speed buses it is recommended to set this to false . In the sample code below the CAN bus is communicating at 1 Megabit per second over a short bus. Sending CAN Messages WriteMessage() WriteMessage() writes a single CAN message. Each CAN message is defined by eight data bytes, an arbitration ID, the length (number of bytes to send), and two Boolean arguments which specify if the transmission is a remote transmission request and whether the message uses an extended arbitration ID. Extended arbitration IDs are 29 bits long, standard IDs are 11 bits long. WriteMessages() The WriteMessages() method is used to send an array of CAN messages. The arguments for this function are the array of CAN messages followed by an offset and count integer values. The offset is the array subscript of the first message to send, while count specifies how many messages to send. Receiving CAN Messages ReadMessage() ReadMessage() receives a CAN message and includes the ArbitrationId , IsExtendedId , IsRemoteTransmissionRequest , TimeStamp and Data properties. Filtering Incoming CAN Messages SetGroupFilters() SetGroupFilters() takes two arrays as arguments to set ranges of arbitration IDs that will be accepted. The first array defines the lower bounds of accepted arbitration IDs, while the second array specifies the upper bounds. Both arrays must be the same size. In the sample code below the group filters will accept messages with arbitration IDs ranging from 0x12 to 0x20 and also between 0x500 and 0x1000 inclusive. SetExplicitFilters() SetExplicitFilter() takes an array argument which specifies individual arbitration IDs that will be accepted regardless of the group filter settings. In the sample code below, CAN messages with arbitration IDs of 0x11 and 0x5678 will be accepted in addition to the arbitration IDs specified by the group filters. Sample Code The following sample code is written for our G120E Dev Board. It requires installation of the GHIElectronics.TinyCLR.Core , GHIElectronics.TinyCLR.Devices and GHIElectronics.TinyCLR.Pins Nuget packages. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Can; using GHIElectronics.TinyCLR.Devices.Gpio; namespace CanExample { class Program { static void Main() { var downButton = GpioController.GetDefault().OpenPin(0); downButton.SetDriveMode(GpioPinDriveMode.InputPullUp); var can = CanController.FromId(G120E.CanBus.Can1); var propagation = 0; var phase1 = 7; var phase2 = 4; var baudratePrescaler = 5; var synchronizationJumpWidth = 1; var useMultiBitSampling = false; can.SetBitTiming(new CanBitTiming(propagation, phase1, phase2, baudratePrescaler, synchronizationJumpWidth, useMultiBitSampling)); var message = new CanMessage() { Data = new byte[] { 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2E, 0x20, 0x20 }, ArbitrationId = (0x11), Length = 6, IsRemoteTransmissionRequest = false, IsExtendedId = false }; var lowerBounds = new uint[] { 0x12, 0x500 }; var upperBounds = new uint[] { 0x20, 0x1000 }; can.SetGroupFilters(lowerBounds, upperBounds); var explicitFilter = new uint[] { 0x11, 0x5678 }; can.SetExplicitFilters(explicitFilter); can.MessageReceived += CanController_MessageReceived; can.ErrorReceived += CanController_ErrorReceived; while (true) { if (downButton.Read() == GpioPinValue.Low) can.WriteMessage(message); Thread.Sleep(100); } } private static void CanController_MessageReceived(CanController sender, MessageReceivedEventArgs e) { sender.ReadMessage(out var message); Debug.WriteLine(\"Arbritration ID: 0x\" + message.ArbitrationId.ToString(\"X8\")); Debug.WriteLine(\"Is extended ID: \" + message.IsExtendedId.ToString()); Debug.WriteLine(\"Is remote transmission request: \" + message.IsRemoteTransmissionRequest.ToString()); Debug.WriteLine(\"Time stamp: \" + message.TimeStamp.ToString()); var data = \"\"; for (var i = 0; i < message.Length; i++) data += Convert.ToChar(message.Data[i]); Debug.WriteLine(\"Data: \" + data); } private static void CanController_ErrorReceived(CanController sender, ErrorReceivedEventArgs e) => Debug.WriteLine(\"Error \" + e.ToString()); } }"
  },
  "software/tinyclr/tutorials/graphics.html": {
    "href": "software/tinyclr/tutorials/graphics.html",
    "title": "Graphics",
    "keywords": "Graphics You can use the GHIElectronics.TinyCLR.UI library to create user interfaces for your application. It is inspired by WPF on the desktop. The below sample shows how to use a few of the available elements. Make sure to provide your display configuration and the font you want to use. You can also feed touch and button events in from whatever source you may want to use. using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.UI; using GHIElectronics.TinyCLR.UI.Controls; using GHIElectronics.TinyCLR.UI.Media; namespace UI { public class Program : Application { public Program(DisplayController d) : base(d) { } public static void Main() { var disp = DisplayController.GetDefault(); disp.ApplySettings(new ParallelDisplayControllerSettings { //Your display configuration }); var app = new Program(disp); //Use the below two functions to pass input to the UI system //app.InputProvider.RaiseTouch(x, y, touchState, DateTime.UtcNow); //app.InputProvider.RaiseButton(btn, btnState, DateTime.UtcNow); app.Run(Program.CreateWindow(disp)); } private static Window CreateWindow(DisplayController disp) { //Setup var window = new Window { Height = (int)disp.ActiveSettings.Height, Width = (int)disp.ActiveSettings.Width }; window.Background = new LinearGradientBrush(Colors.Red, Colors.Blue, 0, 0, window.Width, window.Height); var font = Resources.GetFont(/*your font*/); OnScreenKeyboard.Font = font; //List var listBox = new ListBox(); listBox.Child.Width = window.Width; //Text for (var i = 0; i < 3; i++) { var text = new Text(font, $\"Text item {i}\"); text.SetMargin(5); listBox.Items.Add(text); } //Button var j = 0; var val = new Text(font, \"Tap Me\"); var btn = new Button { Child = val, Width = 100 }; btn.SetMargin(5); btn.Click += (s, e) => val.TextContent = \"Tap Me \" + (j++).ToString(); listBox.Items.Add(btn); //Textbox var txt = new TextBox { Font = font, Text = \"Text Sample\" }; txt.SetMargin(5); listBox.Items.Add(txt); //Setup window.Child = listBox; window.Visibility = Visibility.Visible; return window; } } }"
  },
  "software/tinyclr/tutorials/i2c.html": {
    "href": "software/tinyclr/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips as a protocal for synchronous serial communication between integrated circuits. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves by using a dedicated chip select signal like SPI, I2C uses an addressing mechanism to communicate with the selected device. This addressing method saves one I/O pin per slave. Before data is transferred, the master transmits the 7-bit address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the slave or receive data from the slave. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start condition\" before sending an address or data. The master ends the data transfer with a \"stop condition.\" The two wires for I2C communication are called the SDA and SCL lines. SDA stands for Serial Data, and SCL is Serial Clock. This is a partial demo showing the use of I2C. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var settings = new I2cConnectionSettings(0x1C) { // the slave's address BusSpeed = I2cBusSpeed.FastMode }; var device = I2cDevice.FromId(FEZ.I2cBus.I2c1, settings); device.Write(new byte[] { 1, 2 }); // write something device.WriteRead(...) // this is good for reading registers } } Software I2C The I2C bus is relatively simple and can be \"bit banged\" using software. The advantage is that any two GPIO pins can be used. However, software I2C requires more system resources and runs slower. This example initializes a software I2C driver. Once initialized, it's used the same as hardware I2C. using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var softwareProvider = new I2cSoftwareProvider(FEZ.GpioPin.PA0, FEZ.GpioPin.PA1); var controllers = I2cController.GetControllers(softwareProvider); var controller = controllers[0]; var device = controller.GetDevice(new I2cConnectionSettings(0x22) { BusSpeed = I2cBusSpeed.StandardMode, SharingMode = I2cSharingMode.Exclusive }); } }"
  },
  "software/tinyclr/tutorials/intro.html": {
    "href": "software/tinyclr/tutorials/intro.html",
    "title": "TinyCLR Tutorials",
    "keywords": "TinyCLR Tutorials Here you will find programming tutorials and code examples for our TinyCLR OS. We try to keep the documents as hardware generic as possible but changes may be required to get the sample code to run on your target device. Topics GPIO UART I2C SPI PWM ADC DAC CAN Display Gpio Change Writer Gpio Change Reader Gpio Pulse Reader Writer"
  },
  "software/tinyclr/tutorials/pwm.html": {
    "href": "software/tinyclr/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM Pulse Width Modulation (PWM) is a very import feature found in most microcontrollers. PWM is a pulse that is repeated and generated by the internal hardware. The ratio of the pulse width and its frequency is called duty cycle. Through software, you can control the pulse's frequency and duty cycle. Tip We usually use GetDefault() for most peripherals. For example, there is only one GPIO controller on most systems. This is not the case with PWM. Never use the Default controller and always select the proper channel on the corresponding controller. Tip PWM2.3 is channel 3 on controller 2 Energy Level PWM is perfect for dimming an LED or slowing down a motor. This is done by turning power on and off, at a high speed. When power is on half the time and off half the time, only half the energy is transferred, to the LED or a motor. This demo will fade the LED in and out using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { PwmController Controller4 = PwmController.FromId(FEZ.PwmPin.Controller4.Id); PwmPin led = Controller4.OpenPin(FEZ.PwmPin.Controller4.Led1); Controller4.SetDesiredFrequency(10000); double duty = 0.5, speed = 0.01; led.Start(); while (true) { if (duty <= 0 || duty >= 1.0) { speed *= -1; //invert dirrection duty += speed; } led.SetActiveDutyCyclePercentage(duty); duty += speed; Thread.Sleep(10); // always give the system time to think! } } } Musical Tones Music notes have specific frequencies; C for example is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. When playing notes by changing the frequency, keep thee duty cycle set to 0.5. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 1000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //make sure the two below arrays match in length. each duration element corresponds to //one note element. static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; static void Main() { PwmController Controller1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); PwmPin tones = Controller1.OpenPin(FEZ.PwmPin.Controller1.D0); tones.SetActiveDutyCyclePercentage(0.5); tones.Start(); while (true) { for (int i = 0; i < note.Length; i++) { Controller1.SetDesiredFrequency( note[i]); Thread.Sleep(duration[i]); } Thread.Sleep(100); } } } Servo Motors Servo motors are controlled by a repeated pulse. The pulse is generated every 20ms. This pulse will have a width between 1ms and 2ms, for min and max. Positional servos will go to a specific direction based on the pulse width. Full rotational servos can be controlled, speed and direction, through this pulse, where 1.5ms pulse will stop, 1ms is full speed and 1ms is reverse full speed. Tip most servos will have a 1.25ms min and 1.75max. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { PwmController Controller1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); PwmPin servo = Controller1.OpenPin(FEZ.PwmPin.Controller1.D0); Controller1.SetDesiredFrequency(1 / 0.020);//a pulse every 20ms double maxPulseLength = 1.75; double minPulseLength = 1.25; double position = 90; double speed = 0.5; servo.Start(); while (true) { double duty = ((position / 180.0) * (maxPulseLength / 20 - minPulseLength / 20)) + minPulseLength / 20; servo.SetActiveDutyCyclePercentage(duty); position += speed; if (position <= 0 || position >= 180) duty *= -1;//reverse dirrection Thread.Sleep(10);// always give the system time to think! } } }"
  },
  "hardware/gadgeteer/fez-spider.html": {
    "href": "hardware/gadgeteer/fez-spider.html",
    "title": "FEZ Spider",
    "keywords": "FEZ Spider FEZ Spider is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider is the EMX System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Tip The EMX bootloader version 1 doesn't always work with Windows 7 and newer (Error code 10). You can use the serial option to update the loader. This is a one-time procedure. You should have no issues after the bootloader V2 is loaded. To update using USB Download the EMX bootloader file Set the board's configuration switches in boot mode. That is by setting switches #1, #2 and #3 to the ON position. Connect the FEZ Spider to a power module (red module) and then to a PC. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! To update using Serial Connect a USB-serial module to socket 11. Follow the exact same steps above except you need to also switch #4 to ON (serial mode) and you need to set the baud rate to 115200 on the terminal software. The drivers for the USB-serial module should load automatically. If not, get them from http://www.ftdichip.com/ Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set the configuration switch #1 to the on position and then reset your board. Make sure to set back to off after loading the firmware. Download the EMX firmware and follow Loading the Firmware steps."
  },
  "hardware/scm/usbizi.html": {
    "href": "hardware/scm/usbizi.html",
    "title": "USBizi",
    "keywords": "USBizi USBizi was the first single chip .NET Micro Framework (NETMF) on the market. It was available in 100pin and 144pin LQFP packages. We are no longer making the chip available but we are making all bootloader binaries available for free, including for commercial use. Resources User Manual Using NETMF software We discourage the use of NETMF software on our products in favor of TinyCLR OS, but the choice is up to you. To find out more about NETMF, got to our NETMF Introduction Page Using TinyCLR OS The following instructions describe how to set up USBizi to work with TinyCLR OS. To learn more about TinyCLR check out the TinyCLR Introduction page. Loading Bootloader v2 Tip The instructions apply to all USBizi-based boards but we are using the FEZ Panda II as reference. We first need to erase the old bootloader v1: Connect UART0 TX/RX to your PC. The easiest way would be to use a USB-Serial TTL cable. Those are D0 and D1 on FEZ Panda II. Do not forget to connect the ground. Put the device in serial mode by connecting MOD pin to ground. Open a terminal software and set the baudrate to 115200. Press the enter key and you should see BL coming back. Enter this exact line Unlock This device! (case sensitive). Ignore the BL keeps coming back with every key press. If you entered it correctly, you will see Are you sure? Enter Yes (case sensitive). You now have a blank LPC chip! You can now close the terminal software, release MOD pin, and reset your board. The new bootloader v2 can now be loaded. Download and install Flash Magic . Open Flash Magic and select LPC2378. Check \"Erase all Flash\". Set the correct COM port number of your serial connection. Click the Start button. When done, reset the board and the PC will detect a virtual USB device. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set LDR pin low. On FEZ Panda II it is a button marked LDR. Simply press it. Once the LDR pin is set low, keep it low while resetting the board. Download the USBizi firmware and follow Loading the Firmware steps. USBizi DevSys The original development board for USBizi. Resources Schematic"
  },
  "hardware/ucm/chipworkx.html": {
    "href": "hardware/ucm/chipworkx.html",
    "title": "ChipworkX",
    "keywords": "ChipworkX ChipworkX is a NETMF System on Module. To use with NETMF, follow these setup instructions . Needs the NETMF 4.1 SDK. Resources User Manual"
  },
  "hardware/ucm/uc2550.html": {
    "href": "hardware/ucm/uc2550.html",
    "title": "UC2550",
    "keywords": "UC2550 Overview The efficiency of our UC2550 makes it ideal for low power applications. It is also our lowest cost UCM and offers a large complement of peripherals. Unlike the UC5550 however, it does not support USB host, a parallel LCD display, Ethernet PHY, or DCMI (Digital Camera Interface). We currently stock the UC2550 both with and without Wi-Fi depending on the model. We also offer customized, non-stock versions of our SoMs. See Options below for more information. Getting Started The UCM development options can greatly simplify the process of building a product or prototype using the UC2550. Options include a development board and displays which can get you programming in minutes. Please refer to the Development Options page for more information. Using TinyCLR OS TinyCLR provides a way to program the UC2550 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the bootloader and firmware on the UC2550 (instructions below) and then go to the TinyCLR Getting Started page for instructions on setting up the host computer and writing and deploying programs. Loading Bootloader Version 2 Download the UC2550 bootloader from here . Go to the Uploading DFU Files section of the STM32 Bootloader page for instructions on installing the bootloader. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 signal low (press BOOT B on UCM Dev and Breakout boards) while resetting the board. Download the UC2550 firmware and follow the Loading the Firmware steps. Setup the Host Computer and Start Coding Now that you have installed the bootloader and firmware on the UC2550, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Schematic The schematic for the UC2550 can be found here . Options Model Number Wi-Fi External QSPI Flash UC2550-13NNN no no UC2550-13NNW yes no Customization We also offer customized, non-stock versions of our SoMs. Many options are available, such as various sizes of external QSPI flash. Please contact us for details. We will always do our best to provide you with a module to fit your exact needs. Specifications Specs Value Processor STM STM32F413 32-bit ARM Cortex-M4 Speed 100 MHz Internal RAM 320 KByte (SRAM) Internal Flash 1 MByte External RAM 0 KByte External Flash Up to 4 MByte (QSPI) Peripherals Peripheral UCM Standard Overall* UART 4 9 (including HS) UART HS 2 2 I2C 2 2 SPI 2 3 CAN 2 2 SDIO 1 1 ADC 8 15 PWM 8 27 GPIO 10 67 IRQ 4 67 USB Client Supported Supported USB Host Not supported Not supported LCD Not supported Not supported Ethernet PHY Not supported Not supported Wi-Fi Supported Supported DCMI Not supported Not supported VBAT Supported Supported JTAG SWD SWD * The \"Overall\" column includes peripherals that fall outside of the UCM standard definition. Using these peripherals may reduce code portability with our other UCM models. Also, as many of these non-standard peripherals share I/O pins, not all of them will be available to your application. Pin Assignments SO-DIMM Pin Universal Compute Standard Function Name 1 AGND AGND 2 Ethernet TX- 3 Module Specific 1 (Wi-Fi Module PIN14) GPIO4 (LED PWR) 4 Ethernet TX+ 5 Analog VREF- Analog VREF- 6 Ethernet RX- 7 Reserved 8 Ethernet RX+ 9 Reserved 10 Indicator A (Wi-Fi Module PIN15) GPIO3 (LED LINK) 11 Indicator B (Wi-Fi Module PIN5) GPIO10 (LED ACT) 12 Reserved 13 GND GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V Analog 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND GND 28 PWM E PE5, T9C1 29 PWM F PE6, T9C2 30 PWM G PB14, T12C1 31 PWM H PB15, T12C2 32 Analog VREF+ Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 (Wi-Fi Module PIN13) GPIO7 36 Module Specific 5 (Wi-Fi Module PIN16) GPIO0 37 Module Specific 6 (Wi-Fi Module PIN22) GPIO6 38 Module Specific 7 39 Module Specific 8 40 GND GND 41 GND GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND GND 52 Module Specific 9 53 I2S SCK 54 I2S WD 55 I2S WS 56 5V 57 IRQ A PC0, ADC10 58 IRQ B PC1, ADC11 59 IRQ C PC2, ADC12 60 3.3V 3.3V 61 IRQ D PC3, ADC13 62 GPIO A PC4, ADC14 63 GPIO B PC5, ADC15 64 GPIO C PA15, T2C1 65 GND GND 66 GPIO D PB0, ADC8, T3C3 67 GPIO E PB7, T4C2 68 GPIO F PD7 69 GPIO G PD10 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA PB8, I2C3 SDA, T10C1 74 I2C B SCL PA8, I2C3 SCL, MCO1 75 UART C TX PE1, UART8 TX 76 UART C RX PE0, UART8 RX 77 UART D TX PD15, USART9 TX, T4C4 78 UART D RX PD14, USART9 RX, T4C3 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX PE8, USART7 TX 90 UART B RX PE7, USART7 RX 91 ADC A PA0, ADC0, T5C1 92 GPIO H PE10 93 SPI B MISO PE13, SPI5 MISO, T1C3 94 SPI B MOSI PE14, SPI5 MOSI, T1C4 95 GND GND 96 SPI B SCK PE12, SPI5 SCK 97 ADC B PA1, ADC1, T5C2 98 CAN A TD PD1, CAN1 TX, UART4 TX 99 CAN A RD PD0, CAN1 RX, UART4 RX 100 CAN B TD PB13, CAN2 TX, UART5 TX 101 CAN B RD PB12, CAN2 RX, UART5 RX 102 UART HS A TX PD5, USART2 TX 103 UART HS A RX PD6, USART2 RX 104 ADC C PA2, ADC2, T5C3 105 PWM A PE9, T1C1 106 3.3V 3.3V 107 System A BOOT0 108 Module Specific 2 (Wi-Fi Module PIN2) BOOT0 109 Module Specific 3 (Wi-Fi Module PIN4) GPIO8 (Mini Python) 110 ADC D PA3, ADC3, T5C4 111 System C PE3 112 PWM B PE11, T1C2 113 GND GND 114 ADC E PA4, ADC4, DAC1 115 I2C A SDA PB9, I2C2 SDA, T10C1 116 I2C A SCL PB10, I2C2 SCL, T2C3 117 UART A RX PA10, USART1 RX 118 UART A TX PA9, USART1 TX 119 GPIO I PD14, UART9 RX, T4C3 120 UART HS A RTS PD4, USART2 RTS 121 UART HS A CTS PD3, USART2 CTS 122 GPIO J PD15, UART9 RX, T4C4 123 SD Card D0 PC8, SD D0, T8C3 124 3.3V 3.3V 125 SD Card CMD PD2, SD CMD 126 SD Card CLK PC12, SD CLK, SPI3 MOSI 127 SD Card D1 PC9, SD D1, T8C4 128 SD Card D2 PC10, SD D2, SPI3 SCK 129 SD Card D3 PC11, SD D3, SPI3 MISO 130 PWM C PC6, T3C1, USART6 TX 131 GND GND 132 GPIO K 133 PWM D PC7, T3C2, USART6 RX 134 System B PB2 135 System D PE4 136 GPIO L 137 Module Specific 10 138 UART HS B RTS PD12, USART3 RTS 139 UART HS B CTS PD11, USART3 CTS 140 UART HS B TX PD8, USART3 TX 141 UART HS B RX PD9, USART3 RX 142 3.3V 3.3V 143 LCD VSYNC 144 LCD HSYNC 145 LCD CLK 146 LCD DE 147 Module Specific 11 148 SD Card CD PC13 149 Module Specific 12 150 Reserved 151 GND GND 152 LCD B3 153 LCD B4 154 LCD B5 155 LCD B6 156 LCD B7 157 ADC F PA5, ADC5, DAC2 158 ADC G PA6, ADC6 159 ADC H PA7, ADC7 160 3.3V 3.3V 161 LCD G2 162 LCD G3 163 LCD G4 164 LCD G5 165 LCD G6 166 Module Specific 13 167 Indicator C 168 LCD R7 169 GND GND 170 LCD G7 171 LCD R3 172 LCD R4 173 LCD R5 174 LCD R6 175 SPI A SCK PB3, SPI1 SCK, T2C2 176 SPI A MISO PB4, SPI1 MISO 177 Module Specific 14 178 SPI A MOSI PB5, SPI1 MOSI 179 Module Specific 15 180 3.3V 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT VBAT 184 Module Specific 18 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ 189 JTAG RTCK 190 USB Host D- 191 JTAG TDO 192 3.3V 3.3V 193 JTAG NTRST 194 USB Device D+ PA12, USB D+ 195 JTAG TDI 196 USB Device D- PA11, USB D- 197 JTAG TCK (SWCLK) PA14, JTCK, SWCLK 198 GND GND 199 JTAG TMS (SWDIO) PA13, JTMS, SWDIO 200 Indicator D Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/netmf/tutorials/spi.html": {
    "href": "software/netmf/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three, sometimes four, wires for transferring data. The bus on SPI consists of one master and one or more slaves. The master will send clock to the salves along with data and will read back using the same clock. This clock is used to determine how fast the data is moved. If you know electronics, this is a shift register. So, the master will transmit a clock on a SCK (serial clock) pin and will simultaneously transmit the data on MOSI (Master Out Slave In) pin. The slave will read the clock on SCK pin and simultaneously read the data from MOSI pin. So far, this is a one way communication. While data is transmitted in one direction using MOSI another set of data is sent back on MISO (Master In Slave Out) pin. Other data sizes are possible but bytes are most common. NETMF supports 8-bit (byte) and 16-bit (short) data transfers. Because of this master/slave scheme, we can add multiple slaves on the same bus where the master selects which slave it will swap the data with. Note I am using the word swap because you can never send or receive but you always send and receive (swap) data. The master selects one of the slaves using SSEL (Slave Select) pin. This pin can be called CS (Chip Select) as well. In theory, the master can have unlimited slaves but it can only select one of them at any given time. The master will only need 3 wires (SCK, MISO, MOSI) to connect to all slaves on the bus but then it needs a separate SSEL pin for each one of the slaves. Some SPI devices (slaves) can have more than one select pin, like VS1053 MP3 decoder chip that uses one pin for data and one pin for commands but both share the 3 data transfer pins (SCK, MOSI, MISO). SPI needs more wires than other similar buses but it can transfer data very fast. A 50Mhz clock is possible on SPI, that is 50 million bits in one second. Note that NETMF devices are always SPI masters, not slaves. Before creating a SPI object, we would need a SPI configuration object. The configuration object is used to set the states of the SPI pins and some timing parameters. In most cases, you need the clock to be idle low (false) with clocking on rising edge (true) and with zero for select setup and hold time. The only thing you would need to set is the clock frequency. Some devices may accept high frequencies but others do not. Setting the clock to 1000Khz (1Mhz) should be okay for a starter Getting Started This example is sending/receiving 10 bytes of data on SPI channel 1. Note: NETMF start numbering SPI channels (module) from 1, but on processors the channels start from 0 typically. So, using SPI1 in code is actually using SPI0 on the processor. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { SPI.Configuration MyConfig = new SPI.Configuration(Cpu.Pin.GPIO_Pin1, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI MySPI = new SPI(MyConfig); byte[] tx_data = new byte[10]; byte[] rx_data = new byte[10]; MySPI.WriteRead(tx_data, rx_data); Thread.Sleep(100); } } Accessing Multiple Devices The SPI object on NETMF is a representation of the \"bus\" and not the \"device\", so you can't construct multiple SPI objects, unless it uses a different SPI bus. To access multiple SPI devices you need to have multiple configurations and then when accessing device \"A\" we need to use configuration \"A\" and when accessing device \"B\" we need to use configuration \"B\". using Microsoft.SPOT.Hardware; public class Program { public static void Main() { SPI.Configuration ConfigDeviceA = new SPI.Configuration(Cpu.Pin.GPIO_Pin1, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI.Configuration ConfigDeviceB = new SPI.Configuration(Cpu.Pin.GPIO_Pin4, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI MySPI = new SPI(ConfigDeviceA); byte[] tx_data = new byte[10]; byte[] rx_data = new byte[10]; // accessing device A MySPI.Config = ConfigDeviceA; MySPI.WriteRead(tx_data, rx_data); // accessing device B MySPI.Config = ConfigDeviceB; MySPI.WriteRead(tx_data, rx_data); } }"
  },
  "software/tinyclr/release-notes.html": {
    "href": "software/tinyclr/release-notes.html",
    "title": "Release Notes",
    "keywords": "Release Notes 1.0.0-preview1 on 2018-08-15 Notes This release is the first preview of the 1.0 release for TinyCLR. We will have at least one other preview after this one. The biggest change in this release is the rework and simplification of the devices library. It was divided into one library per peripheral to reduce deployment size for apps that don't require all libraries. We did keep the devices package as a metapackage that depends on the other packages so you can easily bring them all into your project if desired. Many of the devices did keep a familiar API like ADC, DAC, and GPIO. Others like I2C and SPI did keep a similar device API but the controller was reworked. Previously you'd be able to call FromId on the device or controller object. Now you must call FromName on the controller and then call GetDevice . A few others had minor tweaks to names and members. Of particular note are that you must now call Enable to turn the display on and mounting with FileSystem now requires the Hdc property from the SdCardController instead of the controller instance itself. UART saw a lot of changes in this release. The entire storage library was removed and the SerialCommunication class was changed into UartController to mirror the pattern used with all of the other devices. DataReader and DataWriter are gone as well, so reading and writing to UART can only be done with a byte array. We also introduced a new native library that holds many of the things we added to mscorlib previously like interops, APIs, system time, NativeEventDispatcher , and, new in this release, power. Given the amount of changes in the HAL layer we do expect a few more bugs in this release, but we are working to iron them all out before 1.0. .constrained continues to throw in this release as we gather more data. It is currently known to be used when accessing overridden members on structs, particularly those from object like ToString , Equals , and GetHashCode . You'll encounter it on enum and TimeSpan , among others. We will be making a decision soon on whether or not to revert the exception before the final release. In preparation for the official 1.0 release we are no longer building the firmwares for older unsupported devices. Please see this doc for more information. The source code remains available though so we invite you to contribute to it and build your own firmware. We have also uploaded the libraries to our NuGet account and the VSIX to the Visual Studio Marketplace . Make sure to enable finding prereleases in the NuGet package manager. We will still make them available on our own hosting as well, but the expected workflow going forward is the usual NuGet/Marketplace search and download process you have for other packages and extensions. You can find all downloads in their respective sections on the downloads page. As before you, can update your firmware using TinyCLR Config and now you can update your packages using the NuGet package manager from the online source. There are no new bootloaders in this release. Libraries Changes Reworked the APIs of many of the peripherals in GHIElectronics.TinyCLR.Devices library, particularly UART. Split up the GHIElectronics.TinyCLR.Devices into one library per peripheral. Removed the GHIElectronics.TinyCLR.Storage library. Added a new GHIElectronics.TinyCLR.Native library and moved SystemTime , Interop , Api , and DeviceInformation to it. Added Power to GHIElectronics.TinyCLR.Native . Added DrawPixel to the display controller. Added DrawBuffer to the display controller. Added Enable and Disable to many controllers. Reworked SystemTime to have GetTime and SetTime with DateTime overloads. Reworked and simplified the entire provider model, removing many classes in the process. Renamed OutputEnable to DataEnable on DisplayController . Renamed ApplySettings to SetConfiguration on DisplayController . Renamed PwmPin to PwmChannel . Fixed GetDirectories always throwing #343 . Reduced the default brightness of the light bulb on the BrainPad. Known Issues SPWF04Sx may sometimes lose writes. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. A number of API names are missing from pins, notably RTC and SD. The Edge property of GPIO interrupts is not always correct. Many properties on SignalGenerator and SignalCapture do not work. PulseFeedback does not work. SoftwareI2C does not work #365 . DisplayController.DrawBuffer does not work with a non-zero origin or size different than the entire screen #410 . DisplayController.DrawPixel draws the incorrect color. The timestamp is incorrect when creating a new file. Firmware Changes Fixed I2C sharing conflicts incorrectly throwing OutOfMemoryException #298 . Fixed OutputEnablePolarity being inverted on UC5550 #315 . Fixed some SD cards getting corrupt after use on G400 #319 . Fixed G120 getting stuck deploying #331 . Fixed CAN not working on G400 #332 . Fixed the run app pin not working on USBizi #333 . Fixed paths requiring an extra \\ after the drive letter #334 . Fixed the display on the G400 reserving PC26 #336 . Removed the SPI display controller implementation. Known Issues PWM may jitter when decreasing the pulse length while enabled. UART handshaking may miss data on STM32F4. Testing NaN s for equality gives unexpected results. SignalGenerator and SignalCapture do not work on UC2550 and UC5550. The UD700 will become corrupted after running for a few minutes on the UC5550. Using exception filters may crash the system in some uses #177 . Software SPI does not work with some devices #293 . During multi-pin reservations if a later pin fails to reserve, previously reserved ones are not released #312 . Filesystem is not available on G30 #322 . The ADC is not accurate on the G400 #373 . Many events do not pass a timestamp #368 . Many of the non-essential functions of USB client are not implemented #398 . Using UART may eventually lockup the UC5550 #411 . TinyCLR Config Changes Allowed the app to be resized. Known Issues None. Extension Changes None. Known Issues When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Porting Changes Simplified many of the controller APIs. Removed the controller number from the various controllers. Renamed many instances of provider to manager or controller. Updated to use the latest GCC. Removed Acquire and Release from core-provided APIs. Changed to an initialize and uninitialize pattern for required APIs. Added InteropManager to TinyCLR_Interop_MethodData . Merged DeploymentProvider and SdCardProvider . Changed specifying the deployment API to a dedicated function call. Changed InteropManager::GetArgument to start at index 0 for all arguments, regardless of instance or static. Known Issues The linker will not error when regions overflow or overlap #30 . 0.12.0 on 2018-07-05 Notes This release adds support for gif images, a WPF-like UI library used to build graphical user interfaces, and an SD card driver and associated FAT filesystem. There are also a number of other small API additions and changes to Graphics and the BrainPad. We're also distributing the interop definition headers for all of our libraries so that you can interact with them from native code you may write. Keep in mind that the fields are often private members to the class, so are regarded as implementation details that may change between release. One important note for creators of native APIs, the Implementation parameter was changed so that it is only ever a pointer to a single instance. It no longer points to an array if Count is more than one and, in fact, the Count parameter was removed completely since it's only ever one or nullptr now. As part of this, we added a controller parameter to many functions such as UART and I2C. .constrained continues to throw in this release as we gather more data. It is currently known to be used when accessing overridden members on structs, particularly those from object like ToString , Equals , and GetHashCode . You'll encounter it on enum and TimeSpan , among others. As before, you can find all downloads in their respective sections on the downloads page. Just download the new installers and NuGet packages to get going. You don't even need to download the firmwares since you can use the update firmware feature in TinyCLR Config to automatically download them for you. There are no new bootloaders in this release. Libraries Changes Changed return values of the BrainPad accelerometer to -100 to 100 for -1g to 1g. Capped return values in BrainPad accelerometer to 1g. Marked SystemTime.SetTime as not CLS-compliant. Added EnableFullRange to BrainPad accelerometer to control returning more than 1g. Added GraphicsUnit to Font and Graphics . Added Expansion to the BrainPad library. Added SD and Filesystem to the IO library. Added more overloads of DrawString and DrawImage to Graphics . Added Graphics.MeasureString . Added Font.Height . Added a UI library. Known Issues SPWF04Sx may sometimes lose writes. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Software SPI does not work with some devices #293 . I2C sharing conflicts incorrectly throw OutOfMemoryException #298 . Firmware Changes Added gif image format support. Fixed interrupts crashing the system after some time on UC2550 and UC5550. Fixed the firmware getting erased when using SPI1 on the G120 #294 . Fixed opening one CAN reserving all other CAN pins #296 . Fixed default debounce time to 20ms #313 . Known Issues Many UART properties and events are not implemented. PWM may jitter when decreasing the pulse length while enabled. UART handshaking may miss data on STM32F4. Testing NaN s for equality gives unexpected results. Filesystem is not available on G30. The linker will not error when regions overflow or overlap #30 . The run app pin doesn't work on USBizi #33 . Using exception filters may crash the system in some uses #177 . During multi-pin reservations if a later pin fails to reserve, previously reserved ones are not released #312 . OutputEnablePolarity is inverted on UC5550 #315 . Some SD cards are corrupt after use on G400 #319 . G120 can get stuck deploying #331 . CAN does not work on G400 #332 . TinyCLR Config Changes None. Known Issues None. Extension Changes Added Expansion to the BrainPad helper template. Known Issues When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Porting Changes Added GetControllerCount to many providers. Changed how providers are registered in native to only take a single pointer to an implementation instead of optionally an array. Added interop definitions for our libraries. Known Issues None. 0.11.0 on 2018-05-10 Notes This release fixed a number of bugs, improved the BrainPad display API, added a number of methods to the porting API, and completely reworked the native USB client API. We also moved graphics out of the core library so it's now much leaner which helps small devices like the G30. .constrained continues to throw in this release as we gather more data. It is currently known to be used when accessing overridden members on structs, particularly those from object like ToString , Equals , and GetHashCode . As before, you can find all downloads in their respective sections on the downloads page. Just download the new installers and NuGet packages to get going. You don't even need to download the firmwares since you can use the update firmware feature in TinyCLR Config to automatically download them for you. There are no new bootloaders in this release. Libraries Changes Added a pins library for the UCM standard. Fixed the range of values the BrainPad temperature returns. Fixed disposing of the underlying image when disposing graphics. Fixed another case that would cause Thread.ManagedThreadId to get lost. Renamed ShowOnScreen to RefreshScreen and ClearScreen to Clear in BrainPad. Removed the various AndShowOnScreen methods in BrainPad. Known Issues SPWF04Sx may sometimes lose writes. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Software SPI does not work with some devices #293 . Firmware Changes Added RTC to Cerberus #263 . Added RTC to G30 and FEZCLR #228 . Fixed RTC crashing the G400 and FEZHydra #260 . Fixed ADC11 being mapped incorrectly on STM32F7 #261 . Fixed opening the debugger UART not throwing an exception when in UART debug mode #259 . Fixed pins not always being acquired or released in the HAL #258 . Fixed all GPIO getting reset when opening the GPIO controller #256 . Fixed errors from the HAL side not always surfacing in managed code. Fixed flushing a large screen locking up the device. Implemented UART error events for AT and ST. Known Issues Many UART properties and events are not implemented. PWM may jitter when decreasing the pulse length while enabled. UART handshaking may miss data on STM32F4. Testing NaN s for equality gives unexpected results. The linker will not error when regions overflow or overlap #30 . Using exception filters may crash the system in some uses #177 . Using SPI1 on G120 may corrupt the flash #294 . Use of CAN causes all pins for all CAN busses to be reserved #296 . TinyCLR Config Changes Minor improvements and fixes. Known Issues None. Extension Changes Added a dependency to the VSIX to ensure .NET v4.5.2 is present. Added BrainPad Helper item template. Removed the BrainPad Application project template. Known Issues When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Porting Changes Added ClearReadBuffer and ClearWriteBuffer to UART. Added GetUnreadCount and GetUnwrittenCount to UART. Added GetUnwrittenMessageCount and ClearWriteBuffer to CAN. Changed GPIO debounce time to ticks. Cleaned and overhauled the USB client API. Moved the graphics interop out of the core library. Known Issues None. 0.10.0 on 2018-04-05 Notes This release fixes a number of bugs including some that caused lockup during debugging and deployment. We added RTC to many devices and also added a target for the STM32F7 in the ports repo that we will maintain. .constrained continues to throw in this release as we gather more data. We have not found any other common cases beyond ToString on an enum. Lastly, the time provider for firmwares was split up into a native and system time provider. The core now exposes a system time provider that you can consume to get and set the current system time (this is also exposed in managed). The existing provider was repurposed to simply provide the native tick count, convert it to system time, and delay. As before, you can find all downloads in their respective sections on the downloads page. Just download the new installers and NuGet packages to get going. You don't even need to download the firmwares since you can use the update firmware feature in TinyCLR Config to automatically download them for you. There are no new bootloaders in this release. Libraries Changes Added a method to set the system time in System.Runtime.InteropServices.SystemTime . Fixed Thread not overriding GetHashCode . Fixed Thread.ManagedThreadId getting corrupted. Fixed partially transparent ellipses having weird artifacts. Known Issues SPWF04Sx may sometimes lose writes. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Pins are not currently reserved so you can create multiple objects on the same pin which behave incorrectly. Firmware Changes Added CAN to USBizi #114 . Added support for repeated start in I2C for the AT91 targets #55 . Added an STM32F7 target. Added UC2550 and UC5550 firmwares. Improved resetting peripherals during soft reset #247 . Moved some deployment logic out of flash drivers #187 . Fixed the firmware crashing during soft reset if a CAN or UART port is open #249 . Fixed being unable to deploy a second time if SPI is used in the application on G120 or G400 #208 . Fixed being unable to deploy a second time if CAN is used in the application on G80 #200 . Fixed UART and CAN buffer sizes returning zero if they were not previously set #203 . and #199 . Fixed some devices freezing if receiving too many messages over CAN after setting the buffer size #201 . Fixed the display memory not clearing during soft reset #198 . Fixed the ADC being slightly inaccurate on G80 #45 . Fixed the LCD on the EMM sometimes not working #168 . Fixed the LCD having a blue tint on EMX and EMM #29 . Fixed PWM 3.27 not working on EMM #41 . Fixed ADC6 and ADC7 not working on USBizi #40 . Fixed the firmware crashing on USBizi during debugging #43 . Fixed resetting the ADC provider resetting ADC pins that aren't in ADC mode. Fixed the USBizi sometimes failing to deploy. Fixed some frequencies rounding up on the G120 and G400. Known Issues Many UART properties and events are not implemented. PWM may jitter when decreasing the pulse length while enabled. UART handshaking may miss data on STM32F4. Testing NaN s for equality gives unexpected results. The linker will not error when regions overflow or overlap #30 . Using exception filters may crash the system in some uses #177 . RTC does not work on Cerb #263 . RTC does not work on G400 or FEZHydra #260 . RTC does not work on G30 or FEZCLR #228 . ADC11 does not work on the STM32F7 target #261 . All GPIO are reset when the controller is acquired #256 . TinyCLR Config Changes Added manufacturer name display. Known Issues None. Extension Changes Fixed debugging in VS sometimes pausing forever until you manually break #42 . Known Issues When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Porting Changes Added an RTC provider. Added a system time provider. Reworked the existing time provider to only be a native time provider. Removed DelayNoInterrupt and GetInitialTime from the time provider. Fixed getting the value of a DateTime for return in interops. Enabled deployment regions to be discontiguous. Known Issues The USB host API is missing. The USB client API is still very rough and will change. 0.9.0 on 2018-03-01 Notes This release adds a number of new features. We've also worked to reduce the frequency of crashing during deployment and greatly improved the performance of the SPWF04Sx and how it handles low memory situations. We also re-added the IO , Networking , and HTTP libraries in this release. These contain the old FileStream , HttpWebRequest , Socket , and SslStream classes from before. However, there is no native file system or networking support still. Instead, we've added managed hooks that allow you to provide your own file and networking implementation. Take a look at DriveInfo.RegisterDriverProvider and NetworkInterface.RegisterNetworkInterface to get going. DriveInfo expects an instance of an interface that provides the required file IO operations. NetworkInterface expects an instance of itself. It will be used for the respective network operations if it implements ISocketProvider , IDnsProvider , or ISslStreamProvider interfaces. The SPWF04Sx driver was updated to implement these interfaces. All devices now also have a native SPI display provider that is used just like the existing parallel displays. On a DisplayController created for the SPI native API, call ApplySettings with an instance of SpiDisplayControllerSettings . Then just create an instance of Graphics like previously. Some displays, like the N18, require certain configuration before flushing data, so make sure to do that yourself before calling Flush . It's also expected that you initialize the display itself as well. Relatedly, we also added WriteString to the display controller. This allows you to write directly to the display in a console format, without needing a font, if the display provider supports it (which our current parallel display provider does). It's useful for quick debug logging. One minor added function is MethodBase.GetParameters . It can be used to get the types and positions of parameters for any function (but not the parameter name). This is useful for scenarios like dependency injection. We have changed the core so that any time the .constrained IL prefix is executed, a not-supported instruction is thrown. We noticed a case where it was being generated again so we added this exception to try and catch more cases. Since it is currently not implemented in the firmware, simply ignoring the prefix can corrupt your program. Please let us know if you encounter this exception. We'll evaluate keeping the exception in depending on the frequency it occurs. The one case we have found so far is calling ToString on an enum. To work around it, cast your enum to its underlying type (usually int ) first since we do not support getting names in this way anyway. See this forum thread for more information. Lastly, we've enabled support for anyone to provide NuGet packages for satellite assemblies of our mscorlib that contain the CultureInfo for a desired localization. While we do not provide any ourselves, take a look at the NuGet docs for more information. As before, you can find all downloads in their respective sections on the downloads page. Just download the new installers and NuGet packages to get going. You don't even need to download the firmwares since you can use the update firmware feature in TinyCLR Config to automatically download them for you. There are no new bootloaders in this release. Libraries Changes Added DisplayController.WriteString . Added an IO library. Added a Networking library with Socket , SslStream , and HTTP . Added MethodBase.GetParameters . Added Type to DisplayController . Renamed LcdControllerSettings to ParallelDisplayControllerSettings . Reworking entire SPWF04Sx driver to be more performant and less memory sensitive. ResourceManager now detects if the culture changes after initialization. Culture info can be found in user provided satellite assemblies of mscorlib . Known Issues SPWF04Sx may sometimes lose writes. Thread does not override GetHashCode . Thread.ManagedThreadId may return zero. Partially transparent ellipses have weird artifacts. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Pins are not currently reserved so you can create multiple objects on the same pin which behave incorrectly. Firmware Changes Added a native SPI display driver. The .constrained IL prefix throws a not supported instruction exception. The run app pin now works on USBizi #39 . Attempting to use handshaking when it is not available now throws an exception #175 . Reduced frequency of an internal error during deployment when low on memory. Reduced frequency of crashing on deployment when low on memory. Known Issues Many UART properties and events are not implemented. PWM may jitter when decreasing the pulse length while enabled. Deploying on USBizi sometimes fails. Reset the board and try again to work around it. The LCD on EMM sometimes does not work. UART handshaking may miss data on STM32F4. Testing NaN s for equality gives unexpected results. The LCD has a blue tint on EMX and EMM #29 . The linker will not error when regions overflow or overlap #30 . ADC 6 and 7 do not work on USBizi #40 . PWM on 3.27 does not work on EMM #41 . Debugging in VS with USBizi crashes the firmware sometimes #43 . The ADC on G80 may be slightly inaccurate #45 . CAN is not present on USBizi #114 . Using exception filters may crash the system in some uses #177 . The display is not cleared on soft reset #198 . GetWriteBufferSize returns the wrong value until SetWriteBufferSize is called for CAN #199 . Deployment fails the second time if using CAN #200 . After changing the receive buffer size, CAN may crash if it receives too many messages #201 . GetWriteBufferSize returns the wrong value until SetWriteBufferSize is called for UART #203 . TinyCLR Config Changes Erasing and loading the app now properly refreshes the assembly list. Added function to the loader interface that will update to the latest firmware regardless of the version on device. Known Issues Many features will not function with devices running firmwares before 0.6.0. Extension Changes Fixed the # character in a project's path preventing deployment. Known Issues When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Debugging in VS sometimes pauses forever until you manually break #42 . Porting Changes Added TinyCLR_Display_Provider::GetCapabilities . Removed the interop parameter from TinyCLR_Can_MessageReceivedHandler and TinyCLR_Can_ErrorReceivedHandler . Reordered members in TinyCLR_Api_Info . Reworked TinyCLR_Display_Provider::SetLcdConfiguration and other members to a generic SetConfiguration that takes a new TinyCLR_Display_ParallelConfiguration or TinyCLR_Display_SpiConfiguration . Renamed TinyCLR_Display_Format to TinyCLR_Display_DataFormat . Renamed TinyCLR_UsbClient_StreamMode to TinyCLR_UsbClient_PipeMode . Moved external flash drivers out of targets #58 . Updated many of the names of the targets. Known Issues The USB host API is missing. The USB client API is still very rough and will change. 0.8.0 on 2018-02-01 Notes This release adds a firmware and bootloader for the FEZ Hydra, a driver for the SPWF04Sx Wi-Fi module from STMicroelectronics, and a build of the core for Cortex-M7 based devices. We've also updated to the latest GCC and CMSIS builds, so be sure to visit the porting page to ensure you have the latest if you build your own firmware. Also added are overloads to the various SPI and I2C write and read functions that take an offset and a count so you no longer need to pass exact sized buffers. The previous overloads still exist for compatibility with UWP. While they're not yet exposed in managed code publicly, UART and CAN now allow you to customize the size of the read and write buffer for each port to suit your needs. Additionally, we've also added GetString to the Encoding class (as before, only UTF8 is provided by default). It takes a byte array so you can create a string without having to use an intermediate char array, potentially wasting space. Additionally, since strings are represented as UTF8 internally, you can save on having your already-UTF8 byte[] converted to UTF16 when it's converted to char[] , then back to UTF8 when using that char[] to create a string. To get started with the FEZ Hydra, you'll need to install the GHI Bootloader. Follow these steps to get going. As before, you can find all downloads in their respective sections on the downloads page. Just download the new installers and NuGet packages to get going. You don't even need to download the firmwares since you can use the update firmware feature in TinyCLR Config to automatically download them for you. Libraries Changes Added Encoding.GetString . Added string.IsNullOrEmpty . Added the non-generic System.Action delegate. Added various overloads to I2C and SPI write and read that take an offset and count. Added the Wi-Fi pins to the FEZ pins class. Added the missing I2C on Cerb socket 1 pins. Added driver for STMicroelectronics SPWF04Sx Wi-Fi module. Fixed offset in CAN WriteMessages having no effect. Fixed PwmController.ActualFrequency never being set. Known Issues Partially transparent ellipses have weird artifacts. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Pins are not currently reserved so you can create multiple objects on the same pin which behave incorrectly. Large responses for HttpGet and HttpPost on SPWF04Sx will overflow the internal buffer. SpiDevice::TransferFullDuplex requires same-sized arrays to function correctly. Firmware Changes Added FEZ Hydra. Added ADC 16 and 17 to STM32F4 #130 . Improved native SPI driver stability #128 . Changed CAN and UART default buffer sizes to be per-port #154 . Fixed I2C on LPC24 based devices failing after soft reset #164 . Fixed most frequencies on many PWMs not working on LPC17 and LPC24 #144 . Fixed handshaking on UART2 for LPC17 and LPC24 not working #143 . Fixed PWM on PB6 and PB7 not working on the G30 #141 . Fixed PWM not stopping on soft reset on the AT91 #137 . Fixed UART6 on Cerb being mapped incorrectly. Known Issues An internal error may sometimes occur during deployment. Reset the board, cancel deployment, and try again to work around it. Many UART properties and events are not implemented. Deploying over USB when out of memory crashes the board. PWM may jitter when decreasing the pulse length while enabled. Deploying on USBizi sometimes fails. Reset the board and try again to work around it. The LCD on EMM sometimes does not work. UART handshaking may miss data on STM32F4. Testing NaN s for equality gives unexpected results. The LCD has a blue tint on EMX and EMM #29 . The linker will not error when regions overflow or overlap #30 . The run app pin does not work on USBizi #39 . ADC 6 and 7 do not work on USBizi #40 . PWM on 3.27 does not work on EMM #41 . Debugging in VS with USBizi crashes the firmware sometimes #43 . The ADC on G80 may be slightly inaccurate #45 . CAN is not present on USBizi #114 . Debug.WriteLine sometimes does not output anything #173 . Trying to use handshaking on a UART port that doesn't support it does not throw an exception #175 . TinyCLR Config Changes Fixed the assembly list not clearing during reboot. Known Issues Many features will not function with devices running firmwares before 0.6.0. Extension Changes Fixed the list of assemblies after erase being populated with garbage. Fixed strings in the debugger longer than 128 characters displaying as garbage #169 . Known Issues When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Debugging in VS sometimes pauses forever until you manually break #42 . Porting Changes Added Cortex-M7 build. Added length parameter to TinyCLR_Display_Provider::WriteString . Added length parameter to TinyCLR_Interop_Provider::CreateString . Added TinyCLR_Debugger_Provider::Log . Added members to the native CAN and UART providers to control the buffer sizes. Renamed TinyCLR_Startup_SetDebugger to TinyCLR_Startup_SetDebuggerTransportProvider . Updated to latest CMSIS. Updated to latest GCC. Known Issues The USB host API is missing. The USB client API is still very rough and will change. 0.7.0 on 2018-01-04 Notes This release adds CAN support to many devices. The managed API reflects the UWP provider model, but there are more changes to come. We've also fixed the issue in the latest Visual Studio 15.5 update that prevents projects from building along with many other firmware level bugs. For best results with the 15.5 fix, you should either recreate your projects or remove the NoStdLib and AddAdditionalExplicitAssemblyReferences properties from your csproj (or vbproj). There have been several changes around the interop API in this release that makes it easier to interact with managed arguments, fields, and objects including reading, writing, creation, and reassignment. You can find an updated basic example on the interop docs . There was also a field added to the API info object that allows the API author to track custom state based on their needs. As before, you can find all downloads in their respective sections on the downloads page. There are no new bootloader releases this time. Just download the new installers and NuGet packages to get going. You don't even need to download the firmwares since you can use the update firmware feature in TinyCLR Config to automatically download them for you. Libraries Changes Added CAN provider. Added CAN and USB to pins. Fixed builds failing in the latest Visual Studio 15.5 update. Fixed some DataWriter not always growing the internal buffer enough causing it to throw. Fixed many errors and inconsistencies in pins. Updated the ResourceManager API to match the desktop more closely. Changed mscorlib.targets to props so it gets included first and also registered it with MSBuildAllProjects . Known Issues Partially transparent ellipses have weird artifacts. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Pins are not currently reserved so you can create multiple objects on the same pin which behave incorrectly. PwmController.ActualFrequency is always 0. Firmware Changes Fixed GpioChangeWriter generating an incorrect signal for periods above 50ms on G400. Fixed min and max clock values for SPI. Fixed debugging G120 through serial not working #34 . Fixed UART3 and UART4 not working on G120 #35 . Fixed non-blocking GpioChangeWriter not working on NXP devices #36 . Fixed the last two PWM being missing on Cerb #37 . Fixed PWM on PB8 and PB9 not working on Cerb #38 . Fixed AT91 SPI modes being incorrect #57 . Fixed 921600 baud not always working on STM32F4 #91 . Fixed some interrupts not working on STM32F4 #106 . Fixed incorrect SPI clock behavior on STM32F4 #108 . Enabled custom GPIO initialization in STM32F4 port #23 . Known Issues When the deployment is erased, a junk assembly list is returned until device reboot. An internal error may sometimes occur during deployment. Reset the board, cancel deployment, and try again to work around it. Rapidly pressing the buttons on the BrainPad may corrupt the display. Many UART properties and events are not implemented. Deploying over USB when out of memory crashes the board. PWM may jitter when decreasing the pulse length while enabled. Deploying on USBizi sometimes fails. Reset the board and try again to work around it. The LCD on EMM sometimes does not work. UART handshaking may miss data on STM32F4. The LCD has a blue tint on EMX and EMM #29 . The linker will not error when regions overflow or overlap #30 . The run app pin does not work on USBizi #39 . ADC 6 and 7 do not work on USBizi #40 . PWM on 3.27 does not work on EMM #41 . Debugging in VS sometimes pauses forever until you manually break #42 . Debugging in VS with USBizi crashes the firmware sometimes #43 . The ADC on G80 may be slightly inaccurate #45 . CAN is not present on USBizi #114 . STM32F4 is missing ADC 16 and 17 #130 . PWM does not stop after a soft reset on AT91 #137 . PWM on PB6 for G30 does not work #141 . UART2 handshaking does not work on NXP devices #143 . Several PWMs on NXP do not work at most frequencies #144 . TinyCLR Config Changes Added a list to show deployed assemblies. Added a button to enter loader mode. Added a display for separate core and device versions. Fixed crashes when multiple COM ports are present. Fixed many UI issues when rebooting the device. Updated the logo. Known Issues The assembly list is not cleared when rebooting the device. Many features will not function with devices running firmwares before 0.6.0. Extension Changes Added support for CustomToolNamespace . Readded resx to the My Project dialogs in VB. Readded the Code Analysis project page. Fixed VB resx generating under a second level namespace. Fixed the deploy list order not reflecting what is actually deployed to. Moved two properties from the project templates into the mscorlib.props file referenced by GHIElectronics.TinyCLR.Core . Increased the number of retries and decreased the wait between each when attempting to connect to the device. Known Issues When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Porting Changes Added the CAN provider. Added TinyCLR_Result::NoDataAvailable . Added TinyCLR_Api_Info::State for implementer use. Added support for arrays of non-primitives in interops. Added missing RLI region to NXP devices #46 . Added better macros for controlling debugger selection #53 . Fixed the version passed to SetDeviceInformation being ignored. Fixed device name and manufacturer for non-GHI devices #49 . Clarified policy around USB VID and PID by assigning one PID under our VID for general use #27 . Heavily reworked the interop API for easier use. Renamed TinyCLR_Power_Sleep_Level to TinyCLR_Power_SleepLevel . Known Issues The USB host API is missing. The USB client API is still very rough and will change. 0.6.0 on 2017-08-31 Notes This release adds support for the G400 and all of our previous NXP based devices: G120, EMX, Embedded Master, and USBizi. There are new LPC17 and LPC24 ports and ARM7, ARM9, and CortexM3 builds of the core now available in the GitHub repo . There are new classes available in the Pins library to go along with these new ports. The other major changes in this release are fixed automatic loading of USB drivers, updated bootloaders for devices, continued improvements to the BrainPad library, Acquire and Release were added to all native APIs, native interops have increased functionality, and sharing modes for devices are now supported. Also available in this release is a very early preview of the new TinyCLR Config tool. It can be used to check your device for updates over the internet and install an update if found (if the device has the GHI Bootloader version 2); save, load, erase, pause, and resume the managed application; and capture debug messages. More functionality is planned. See here for more information. Relatedly, we are also making signed drivers for the GHI Bootloader available for Windows 7 and 8. These drivers are not needed on Windows 10 or newer. Lastly, how we distribute releases is changing going forward. There's no longer one monolithic archive to download. Instead, everything TinyCLR can be found on its downloads page and bootloader binaries are available on the bootloader download page. MD5 hashes are provided for all downloads as well. Libraries Changes Split ReadTemperature in BrainPad to ReadTemperatureInCelsius and ReadTemperatureInFahrenheit . Moved Picture out of BrainPad.Display . Moved BrainPad.Expansion to the pins library. Changed the original BrainPad display driver to only allocate memory on first use. Added basic STM32F4, LPC17, LPC23, LPC24, and AT91 processor definitions to the pins library. Added many more devices to the pins library. Updated many pin names to match the processor name more closely (particularly COM to UART). Calls to *Provider.FromId in devices with the same id now return the same object instance. Sharing modes for the various providers in the devices library are now supported. Software I2C works correctly again. Added Environment.NewLine . Known Issues Formatting numbers that cross an assembly boundary can throw an exception. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Partially transparent ellipses have weird artifacts. Pins are not currently reserved so you can create multiple objects on the same pin which behave incorrectly. Firmware Changes Fixed the device not loading drivers over USB. Added clicker and clicker2. Added G400, G120, EMX, Embedded Master, and USBizi. Renamed FEZ to FEZCLR and FEZCerberus to Cerb #8 . Refactored specific devices out of the build script and into configuration files #6 . Corrected the incorrect index being passed to TinyCLR_Startup_SetDebugger #3 . Fixed PWM beyond timer 8 on on STM32F4 boards not functioning. Reworked the GPIO functions in the ports to more closely match the processor's API. Added ARM7, ARM9, and Cortex M3 targets. Added a flag for whether or not to run TinyCLR after rebooting. Added Acquire and Release to GPIO, ADC, DAC, PWM, Interop, Task, Memory, and API providers. Interop GetReturn now sets the return type automatically but will no longer create an array, object, or string (call CreateObject yourself after). Interop ReplaceObject now functions. Strings can now be manipulated in interops. Interops now support DateTime and TimeSpan objects by exposing them as U8. Added FindType to interops for finding a specific managed typed by name and assembly. Objects in interops now track the type of the object as well with the TinyCLR_Interop_ManagedObjectType type. Very basic object creation in interops has been added, but it fails in many cases and does not run any constructor. Removed the stack parameter from ReplaceObject in interop. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. Many UART properties and events are not implemented. Deploying over USB when out of memory crashes the board. Arrays of non-primitives in interops are not supported. CAN and USB host are missing. The USB client API is still very rough and will change. An 0xA2000000 error is sent over the debug transport when there is no deployment present. The version passed to SetDeviceInformation is ignored. PWM may jitter when decreasing the pulse length while enabled. Deploying on USBizi sometimes fails. Reset the board and try again to work around it. An internal error may sometimes occur during deployment. Reset the board, cancel deployment, and try again to work around it. Tight loops on LPC24 may prevent the debugger from working. The LCD on EMM sometimes does not work. The LCD has a blue tint on EMX and EMM #29 . Debugging VS through serial on G120 does not work #34 . UART 3 does not work on G120E and 4 does not work on G120 and G120E #35 . Non-blocking GpioChangeWriter does not work on NXP devices #36 . The last two PWM are missing on Cerb #37 . PWM on PB8 and PB9 do not work on Cerb #38 . The run app pin does not work on USBizi #39 . ADC 6 and 7 do not work on USBizi #40 . PWM on 3.27 does not work on EMM #41 . Debugging in VS sometimes pauses forever until you manually break #42 . Debugging in VS with USBizi crashes the firmware sometimes #43 . The ADC on G80 may be slightly inaccurate #45 . TinyCLR Config Changes Initial release. Known Issues The Update Firmware action won't work in this release because changes were needed in the firmware. Use the Loader tab to manually update the firmware. This will not be required in the next release as long as you have the firmware from this release or newer on the device. TinyCLR Config may not function properly with devices running firmwares from before this release due to changes in the communication protocols. Extension Changes Added a using for GHIElectronics.TinyCLR.BrainPad to the C# BrainPad Application template. Removed Expansion from the VB and C# BrainPad application templates. Updated URLs in the various NuGet and VSIX packages. Forced parity to none when using the serial debugger interface instead of using what the port configures. Known Issues Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.5.0 on 2017-07-07 Notes This release focuses on the public porting library and API -- though there are a few minor fixes and changes in other areas. As part of the new porting experience, we are also releasing a very early build of TinyCLR for the Netduino 3 and Quail mainboard! You can now port TinyCLR OS to run on your own system using the header file and library we provide -- as long as your architecture is supported. Currently, only Cortex M4 is available. Keep in mind the available API is still alpha and may change, especially USB client. See here for details. You can also create your own managed functions that can call into native code that you provide. These will be automatically wired into the system for a seamless experience. See here for details. To support this, we added a few more classes under System.Runtime.InteropServices . Most important is the Interop class. It allows you to add and remove interops from the system by providing it with the address in memory of the interop definition table. It expects you to load it into memory yourself using the Marshal class. You can use FindAll to get back a list of all interops registered in the system and RaiseEvent to trigger an event on the specified native event dispatcher. The NativeEventDispatcher class allows you to get an instance of the class to receive events that the specified dispatcher name receives (either from native code or Interop.RaiseEvent ). It has a single event that gets triggered whenever an event is received. There is only one instance per dispatcher name, so calls to GetDispatcher with the same name will return the same instance. Similar to Interop , Api can be used to add and remove native APIs from the system. It expects you to load the API into memory yourself and pass it the address of the API definition. You can query all registered APIs, find a specific API by name and type, and parse and creator selectors. Selectors are a string that represents an API name and index into its implementations of the form \"name\\index\". A default selector is set so that a specific API type can be returned without knowing the exact name, like the default GPIO controller on a system. The Api class is used internally by the devices library to talk to the native implementation via the implementation IntPtr provided for the given API name and index. In some cases you can use the GetDefault method on a given device provider to return the default registered API. If there is no default, like for PWM and others, you can pass the Id property in the specific pins class to the desired device provider. We added Marshal.GetDelegateForFunctionPointer to enable you to create a quick native interop for a specific address in memory that takes a single ref IntPtr parameter and returns nothing. DeviceInformation was also added to return the device name, manufacturer, and version set on the native side. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Added running device detection. Added listing, adding, and removing system interops. Added listing, adding, and removing system APIs. Added Marshal.GetDelegateForFunctionPointer . Added NativeEventDispatcher . Added provider IDs to pins. Added FEZ pinout. Added Expansion to BrainPad. Updated devices library to use the provider and native API model via a Provider class for each type. Core assembly was renamed to mscorlib . GetDeviceSelector and DeviceInformation.FindAll now throw an exception on use. Opening a non-existent UART now throws on construction. Changed DateTime.Ticks to use the same epoch as the desktop. Gpio write now fires ValueChanged . BrainPad accelerometer now uses the proper axes and scaling. BrainPad Image was renamed to Picture . BrainPad WriteOnComputer was renamed to WriteToComputer . BrainPad Servo SetMaxPulseWidth now has correct range in the exception message. Increased the duration and frequency of the BrainPad buzzer beep. Original BrainPad display now works. Replaced AutoShow flag on BrainPad with DrawTextAndShowOnScreen methods. Reworked BrainPad Servo API. Removed BrainPad Board class. Known Issues Software I2C can lock up the board if a slave device isn't connected or responds improperly. Formatting numbers that cross an assembly boundary can throw an exception. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Device sharing modes are not respected. Partially transparent ellipses have weird artifacts. Pins are not currently reserved so you can create multiple objects on the same pin which behave incorrectly. Software I2C does not work. Firmware Changes Initial FEZ Cerberus, FEZ, Netduino 3, and Quail firmware release. All peripherals are now properly reset on startup. Gpio write values are stored when not in output model. Fixed PWM jittering. All frequencies now round down. Fixed gpio interrupts being slow and something getting missed. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. GpioChangeWriter generates an incorrect signal for periods above 50ms on G400. An 0xA2000000 error is sent over the debug transport when there is no deployment present. Many UART properties and events are not implemented. There is no firmware for G120 and G400 in this release. PWM on controller 8 and up does not work on the G80. Deploying over USB when out of memory crashes the board. Extension Changes Removed stray semicolon in BrainPad Visual Basic template. Changed BrainPad templates to have a BrainPad static class in them. Reduced the number of retries for connecting to device. Added namespace to C# BrainPad template. Known Issues The device may not load drivers on Windows 7 preventing Visual Studio from seeing it. Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Porting Changes Initial release of porting library and API. Known Issues Marshalling strings does not work. Marshalling DateTime and TimeSpan does not work. Creating and replacing managed objects does not work. CAN and USB host are missing. The USB client API is still very rough and will change. 0.4.0 on 2017-05-10 Notes This release primarily fixes several bugs; implements more of the serial API; adds DataReader , DataWriter , and Marshal classes; and reworks a lot of the BrainPad API. A new Storage library was added that moves some large members (like DataReader ) out of Devices that you may not always needed. There is more to be added to this library down the road. SignalGenerator , SignalCapture , and PulseFeedback were renamed to match the Windows 10 counterparts. Their API will be updated to match as well in a future release. The Marshal class under System.Runtime.InteropServices can be used like the old Register and AddressSpace classes to read and write memory. It also adds allocating and releasing unmanaged memory from the managed side that can be manipulated from the other members. You can see a quick example on using the new serial API here . You must use either the DataReader and DataWriter classes or use the WindowsRuntimeBufferExtensions to manipulate a Buffer since the internal array is no longer publicly accessible to match the UWP API. Pay attention to the Load and Store members. You can't read before calling Load and writes do not get flushed until you call Store . There has been no change to the G120 and G400 bootloaders in this release so you do not need to update them if you already have them on your device from the 0.3.0 release. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Fixed GpioPin.ValueChanged sender parameter type to be GpioPin. Fixed many of the Debug and Trace members not functioning properly. Fixed LowLevelDevicesController.DefaultProvider throwing an exception when null instead of falling back to the built-in providers. Fixed SerialDevice.Read not respecting the ReadTimeout value. Fixed SerialDevice.BytesReceived and IBuffer.Length not getting updated when reading. Fixed the exception that was thrown in BrainPad.Buttons when buttons are pressed. Fixed the exception that was thrown when using BrainPad.ServoMotor . Fixed PWM glicthing other pins on the same controller when changing one pin. Fixed Thread.Sleep not always sleeping for the proper amount of time. Fixed SerialDevice.ErrorReceived not being raised. Added EventArgs . Added WindowsRuntimeBufferExtensions . Added DataReader and DataWriter . Added various From methods to TimeSpan . Added InteropServices.Marshal . Added EditorBrowsable attribute to several members inherited from object to the BrainPad members. Added GHIElectronics.TinyCLR.Storage with WindowsRuntimeBufferExtensions , DataReader , and DataWriter in it. Updated the underlying value of the SerialError enum. Updated the BrainPad to be based around instance properties rather than static classes. Updated SerialDevice.Read to only support InputStreamOptions.Partial and InputStreamOptions.None . Moved InputStreamOptions , IInputStream , IOutputStream , IBuffer , and Buffer to the GHIElectronics.TinyCLR.Core assembly. Moved the BrainPad expansion pins to the pins library. Improved support for the original BrainPad in the driver. Improved many of the BrainPad APIs. Removed the members of Buffer that don't conform to the UWP API. Renamed SignalGenerator to GpioChangeWriter , SignalCapture to GpioChangeReader , and PulseFeedback to GpioPulseReaderWriter . Known Issues The original BrainPad display does not currently work with the GHIElectronics.TinyCLR.BrainPad library. Software I2C can lock up the board if a slave device isn't connected or responds improperly. ServoMotors.SetMaxPulseWidth has an invalid range in the exception message. Formatting numbers that cross an assembly boundary can throw an exception. Opening a non-existent UART will only throw when it is used. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Firmware Changes Fixed the G30 sometimes getting stuck during deployment. Added another sector to the G30 deployment region. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. Gpio interrupts may be slow when Visual Studio is connected. Some frequencies may round up instead of down if the requested frequency cannot be met. An 0xA2000000 error is sent over the debug transport when there is no deployment present. GpioChangeWriter does not generate proper signals for periods above 50ms on G400. Extension Changes Added a flag on the TinyCLR OS property page to control stub generation style. Added the DebuggerNonUserCode attribute to the startup code in BrainPad templates. Removed the public modifier from the C# application template. Known Issues The Visual Basic BrainPad template has a semicolon in the startup file. The device may not load drivers on Windows 7 preventing Visual Studio from seeing it. Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.3.0 on 2017-04-06 Notes This release has several API additions. Some were added as features themselves (software SPI, SignalGenerator, etc) while others were added to support certain features (the VB runtime, string.Format, MemoryStream and IntPtr for Drawing, etc). We're working to align ourselves with the various .NET Reference Sources available. You'll also see many new icons throughout, application templates for the BrainPad, and common item templates. The NuGet packages that have dependencies (such as on Core), now require the major and minor versions to match. For example, the 0.3.0 Devices library depends on Core [0.3.0,0.4.0). This is to further our use of SemVer so that the native interop checksum only changes in major and minor versions. See the NuGet docs for more information. The biggest addition is the drawing library. It was designed to mirror System.Drawing from the desktop. The basic API is there but there is still more work to be done. To support this, a DisplayController was added to the devices library to configure the display. Since there is no config yet you need to configure the display every time your program starts. A notable change from NETMF is calling flush on a drawing surface the size of the display will no longer draw to the display. Only drawing surfaces created from the FromHdc method passing in the Hdc value from the DisplayController will flush to the display. At this time, only bmp images are supported. Make sure you add a reference to GHIElectronics.TinyCLR.Drawing if using bitmap or font resources. Since it's in NuGet now it isn't automatically added. Support for Visual Basic has also been reenabled. One important thing to keep in mind is that there is no longer a Microsoft.VisualBasic assembly. We are using the embedded runtime option provided by Roslyn. It relies on several APIs being present in the core library. We added several of the key APIs needed to enable common usage scenarios. If you find you're getting cryptic compile errors from locations not in your code, let us know so we can evaluate what additional APIs are required. Since the UWP API only supports a controller wide frequency, we had to rework PWM a little bit. There is no longer one controller like there is for GPIO, instead one controller exists for each frequency source. On devices like the G30 and G80, this is a timer. On devices like the G400, there are independent registers for each channel (so unfortunately there will be one controller per channel). The pins library has been updated to organize PwmPin around controllers. SignalGenerator, SignalCapture, and PulseFeedback have also been added, but their APIs will change in a future release to match the UWP style. You can also now change what gets returned by GetDefault calls on the various controllers by updating LowLevelDevicesController.DefaultProvider. The Diagnostics namespace now matches the desktop version more closely. WriteLineIf and Assert were added to Debug and Trace was added as well. All methods on Debug and Trace are marked with the Conditional attribute as expected using the DEBUG and TRACE constants respectively. There's also now a Listeners property on each. This is a collection that you can add to so you can receive whatever is written to Trace or Debug by registering a class derived from TraceListener. As on the desktop, both Trace and Debug share the same listener collection. By default, the collection is populated with a listener that prints to the debug transport which is now at Debugger.Log. Collect and GetTotalMemory were added to GC. Note that GetTotalMemory returns the amount of memory used, not free, to match the desktop. We're investigating APIs to return the amount free. The last notable change is that we implemented IntPtr and UIntPtr. For now, they're only used as the type of the Hdc property in drawing. We expect them to be used in more places going forward. Since these two types map to native int and native unsigned int in the CLR and the managed compilers emit those types when they encounter IntPtr or UIntPtr, we have also added initial support for those types in the interpreter and runtime as well. Let us know if you encounter any weird or hard to explain runtime issues. This release also includes the firmware for the G400. It requires an updated bootloader from the one provided on the G400 bootloader installation page . Simply download the bootloader installer from the installation page and replace Bootloader.bin with the bootloader provided in the TinyCLR download package (making sure to rename it to Bootloader.bin). This updated bootloader can still be used to install the NETMF G400 firmware. It will eventually replace the one provided on the installation page. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . You can see some examples of the new APIs added in this release here . Libraries Changes PWM now has one controller per frequency source (usually a hardware timer) allowing different frequencies for each controller. string.Format should now work in all cases. Formatting numbers (ToString(\"N2\"), etc) should now work in all cases. I2C read/write partial functions now return the proper result. Opening non-existent ports no longer crashes the firmware. CultureInfo, NumberFormatInfo, and DateTimeFormatInfo now implement IFormatProvider. Primitives (except Boolean), DateTime, TimeSpan, Guid, and Enum now implement IFormattable. Added the == and != operators to Guid. Added a drawing library and display configuration. Added Enum.GetUnderlyingType Added LowLevelDevicesController and the provider API model for SPI, I2C, GPIO. Added SignalGenerator, SignalCapture, and PulseFeedback. Added software providers for I2C and SPI. Added CompilerGenerated, SuppressMessage, and In attributes. Added class target to Conditional attribute. Added FormatException and OverflowException. Added InvariantCulture and CurrentCulture to CultureInfo. Added FormattableString and FormattableStringFactory. Added Collect and GetTotalMemory to GC. Added MemoryStream. Added parts of the CodeContracts namespace. Added implementations to IntPtr and UIntPtr. Added Debugger.Log. Added Trace. Added Assert and WriteLineIf to Debug. Added listeners collection to Trace and Debug and a default listener mapped to Debugger.Log. Added BrainPad. Known Issues The sender parameter in the ValueChanged event on GpioPin is an instance of IGpioPinProvider, not GpioPin. Opening a non-existent UART will only throw when it is used. SignalGenerator may fail for small durations. An exception is thrown in BrainPad.Buttons when buttons are pressed. An exception is thrown when using BrainPad.ServoMotor. Some frequencies may round up instead of down if the requested frequency cannot be met. In the Debug class, only WriteLine(string) functions correctly. Firmware Changes G30 should no longer get stuck at waiting for device to initialize. PWM no longer takes 40 seconds to start on the G30 and G80. GPIO interrupts now work on the G120E. Added support for native int and native unsigned int in runtime Added G400 firmware. Known Issues Deploying to the G30 sometimes fails when writing a sector. An 0xA2000000 error is sent over the debug transport when there is no deployment present. Extension Changes Assemblies larger than sector size can now be deployed. Added Visual Basic support. Added BrainPad Application templates Added common item templates. Added icons throughout. NuGet packages now have a better range dependency for dealing with assembly checksums. Known Issues Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.2.0 on 2017-03-07 Notes You cannot use projects you made for the 0.1.0 version. You must recreate them and re-add your code files because of the changes to the project templates to make them more closely align them with the desktop .NET templates -- you'll notice the only difference is a few properties which prevent inclusion of reference assemblies. The templates also use the .NET Framework 4.5.2 target framework. This is only for NuGet compatibility going forward and does not mean you can use other libraries targeting that framework. This was done in anticipation of broader project system support of the new PackageReference format currently used in .NET Core which fails with unknown target frameworks. The MSBuild package is no longer provided or required. The metadata processor tool has moved internally to the extension and is invoked during deployment to the device. This means that pe and pdbx files are no longer redistributed with their assemblies -- they appear in a pe folder under the output directory when you deploy. We have also rewritten how dependencies are detected for deployment. If you notice any weird failures around assembly resolution or deployment, let us know and send us the entire project as-is so we can diagnose it. The information displayed while deploying to the device has also been improved to show more information about what is going on and what stage the deployment is in. We've also reworked incremental deployment so that assemblies are deployed one to a flash sector (if space allows) to enable re-deploying only the assemblies that have changed on a sector by sector basis. This greatly increases deployment speed on devices which a large number of flash sectors allocated to deployment. This release also includes the firmware for the G120 and G120E. Because the current GHI bootloader on the G120 expects to load TinyBooter, we have provided a second stage bootloader with this preview that you must deploy using the existing GHI bootloader as if you were deploying TinyBooter. Once it is deployed and you restart the device, you'll notice that it starts our newer GHI bootloader 2.0 . You can then use this second bootloader to deploy the TinyCLR OS firmware. Asserting LDR0 will enter the second bootloader while asserting both LDR0 and LDR1 will enter the original bootloader and allow you to return to NETMF. After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Formatting numbers works in more cases. The built in \"en\" culture has been removed. The dependency on GHIElectronics.TinyCLR.MsBuild has been removed. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. The duty cycle and polarity can now be set when the PWM pin is stopped. The frequency for the PWM controller can now be set at any time. PwmController.SetDesiredFrequency and PwmController.ActualFrequency now return the actual frequency the device was able to meet. The min and max frequency for PWM is now returned correctly. Removed analog input and output precision. Added G120, G120E, and FEZ Cobra III. CAN bus definitions now return a friendly name instead of an integer. Renamed Gpio to GpioPin, AnalogInput to AdcChannel, AnalogOutput to DacChannel, and PwmOutput to PwmPin. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. Known Issues Formatting numbers sometimes returns incorrect values. string.Format fails for non-trivial cases. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. Some frequencies may round up instead of down if the requested frequency cannot be met. Firmware Changes Added G120/G120E firmware. Flushing over USB is quicker. GPIO interrupts are now raised reliably. The maximum allocation is now 51,539,607,484 bytes. Known Issues PWM frequencies beyond 45MHz on G80 and 21MHz on G30 can fail. PWM may take up to a minute to start on G30 and G80. Extension Changes Breakpoints and the commands dependent on them now function properly. References no longer need a solution reload to deploy. The GHIElectronics.TinyCLR.MsBuild package has been removed. PDBX and PE files are now generated at deploy time. The deployment progress log shows more information. Incremental deployment is now better about deploying only what has changed. Debugging stops quicker after all threads in the application exit. The project templates now mirror the desktop templates much more closely. The Visual Studio projects now target .NET Framework v4.5.2. Known Issues Deploying an assembly larger than the flash sector size fails. An 0xA2000000 error will get sent over the debug transport whenever there is no app present. 0.1.0 on 2016-12-16 Known Issues After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Breakpoints and the commands dependent on them (run to cursor, others) do not work. As a work around, add a class library project called mscorlib to your solution and add a project reference to it or insert calls to System.Diagnostics.Debugger.Break. References can fail to deploy unless a solution close and open occurs after adding the reference. Re-deploying immediately after stopping debugging can fail. Try again to work around it. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. PwmController.SetDesiredFrequency must be called before any call to PwmController.OpenPin. PwmPin.SetActiveDutyCyclePercentage must be called after Start. GPIO interrupts do not always trigger. PWM may take up to a minute to start. Formatting numbers yields incorrect results in some cases. string.Format fails for non-trivial cases. Only Core, Devices, and Pins libraries are available. Only G30 and G80 are available. Packages are not uploaded to the NuGet public gallery. Additions TimeSpan.Total* {int/long/double/...}.TryParse(string source, out value) string.Format(string format, param object[] args) System.Diagnostics.WriteLine(string message) Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/tinyclr-config.html": {
    "href": "software/tinyclr/tinyclr-config.html",
    "title": "TinyCLR Config",
    "keywords": "TinyCLR Config TinyCLR Config is a stand-alone tool to help managing TinyCLR OS devices. The tool is cloud-connected. It automatically finds and downloads newer firmware versions from a list of provided sources. These sources can be on the internet or local on your machine if you don't have or don't want to access to the internet. The firmware update functionality only works for devices that have GHI Bootloader v2 . You can download TinyCLR Config from TinyCLR Config section of our Downloads page. The TinyCLR Config tool is stil in development. Please stay tuned . Firmware Sources When TinyCLR Config starts up, it looks for a file called FirmwareSources.txt in the same directory as the TinyCLR Config executable itself. If the file isn't present, it's created automatically with one entry pointing to the official GHI firmware store. The file is a comma-separated list of sources, one per line. The first value is an integer priority with lower numbers being searched first. Each source is tried until a newer version than the currently flashed version is found. The next value is either Local or Network which determines where the next value points to: the local disk or the network. The last value is a URI that points to an xml file that defines the list of available firmwares. The firmware xml list is made up of a list of devices. Each device has a name attribute and firmware list child. Within the firmware list is a list of each available firmware. Each firmware must have an MD5 hash that matches the file pointed to, a version of the form major.minor.patch , a release date, and a uri that points to the location of the firmware (the location type must match the location type of the firmware list itself, i.e. local vs network). See the official hosted file for a complete example. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/loaders/intro.html": {
    "href": "software/tinyclr/loaders/intro.html",
    "title": "Bootloaders Introduction",
    "keywords": "Bootloaders Introduction A bootloader is a small software that boots up the system and runs the firmware. It is also used to update the firmware. This section covers different bootloader features and usage details. GHI Bootloader The GHI Bootloader page can be found here . This page describes the bootloader commands, using the bootloader to load firmware onto a device, and has a downloads section where you can find the bootloaders for our products. Upgrading Bootloader v1 to Bootloader v2 Some of our earlier devices based on the NXP LPC family of microcontrollers come shipped with our Bootloader v1 installed. These include the Embedded Master, EMX, G120, G120E, and USBizi devices. To upgrade this bootloader to v2, go to the GHI v1 to v2 bootloader page STM32 Bootloader The STM32 Bootloader page can be found here . This page covers loading .hex, .bin, and .dfu files onto our STM32 based devices. SAM-BA Bootloader The SAM-BA Bootloader lives on many Atmel chips. It is necessary to load files (loaders and/or firmware) onto the chip. Several TinyCLR OS supported boards will use this loader to load the software. The SAM-BA Bootloader page can be found here . Mikro Bootloader MikroElektronika's bootloader is found on several products offered by them. Some of the TinyCLR OS supported boards are made by MikroElectronika and include this loader by default. This page covers it in full details https://learn.mikroe.com/bootloaders/"
  },
  "software/tinyclr/loaders/sam-ba-bootloader.html": {
    "href": "software/tinyclr/loaders/sam-ba-bootloader.html",
    "title": "SAM-BA Bootloader",
    "keywords": "SAM-BA Bootloader The SAM-BA Bootloader lives on many Atmel chips. It is necessary to load files (loaders and/or firmware) onto the chip. Several TinyCLR OS supported boards will use this loader to load the software. Uploading bin Files To set the chip in SAM-BA mode, hold down the dedicated button on your board (BOOTA on UCM Dev and Breakout boards) while the system powers up (or during reset). If there is no such button, connect SPI1_MISO to ground instead. Keep the pin grounded for three seconds after power up or reset and then remove the connection from SPI1_MISO to ground. The device manager will show a COM port similar to \"Bossa Program Port\" or \"GPS Detect\". If it is not already installed, download and install the SAM-BA tool from Microchip. The latest version we have tested is 2.18 for Windows. Open the SAM-BA program then select the COM port for your device in the connection box and your board type below it (at91sam9x35-ek for G400), then click connect. Near the middle of the window, go to the DataFlash AT45DB/DCB tab. Under Scripts , select Enable Dataflash (SPI0 CS0) then click the Execute button.. Under Scripts , select Erase All then click Execute . This will take some time to complete. It seems that if SAM-BA loses focus during the erase procedure it can lock up. We recommend that once you click the Execute button you leave the computer alone until the erase procedure is completed. Under Scripts , select Send Boot File , click execute, then browse to and select the bootloader for the device. Once the transfer finishes, go to File > Quit and then reset the board. Make sure to properly quit the program or connection errors may result on subsequent uses. Now reset the board. Congratulations, your board is now running the loaded program!"
  },
  "software/tinyclr/native/intro.html": {
    "href": "software/tinyclr/native/intro.html",
    "title": "Native Code on TinyCLR",
    "keywords": "Native Code on TinyCLR TinyCLR has a few different ways you can use native code. You may want to do this for performance reasons or to access advance features on your platform. The most commonly used option will be native interops combined with native APIs . Interops allow you to call native code from your managed application and interact with managed data from the native side. APIs allow access to other services registered with the system like SPI, GPIO, and I2C. You will commonly want to access an API from your native interop. You are also able to port TinyCLR to a new device. Most ports will be based off of an existing target like the STM32F4 and simply change the device periperal mappings. A more advanced use case is to port TinyCLR to an entirely new target that is not currently available, provided that it is based on one of the architectures we support, such as Arm Cortex M4."
  },
  "software/tinyclr/native/porting.html": {
    "href": "software/tinyclr/native/porting.html",
    "title": "Porting TinyCLR",
    "keywords": "Porting TinyCLR TinyCLR OS can be ported to new devices. We provide the precompiled .NET interpreter and runtime for several architectures. Currently Cortex M3, Cortex M4, Cortex M7, ARM7, and ARM9 are supported. To get started we'll build the FEZCLR firmware that the FEZ uses. Clone the ports repo to your computer. Make sure to clone the master branch so you're using the latest stable version. If you're new to git or haven't even heard of it, take a look at the Git Book to learn more about it. Download and install GCC . The latest version we have tested is 7-2018-q2-update . Download and extract the contents of CMSIS into the CMSIS folder of the cloned repo. While the file extension is *.pack , it's actually a zip that you can extract once you rename it to *.zip . Download and extract the latest TinyCLR OS Core Library into the Core folder of the cloned repo. Make sure to download the version corresponding to the version of the source code that you're trying to build. If you're building the master branch, then you want to use the very latest released version. Open a command prompt, change the directory to the cloned repo, and then execute build.bat FEZCLR . The compiled firmware can then be found in the repo directory under build\\release\\FEZCLR . The build system automatically produces firmware images in hex format (.hex), a raw binary (.bin), and either a binary meant to be loaded by our GHI Bootloader with its U command (.glb) or a binary meant to be loaded by the same bootloader with the X command (.ghi). For the FEZCLR firmware we built, flash the FEZCLR Firmware.glb to your FEZ following the instructions on the bootloader page. When you restart it, it should be running TinyCLR OS and you can deploy to it from Visual Studio. Creating your own device To create a new firmware for a board that a Target already exists for, you just need to create a new folder under Devices to define your board. You can do this easily by copying an existing board, like the FEZ, and making the changes you need for your board. Make sure you update the scatterfile to place the final firmware image in memory where it needs to be. For example, the FEZ scatterfile expects the GHI Bootloader to be present but you need to place your firmware's image at the start of flash. To make using a custom port easier, we're specifically making the USB product ID 0x5000 under our vendor ID (0x1B9F) available for anyone to use for the USB debug interface on their TinyCLR device. Make sure to only use this product ID because other product IDs are assigned by us for our own use. Of course, if you have your own vendor ID, you are free to use it. So when you copy an existing device to make a new one, be sure to verify the USB vendor and product IDs are correct. Creating a new target To port to a new board with a new Target , make sure it is one of the architectures that we have made a core library available for. Then, like above, you'll need to make a new folder for your device under the Devices folder. You'll also need to create a new folder under Targets that implements the needed APIs. The TinyCLR runtime requires you to provide a few APIs for it to function correctly: deployment, interrupt, power, and time. The runtime also makes a few APIs available to you automatically: the API provider itself; a memory allocator; a recurring task creator; and a way to interact with managed objects, arguments, and events. Beyond that, you can provide whatever APIs you need like GPIO and SPI. See the native API document for details on APIs. On top of providing several APIs, you must call all the functions under TinyCLR_Startup_* to properly initialize the system. The main.cpp provided in the repo that our existing ports use and the build system includes is a good starting point. Contributing We are taking contributions to the TinyCLR OS ports and documentation, but we don't have an established process just yet, so standard contributing practices apply. Create a fork of the repo, create a new branch from dev, work on your changes, then submit a PR. Make sure to follow the existing style for the project and keep your changes easily reviewable. Your changes will need to be licensed under Apache 2 and you need to sign a Contributor License Agreement with us before your PR can be accepted."
  },
  "hardware/breakout/intro.html": {
    "href": "hardware/breakout/intro.html",
    "title": "Breakout",
    "keywords": "Breakout We offer breakout boards for all of our SoMs to speed the path to programming and product development. All of these boards offer through hole connections which accept standard 0.10 inch headers. Some boards also offer surface mount edge connections which are ideal for short production runs."
  },
  "hardware/duino/fez-domino.html": {
    "href": "hardware/duino/fez-domino.html",
    "title": "FEZ Domino",
    "keywords": "FEZ Domino Resources Schematic Software For information on programming the FEZ Domino, please go to the USBizi page."
  },
  "hardware/duino/fez-panda-ii.html": {
    "href": "hardware/duino/fez-panda-ii.html",
    "title": "FEZ Panda II",
    "keywords": "FEZ Panda II An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Panda II, please go to the USBizi page."
  },
  "hardware/fez/intro.html": {
    "href": "hardware/fez/intro.html",
    "title": "Introduction",
    "keywords": "Introduction The Maker Board to Rule Them All! FEZ (fast and easy) is our magnificient maker board. This low cost board offers Arduino pinout compatibility, optional Wi-Fi for IOT applications, and can be programmed using multiple programming languages and development environments. Pricing, purchasing and other information can be found on the FEZ page on our main website. Specifications Spec Value Processor STMicroelectronics ST32F401RET6 Speed 84 MHz Internal RAM 96 KByte Internal Flash 512 KByte Dimensions 70.6 x 56.0 x 14.5 mm Peripherals* Peripheral Quantity GPIO (5V tolerant) 22 IRQ 22 UART 1 I2C 1 SPI 1 PWM 8 12 Bit ADC 8 CAN 0 USB Client 1 Wi-Fi Optional * Note: Many peripherals share I/O pins. Not all peripherals will be available to your application. Resources Schematic TinyCLR Tutorial Programming Options TinyCLR Embedded programming using Visual Studio .NET. Learn more... Arduino Very popular open source standard. Learn more... Mbed Free online C/C++ compiler. Learn more... MicroPython A version of Python for microcontrollers. Learn more... Bare Metal Use the Cortex-M4 compiler of your choice. Learn more... Shields Selected to help get you started. Learn more... Our TinyCLR operating system lets you program the FEZ (and other devices) in C# or Visual Basic using Microsoft's Visual Studio -- and it's all free! Learn more... . Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/netmf/tutorials/fez-hydra-developers-guide.html": {
    "href": "software/netmf/tutorials/fez-hydra-developers-guide.html",
    "title": "FEZ Hydra Developers' Guide",
    "keywords": "FEZ Hydra Developers' Guide FEZ Hydra is a 100% open source hardware (OSHW). This means, hardware design files are made public and the software running the board is made public as well. Even better, FEZ Hydra hardware is designed with EAGLE, one of the most popular design tools and the software is developed on the free, open source GCC compiler. Licensing The design files are available to everyone to use, even commercially. The software is licensed using Apache2 . This license allowing for changes, for commercial use and for even close sourcing the derived designs. The hardware is licensed using Creative Commons Share Alike 3.0 . This license allows for commercial use and for derived work but doesn't allow close sourcing the derived work. Please contact GHI if you need to close source your derived work. Note that the FEZ nor the FEZ Hydra name are licensed for use. GHI is licensing the designs as outlined above, even for commercial use, but is not giving any rights to use the any GHI Electronics's trademarks. Check the link above for full details on the license. If you are making your own commercial product, you should have a completely different and distinctive name. Using derived names or similar names will only confuse your own customers and GHI's customers. GHI is interested in learning about what you are doing with FEZ Hydra design files. We can help you even further; so, please consider contacting GHI directly with info about your project. To properly attribute this work, your board should say Based on GHI's OSH FEZ Hydra and your website and all documentation should say Based on GHI Electronics' Open-Source-Hardware FEZ Hydra design files. Visit this page for more details http://www.ghielectronics.com/docs/39/fez-hydra-developer The open-source Files FEZ Hydra EAGLE design files are found here . The files are provided AS-IS. FEZ Hydra software components are available at https://bitbucket.org/ghi_elect/netmf-open-firmware To build the software, you need RVDS or GCC compilers. This page covers more details on using GCC on building your own firmware FEZ Hydra Firmware . Real Time Clock For the Real Time Clock to function, VBAT must be supplied with 1.2 volts. RLP RLP on the FEZ Hydra is a bit different than our other offerings. We do not support parsing ELF files. You must compile your native code into a raw binary image and load it using our AddressSpace class to the RLP address of 0xA0000000. You must find the address of your desired function in the map file that the compiler produces and construct a NativeFunction object manually using that address. Invocation and parameter passing function identically, except that RLP extensions (the RLP.h file) are not supported. The FEZ Hydra folder in the samples archive linked on the RLP page contains a Keil uVision project. It is already configured and references the NativeCode.c file. Just open the project in uVision and build it after you have made your changes to NativeCode.c. For advanced users creating their own project, you want to compile from the Atmel AT91SAM9RL64 processor with an R/O base of 0xA0000000 and R/W base of 0xA0080000. Make sure that you convert any generated ELF file into a raw binary file. Feature Set As FEZ Hydra has been released as open source, some of the features found in other GHI Electronics' products are not available. The following are not supported: SPI display configuration Non-blocking Signal Generator CAN Play PCM audio Bitmap convert to file Watchdog RLP ELF file parsing RTC Alarm Hibernate InField Update Startup Logo SD card detection BuiltInEthernet Wi-Fi RS9110 PPP SQLite USB host USB client Passing bitmaps to RLP Bitmap get and set internal buffer SSL UART handshaking Configuration read and write Pulse capture Known Issues Sockets 3 and 4 should be labeled SX and SUX respectively. Type K on socket 6 is also not available. Loader Update To update the loader, you must erase the device and then deploy the new loader. To begin, disconnect all modules, connect pin eight on socket three or four to ground, power the board, wait five seconds, then unconnect the pin. If your FEZ Hydra has a small button just above socket 9, you can hold that down while powering the board instead of grounding pin 8. After you do that, the device will show up as a COM port in the Devices and Printers menu in Windows. Make note of the COM port number. Navigate to: C:\\Program Files (x86)\\GHI Electronics\\GHI NETMF v4.3 SDK\\Firmwares\\FEZ Hydra\\Loader. Right click on Update.bat, click Run As Administrator, and follow the instructions. \"Updating\" should be displayed on the screen for several minutes. Once \"Done\" is displayed, reset the device, and deploy the firmware using FEZ Config as detailed on the Firmware Update page . Tip If \"Updating\" is only displayed for a few seconds before done is display, the update did not complete. The Log.txt file created in the same directory can help diagnose the problem."
  },
  "software/tinyclr/loaders/ghi-bootloader.html": {
    "href": "software/tinyclr/loaders/ghi-bootloader.html",
    "title": "GHI Bootloader",
    "keywords": "GHI Bootloader The GHI Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device (if present). The bootloader communicates over a USB virtual serial port and a regular serial port. The interface used is controlled by a MODE pin. See your device specifications for details on interface configuration and selection and which version of the bootloader it runs. Tip If you are running Windows 7 or Windows 8, you must install drivers for the bootloader to appear in Windows. See \"USB Drivers\" in the downloads section . Bootloader v2 All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: returns the current version. N: returns the current device type. E: erases all user sectors of the device. R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a ghi file to the device using 1K XMODEM. Only send *.ghi files meant for your device. U: upload a glb file to the device using 1K XMODEM. Only send *.glb files meant for your device. Loading the Firmware Using TinyCLR Config TinyCLR Config tool includes multiple features developers need to work with TinyCLR OS-enabled devices. It simplifies the firmware update and it includes options for accessing the TinyCLR firmware at runtime. Using this tool is the recommended path; however, manual installation instructions are also included on this page. Read more on the TinyCLR Config page. Manually Loading the Firmware TinyCLR Config tool should be used to update the firmware. As a backup, use these instructions: Set your board in the bootloader mode. Each product has a specific way to enter the boot loader. Open any terminal software, for example Tera Term . Select serial and pick the COM port associated with your board. (If unsure, check Device Manager) Press V and then enter. You will see back the boot loader version number (v2.x.x) Press U or X and then enter. Use X for firmware file type GHI and U for firmware file type GLB. Press Y to confirm then enter. You will now see CCCC ... Go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the firmware file. When the transfer is complete, reset your board. GLB File Format The glb files that are loaded onto devices have some additional metadata that help the bootloader function in addition to the raw data itself. The first 1,024 bytes of a glb file is the upload header. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that this image should be copied to. 32 bit unsigned length of the image to flash rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the image. After the upload header is the actual image to flash. If its length is not divisible by 1,024 bytes, it is padded until it is. For images that are meant to be bootable, the address in the upload header should be set to the entry point defined for the specific device. Bootable images have an additional 1,024 byte header at the beginning of the image that is used to verify the image before booting it. The boot image is also padded to the nearest 1,024 bytes. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that is the entry point the bootloader will invoke. 32 bit unsigned length of the boot image rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the boot image bounded by the specified address and length. Bootloader v1 Currently the Embedded Master, EMX, G120, G120E and USBizi ship with this version of the bootloader. All results are terminated with LF (\\n). Commands are executed as soon as they entered without waiting for a new-line. \"BL\" or \"Done.\" will be sent after each command. On startup, a banner is sent that is terminated by \"BL\". Once the banner is received, you are free to enter any of the case-sensitive single-character commands described below. V: returns the current version. E: erases all user sectors of the device (* is sent while erasing). R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. The firmware is automatically run after a successful upload. Tip The USB interface on Version 1.0 doesn't always work on Windows 7 and newer operating systems. Use the serial interface instead. Downloads Here you can find the various bootloaders available for the various products. FEZCLR File Date Status MD5 v2.0.4 2017-08-31 Alpha 33F7FCAE266D07209C079CEA38AAB583 v2.0.3 2017-07-07 Alpha 056919694D6A5F06546F9B721AE141CE UC2550 File Date Status MD5 v2.0.4 2018-04-05 Alpha 692FA78A161BAA2AEF17E9F85A6AF141 UC5550 File Date Status MD5 v2.0.4 2018-04-05 Alpha 594744A52EC07CEFE6212669D33A5FE1 G120 File Date Status MD5 v2.0.4 2017-08-31 Alpha 7052D6FFB1890987DDCC4043895788D3 v2.0.2 2017-03-07 Alpha 00ECD55A24607336863B1D61B91C3D86 G400 File Date Status MD5 v2.0.4 2017-09-13 Alpha BD46D86D41DCD42C4FC50D27AF02E5EE v2.0.2 2017-04-06 Alpha 81D45A8F078AA8E633C824C7BB3279DC v2.0.1 2016-06-27 Alpha 42CD50E4105939611ABF360475EBF4E5 FEZ Hydra File Date Status MD5 v2.0.4 2018-02-01 Alpha 6B8C5DFA5D29F50C6FC3C73ECD2F8ED5 Cerb File Date Status MD5 v2.0.4 2017-08-31 Alpha 934825046A0245756C2F3B4066E7F79F v2.0.3 2017-07-07 Alpha 6505870259AC8E748FD09EBD00796E2E EMX File Date Status MD5 v2.0.4 2017-08-31 Alpha E728AEFF7737E60B05620F9387FAA373 Embedded Master File Date Status MD5 v2.0.4 2017-08-31 Alpha F39BD6BC7F14855A6B5A557DEF26B720 USBizi File Date Status MD5 v2.0.4 2017-08-31 Alpha 97BF3C83B801CDA6119B149CF339BE7A v1.0.7 144 2015-05-05 Production 853557479D8797EAB650B98E3D333DCF v1.0.7 100 2015-05-05 Production 34D17AA5CA4E13D5447C80AB8094D064 USB Drivers Only needed for Windows 7 and 8 since they do not automatically load drivers for the bootloader interface. File Date Status MD5 v0.6.0 x64 2017-08-31 Alpha AEDD7C00854BBF99AC3FDAB4976E1F33 v0.6.0 x86 2017-08-31 Alpha A0F487D32B882199F0A69E6CAA8DE4CB"
  },
  "software/tinyclr/tutorials/dac.html": {
    "href": "software/tinyclr/tutorials/dac.html",
    "title": "DAC",
    "keywords": "DAC An analog output sets the voltage on its pin anywhere between 0 and the supplied voltage (maximum voltage) which is typically 3.3 volts. The output voltage is only a signal, not meant to drive any loads. An op-amp or similar circuits can be added to drive loads, such as a speaker. The analog out on a micro has precision, listed in its documentation. Due to that precision, the actual output values on the pin is an approximation. For example, an DAC with an 8-bit (256 steps) analog out as a step precision of 3.3V/256. This example will generate a triangular waveform. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Dac; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { DacController DAC = DacController.GetDefault(); DacChannel analog = DAC.OpenChannel(G120.DacChannel.P0_26); double d = 0.5; double dd = 0.01; while (true) { analog.WriteValue(d); d += dd; if (d <= 0 || d >= 1) dd *= -1;// inverse Thread.Sleep(10); } } } Tip Do not use analog outputs to control the power of an LED or a motor. Use PWM for that."
  },
  "software/tinyclr/tutorials/display.html": {
    "href": "software/tinyclr/tutorials/display.html",
    "title": "Display",
    "keywords": "Display Displays can be grouped into two distinct interface categories, parallel TFT displays and serial SPI/I2C displays. Parallel TFT Displays These displays connect to special dedicated pins on the processor. Internally the display controller automatically transfers (refreshes) the display directly from memory without any processor interaction. When the system needs to update the display, it simply writes to memory. Neither the operating system nor the application program are burdened with display processing. The down side to this is that the system needs to have enough RAM to handle the display. An 800x600 display with 16bpp needs 960,000 bytes! For systems with external memory this should not be an issue. TinyCLR OS has built in graphics methods for these displays. You will need to add the GHIElectronics.TinyCLR.Drawing NuGet package to your program and using System.Drawing and using GHIElectronics.TinyCLR.Devices.Display to your code. using System.Drawing using GHIElectronics.TinyCLR.Devices.Display var displayController = DisplayController.GetDefault(); // Enter the proper display configurations displayController.ApplySettings(new ParallelDisplayControllerSettings { Width = 480, Height = 272, DataFormat = DisplayDataFormat.Rgb565, PixelClockRate = 20000000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }); // Some needed objects var screen = Graphics.FromHdc(displayController.Hdc); var GreenPen = new Pen(Color.Green); // Start Drawing (to memroy) screen.Clear(Color.Black); screen.DrawEllipse(GreenPen, 40, 30, 20, 10); // Flush the memory to the display. This is a very fast operation. screen.Flush(); Serial SPI/I2C Displays Serial displays can work with all microcontrollers. They use common SPI or I2C busses. These displays have built in memory buffers, freeing resources from the system. However, updating graphics is significantly slower than using Parallel TFT Displays. The system will have to send serial commands to identify the memory region to update and then follow that with the new data. This is why serial interfaces are usually used with smaller displays. To the system, a serial display is nothing but a serial device. You are expected to write your own code to handle graphics. A good example is the Adafruit Display Shield which uses a SPI display. This video features a very low cost I2C display option"
  },
  "hardware/automotive.html": {
    "href": "hardware/automotive.html",
    "title": "CANxtra",
    "keywords": "CANxtra CANxtra is a hand-held programmable OBD-II tool that includes CAN, LIN and other vehicle buses. Resources below are provided for reference only. Please contact us for all of your custom automotive needs. Resources Brochure Schematic"
  },
  "software/tinyclr/tutorials/filesystem.html": {
    "href": "software/tinyclr/tutorials/filesystem.html",
    "title": "Filesystem",
    "keywords": "Filesystem The filesystem library can be used to read and write files from an SD card. The below example requires the GHIElectronics.TinyCLR.IO library and a device with an SD card. using GHIElectronics.TinyCLR.Devices.SdCard; using GHIElectronics.TinyCLR.IO; using System; using System.IO; using System.Text; namespace Filesystem { public class Program { public static void Main() { var sd = SdCardController.GetDefault(); var drive = FileSystem.Mount(sd); var file = new FileStream($@\"{drive.Name}Test.txt\", FileMode.OpenOrCreate); var bytes = Encoding.UTF8.GetBytes(DateTime.UtcNow.ToString() + Environment.NewLine); file.Write(bytes, 0, bytes.Length); file.Flush(); FileSystem.Flush(sd); } } } Low-level Access You can access the raw underlying sectors of an SD card if the provider implements ISdCardLowLevelController , like the one provided by the GHIElectronics.TinyCLR.Devices library. That interface exposes ReadSectors , WriteSectors , EraseSector , and GetSectorMap . Be careful when using this interface, however, as it bypasses any filesystem present and writes directly to the device. This is useful for implementing your own or otherwise not-supported filesystems. var controller = SdCardController.GetDefault(); var lowLevel = (ISdCardLowLevelController)controller.Provider;"
  },
  "hardware/filesystem.html": {
    "href": "hardware/filesystem.html",
    "title": "File System",
    "keywords": "File System Since 2003, GHI Electronics has made several industry-first file system chipsets. F40 Originally called ALFAT. Datasheet ALFAT-SD Schematic ALFAT-OEM Schematic Firmware 1.08 Firmware 2.00 F20 Datasheet Firmware v103 F20-uSD Schematic uALFAT User Manual Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/raspberrypi-hats.html": {
    "href": "hardware/raspberrypi-hats.html",
    "title": "Raspberry Pi Hats",
    "keywords": "Raspberry Pi Hats Several HATs were made for the RPI. The software was focused on the use of Win10. This GitHub repo includes the software for all HATs. FEZ HAT Schematic FEZ ProtoPi Schematic FEZ Utility Schematic FEZ Cream This HAT was part of the Gadgeteering efforts. Schematic Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/breakout/g30-th.html": {
    "href": "hardware/breakout/g30-th.html",
    "title": "G30 TH Module",
    "keywords": "G30 TH Module A through-hole version of G30. Resources Schematic Software For information on programming the G30 TH Module, please go to the G30 page."
  },
  "hardware/duino/fez-cobra-iii.html": {
    "href": "hardware/duino/fez-cobra-iii.html",
    "title": "FEZ Cobra III",
    "keywords": "FEZ Cobra III An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Cerbuino Bee, please go to the G120 page."
  },
  "hardware/duino/fez-panda-iii.html": {
    "href": "hardware/duino/fez-panda-iii.html",
    "title": "FEZ Panda III",
    "keywords": "FEZ Panda III An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Panda II, please go to the G80 page."
  },
  "hardware/fez/bare-metal.html": {
    "href": "hardware/fez/bare-metal.html",
    "title": "Bare Metal",
    "keywords": "Bare Metal Another option is to just start coding everything from scratch. The easiest way would be to start with Mbed online tools and then export your project. With or without Mbed, you can use the free open source GNU GCC tools to build your programs, which are the same tools we use to build the TinyCLR OS firmware. Another option is to use a commercial compiler like Keil compiler/IDE. Keil tools are free for 32 KByte or smaller program size (MDK-Lite). Tip If you are not adding a SWD-JTAG tool, like ST-Link, follow the STM32 bootloader instructions on generating and loading DFU files. Keil Website Keil ARM MDK tools GNU ARM Tools (GCC) Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/gadgeteer/fez-cerberus.html": {
    "href": "hardware/gadgeteer/fez-cerberus.html",
    "title": "FEZ Cerberus",
    "keywords": "FEZ Cerberus FEZ Cerberus is a .NET Gadgeteer product that utilizes .NET Micro Framework (NETMF). The core of the FEZ Cerberus is the G30 System on Chip (SoC). FEZ Cerberus is the mother of the Cerb Family. Resources Schematic Using the Gadgeteer software We discourage the use of Gadgeteer and NETMF software on our products in favor of TinyCLR OS, but the choice is up to you. To find out more about NETMF, go to our NETMF Introduction Page Using TinyCLR OS The following instructions describe how to set up EMX to work with TinyCLR OS. To learn more about TinyCLR check out the TinyCLR Introduction page. The Boot Pins PB10 is the MODE pin, which is used to select between USB and serial interfaces for bootloader and firmware. USART1 (PB6 and PB7) is used when in serial mode. LDR0 and LDR1 are PC1 and PC3 respectively. Setting LDR0 low on power up puts the device into bootloader mode. Setting LDR1 low will execute the firmware but will stop the application from running. Loading Bootloader v2 Download the bootloader file . Press and hold the BOOT button down while resetting the board. If there is no BOOT button, there will be shunt-footprint labeled BOOT or LDR. Short the 2 pads with a wire while resetting the board. The system will now detect an ST DFU device. Read more on uploading DFU files on STM32 microcontrollers. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set PC1 pin low. Download the Cerb firmware and follow Loading the Firmware steps. FEZ Game-O A programmable game console based on the FEZ Cerberus that was funded with a successful kickstarter campaign. The FEZ Game-O combine a 320 x 240 color display, 3D accelerometer and audio circuitry within an attractive, ergonomic enclosure. Schematic"
  },
  "hardware/gadgeteer/fez-raptor.html": {
    "href": "hardware/gadgeteer/fez-raptor.html",
    "title": "FEZ Raptor",
    "keywords": "FEZ Raptor FEZ Raptor is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Raptor is the G400S System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading GHI Bootloader v2 Follow the exact same steps found on the G400 page. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, press and hold the LDR0 button while resetting the board. Download the G400 firmware and follow Loading the Firmware steps."
  },
  "hardware/gadgeteer/intro.html": {
    "href": "hardware/gadgeteer/intro.html",
    "title": ".NET Gadgeteer Intro",
    "keywords": ".NET Gadgeteer Intro .NET Gadgeteer is a discontinued technology that was initiated by Microsoft Research and taken to production by GHI Electronics in the year 2011. .NET Gadgeteer had a great few year run, where it was loved for its plug-and-play mainboard and modules. Tip We will refer to .NET Gadgeteer as Gadgeteer throughout the rest of the documentation. The core of .NET Gadgeteer is .NET Micro Framework (NETMF). Like Gadgeteer, NETMF is no longer evolved by Microsoft and left for the community. Learn more about NETMF Sadly, and after 5 years of building modules and mainboards, GHI Electronics had to announce the EOL for Gadgeteer; however, the Gadgeteer hardware can still be used with TinyCLR OS . External resources: Microsoft's .NET Gadgeteer website (down) http://www.gadgeteer.com/ Microsoft's NETMF website (outdated) http://www.netmf.com/ Most of the Gadgeteer ecosystem is open-source: Microsoft's .NET Gadgeteer Core GHI Electronics' Software sources and Hardware design files The Gadgeteer graphical designer was never made available by Microsoft. Socket Map The magic of Gadgeteer is in its socket map Socket Pin1 Pin2 Pin3 Pin4 Pin5 Pin6 Pin7 Pin8 Pin9 Pin10 A +3.3V +5V AIN (G!) AIN (G) AIN GPIO [UN] [UN] [UN] GND B +3.3V +5V LCD B0 LCD B1 LCD B2 LCD B3 LCD B4 LCD ENABLE LCD CLK GND C +3.3V +5V GPIO! CAN TD (G) CAN RD (G) GPIO [UN] [UN] [UN] GND D +3.3V +5V GPIO! D- D+ GPIO GPIO [UN] [UN] GND E +3.3V +5V [UN] LED1 (OPT) LED2 (OPT) TX D- TX D+ RX D- RX D+ GND F +3.3V +5V GPIO! DAT0 DAT1 CMD DAT2 DAT3 CLK GND G +3.3V +5V LCD G0 LCD G1 LCD G2 LCD G3 LCD G4 LCD G5 LCD BACKLIGHT GND H +3.3V +5V GPIO! D- D+ [UN] [UN] [UN] [UN] GND I +3.3V +5V GPIO! [UN] [UN] GPIO [UN] SDA SCL GND K +3.3V +5V GPIO! TX (G) RX (G) RTS CTS [UN] [UN] GND O +3.3V +5V GPIO! GPIO AOUT [UN] [UN] [UN] [UN] GND P +3.3V +5V GPIO! [UN] [UN] GPIO PWM (G) PWM (G) PWM GND R +3.3V +5V LCD R0 LCD R1 LCD R2 LCD R3 LCD R4 LCD VSYNC LCD HSYNC GND S +3.3V +5V GPIO! GPIO GPIO CS MOSI MISO SCK GND T +3.3V +5V [UN] YU XL YD XR [UN] [UN] GND U +3.3V +5V GPIO! TX (G) RX (G) GPIO [UN] [UN] [UN] GND X +3.3V +5V GPIO! GPIO GPIO [UN] [UN] [UN] [UN] GND Y +3.3V +5V GPIO! GPIO GPIO GPIO GPIO GPIO GPIO GND Z +3.3V +5V [MS] [MS] [MS] [MS] [MS] [MS] [MS] GND * +3.3V +5V GPIO! GPIO GPIO [MS] [MS] [MS] [MS] GND Symbol Description AIN Analog input pin. GPIO A general-purpose digital input/output pin, operating at 3.3 volts. (G) In addition to another functionality, a pin that is also usable as a GPIO. [UN] Modules must not connect to this pin if using this socket type. Mainboards can support multiple socket types on one socket, as long as individual pin functionalities overlap in a compatible manner, so that a pin from one socket type can overlap with a [UN] pin of another. ! Interrupt-capable and software pull-up capable GPIO (the pull-up is switchable and in the range of 10,000 to 100,000 ohms). +3.3V Connection to the +3.3 V power net. +5V Connection to the +5 V power net. GND Connection the power ground net. Using .NET Gadgeteer To use .NET Gadgeteer's legacy software, install: Visual Studio 20013 (community edition is also supported) Unzip and install netmfvs2013.vsix and MicroFramewrokSDK.msi from here Microsoft's Gadgeteer Core GHI Electronics' NETMF SDK . The latest is recommended. The Gadgeteer for Beginners guide is a good starting point. Tip You can only use Visual Studio 2013, not a newer edition, unless you are using your Gadgeteer hardware with TinyCLR OS . With TinyCLR OS All .NET Gadgeteer devices are still useable today, and with the latest technologies, thanks to efforts by GHI Electronics and the community. It all started in this video! This means you can still use all your beloved .NET Gadgeteer gear with TinyCLR OS . The first step needed to use TinyCLR OS is to load the GHI Bootloader v2 onto your mainboard, then use that to load the TinyCLR OS firmware. Each mainboard product page includes the needed instructions. Once those are loaded, you can start blinking the debug LED, detailed in the next section. Blinking the LED Tip If you have never used TinyCLR OS before, start here This example will blink the debug LED. You only need to add a power module to your mainboard. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var led = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.DebugLed); led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(200); led.Write(GpioPinValue.Low); Thread.Sleep(200); } } } Tip The complete pin mapping is made available through GHIElectronics.TinyCLR.Pins . You should not need to use any schematics. Replace FEZSpider with your mainboard's name. Adding Gadgeteer Modules You are now ready to start adding modules ."
  },
  "hardware/gadgeteer/modules.html": {
    "href": "hardware/gadgeteer/modules.html",
    "title": ".NET Gadgeteer Modules",
    "keywords": ".NET Gadgeteer Modules This page lists all .NET Gadgeteer modules and how they can be used with TinyCLR OS . If you are planning on using the old NETMF/Gadgeteer software, which we discourage, then read the .NET Gadgeteer Intro page. Tip You can use Intellisense with the pin definition class to quickly determine where things go. For example: Typing FEZSpider.GpioPin.Socket4. lists the available GPIO pins on socket 4 Another example: Typing FEZSpider.UartPort. lists all available UART sockets (that is \"U\" in the old Gadgeteer standard) Tip We will be using the original, and most popular, FEZ Spider as a base for this page but any other mainboard will work very similarly. Accel G248 The Accel G248 measures acceleration though I2C bus. Use the original Gadgteer driver as a reference. Schematic Barometer Measures pressure. Use the original Gadgteer driver as a reference. Schematic Bluetooth Use the original Gadgteer driver as a reference. Schematic Breadboard X1 An easy breadboard option. Simply access the socket directly to wire whatever your heart desires! Schematic Breakout Simply a breakout of all signals. Schematic Breakout TB10 Simply a breakout of all signals, on a terminal block. Schematic Button The Button module is very simple, with a button connected to pin 3 and an LED connected to pin4. This example will blink the LED at different rates, depending on the button press. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var LED = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket4.Pin4); LED.SetDriveMode(GpioPinDriveMode.Output); var Button = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket4.Pin3); Button.SetDriveMode(GpioPinDriveMode.InputPullUp); var speed = 200; while (true) { if (Button.Read() == GpioPinValue.High) speed = 200;// high = button is not pressed else speed = 500;// low = button is pressed // blink the LED LED.Write(GpioPinValue.High); Thread.Sleep(speed); LED.Write(GpioPinValue.Low); Thread.Sleep(speed); } } } Schematic Button S7 7 buttons on a single module, with LEDs that light up with button presses! Use the same code example provided for the Button Module. Buttons map: Left: Pin Right: Pin 8 Up: Pin 6 Down: Pin 7 Enter: Pin 3 Back: Pin 4 Forward: Pin 9 Schematic CAN DW CAN is not yet supported in TinyCLR OS, you can add it if you are up for a challenge! Schematic Camera USB Host is not supported in TinyCLR OS Schematic Cellular Radio Use the original Gadgteer driver as a reference. Schematic Character Display This is a standard and very common HD44780 display. Use the original Gadgteer driver as a reference. Schematic ColorSense A color sensor that uses software I2C, not yet supported in TinyCLR OS. Use the original Gadgteer driver as a reference. Schematic Compass Use the original Gadgteer driver as a reference. Schematic Current ACS712 This is a current sensor that uses ACS712, which simply outputs an analog voltage. Use the original Gadgteer driver as a reference. Schematic Display CP7 Read more about the display support on TinyCLR OS. The configurations for the display: // these are the wrong values! Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display N18 This is an SPI display that can work on any system with SPI bus, even small ones without TFT display support. See the Display tutorial for more details. Schematic Display N7 Read more about the display support on TinyCLR OS. The configurations for the display: Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display NHVN This allows the use of several displays offered by http://newhavendisplay.com/ Supported displays: NHD-4.3-480272EF-ATXL# NHD-4.3-480272EF-ATXL#-CTP NHD-4.3-480272EF-ATXL#-T NHD-7.0-800480EF-ATXL# NHD-7.0-800480EF-ATXL#-CTP NHD-7.0-800480EF-ATXV# NHD-7.0-800480EF-ATXV#-CTP Read more about the display support on TinyCLR OS. The configurations for all 4.3\" display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, The configurations for all 7\" display: Width = 800, Height = 480, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 88, HorizontalBackPorch = 40, HorizontalSyncPulseWidth = 48, HorizontalSyncPolarity = false, VerticalFrontPorch = 13, VerticalBackPorch = 32, VerticalSyncPulseWidth = 3, VerticalSyncPolarity = false, As for the capacitive touch controller, use this old NETMF driver code as a reference: public class FT5306Controller { private InterruptPort touchInterrupt; private I2CDevice i2cBus; private I2CDevice.I2CTransaction[] transactions; private byte[] addressBuffer; private byte[] touchDataBuffer; private byte[] touchCountBuffer; public delegate void TouchEventHandler(FT5306Controller sender, TouchEventArgs e); public event TouchEventHandler TouchDown; public event TouchEventHandler TouchUp; public event TouchEventHandler TouchMove; public FT5306Controller(Cpu.Pin interruptPin) { this.transactions = new I2CDevice.I2CTransaction[2]; this.addressBuffer = new byte[1]; this.touchDataBuffer = new byte[4]; this.touchCountBuffer = new byte[1]; this.i2cBus = new I2CDevice(new I2CDevice.Configuration(0x38, 400)); this.touchInterrupt = new InterruptPort(interruptPin, false, Port.ResistorMode.Disabled, Port.InterruptMode.InterruptEdgeBoth); this.touchInterrupt.OnInterrupt += (a, b, c) => this.OnTouchEvent(); } private void OnTouchEvent() { var points = this.ReadData(2, this.touchCountBuffer)[0]; for (var i = 0; i < points; i++) { var data = this.ReadData(i * 6 + 3, this.touchDataBuffer); var flag = (data[0] & 0xC0) >> 6; var x = ((data[0] & 0x0F) << 8) | data[1]; var y = ((data[2] & 0x0F) << 8) | data[3]; var handler = flag == 0 ? this.TouchDown : flag == 1 ? this.TouchUp : flag == 2 ? this.TouchMove : null; if (handler != null) handler(this, new TouchEventArgs { X = x, Y = y }); } } private byte[] ReadData(int address, byte[] resultBuffer) { this.addressBuffer[0] = (byte)address; this.transactions[0] = I2CDevice.CreateWriteTransaction(this.addressBuffer); this.transactions[1] = I2CDevice.CreateReadTransaction(resultBuffer); this.i2cBus.Execute(this.transactions, 500); return resultBuffer; } public class TouchEventArgs : EventArgs { public int X { get; internal set; } public int Y { get; internal set; } } } Schematic Display T35 Read more about the display support on TinyCLR OS. The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 27, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 8, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display T43 Read more about the display support on TinyCLR OS. The configurations for the display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display TE35 Read more about the display support on TinyCLR OS. The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 29, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 3, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Distance US3 A very common ultrasonic sensor that works by sending a pulse on the trig Pin4 and measuring the response time on echo Pin3. GpioPulseReaderWriter echolen = new GpioPulseReaderWriter( GpioPulseReaderWriter.Mode.EchoDuration, true, 10, FEZSpider.GpioPin.Socket4.Pin4, true, FEZSpider.GpioPin.Socket4.Pin3); long time = echolen.Read(); Schematic Ethernet ENC28 Requires an internal support in the TinyCLR OS port or a managed TCP/IP stack. Schematic Ethernet J11D Requires an internal support in the TinyCLR OS port or a managed TCP/IP stack. Schematic Extender No drivers are needed. Schematic FEZtive Use the original Gadgteer driver as a reference. Schematic Flash Use the original Gadgteer driver as a reference. Schematic GPS Use the original Gadgteer driver as a reference. Schematic GasSense This module can host several different air sensors, like Alcohol and CO2. The sensor has an internal heater that needs to be enabled and then it is a simple analog read. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var Enable = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket10.Pin4); Enable.SetDriveMode(GpioPinDriveMode.Output); Enable.Write(GpioPinValue.High);// Enable the internal heater var Ain = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin3); while (true) { Debug.WriteLine(\"Ain: \" + Ain.ReadRatio()); Thread.Sleep(500); } } } Schematic Gyro Use the original Gadgteer driver as a reference. Schematic HD44780 See the Character Display Module Schematic HubAP5 No hub support is currently planned. Schematic IO60P16 This module provide 60 IOs and 16 PWM pins. Use the original Gadgteer driver as a reference. Schematic IR Receiver Use the original Gadgteer driver as a reference. Schematic Joystick The Joystick module has two analog inputs for X and Y position. Pressing the knob also works like a button. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var AinX = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin4); var AinY = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin5); var Button = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket10.Pin3); Button.SetDriveMode(GpioPinDriveMode.InputPullUp); while (true) { Debug.WriteLine(\"PosX: \" + AinX.ReadRatio() + \"%\"+ \"PosY: \" + AinY.ReadRatio() + \"%\"); if (Button.Read() == GpioPinValue.Low) Debug.WriteLine(\"Pressed!\"); Thread.Sleep(500); } } } Schematic Keypad KP16 Use the original Gadgteer driver as a reference. Schematic LED 7C An LED that can be set to one of 7 colors, 8 if you count off! using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var GPIO = GpioController.GetDefault(); var Red = GPIO.OpenPin(FEZSpider.GpioPin.Socket8.Pin4); Red.SetDriveMode(GpioPinDriveMode.Output); var Green = GPIO.OpenPin(FEZSpider.GpioPin.Socket8.Pin5); Green.SetDriveMode(GpioPinDriveMode.Output); var Blue = GPIO.OpenPin(FEZSpider.GpioPin.Socket8.Pin3); Blue.SetDriveMode(GpioPinDriveMode.Output); while (true) { // Off Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Red Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Green Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Blue Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.High); Thread.Sleep(500); // White Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.High); Thread.Sleep(500); // Yellow Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Magenta Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.High); Thread.Sleep(500); // Cyan Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.High); Thread.Sleep(500); } } } Schematic LED 7R This is a ring of 6 LEDs and a 7th center LED. Reference the LED 7C module for using pins. Center LED: pin 9 LEDs going clockwise starting from LEDs D1 to D6 on the board D1, D2, D3, D4, D5, D6 are pins 3 to 8 respectively. Schematic LED Strip A strip of 7 LEDs, connected to pins 3 through 9. Reference the LED 7C module for using pins. Schematic Light Sense Simply using analog on pin 3. Use the same code as the potentiometer. Schematic Load Each one of the 7 GPIO pins are connected to a transistor to handle a load, like a motor. Schematic MaxO Shift registers used to take serial SPI data and put on parallel pins, perfect for driving tons of LEDs. This video explains how this works Use the original Gadgteer driver as a reference. Schematic MicroSD Card No file system support yet. Schematic Moisture This is a simple analog input measuring the direct resistance (moisture). An enable pin needs to be activated. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var Enable = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket10.Pin6); Enable.SetDriveMode(GpioPinDriveMode.Output); Enable.Write(GpioPinValue.High);// Enable var Ain = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin3); while (true) { Debug.WriteLine(\"Ain: \" + Ain.ReadRatio()); Thread.Sleep(500); } } } Schematic Motor Driver The Motor Driver Module uses L298 H-bridge that can drive two motors up to 4A. Pin 6: Motor A Direction (GPIO) Pin 7: Motor A Speed (PWM) Pin 8: Motor B Direction (GPIO) Pin 9: Motor B Speed (PWM) Tip NETMF didn't handle PWM correctly. TinyCLR OS breaks PWM pins to individual channels. Read more about PWM . This example will setup both motors and then will make motor A go very slow forward then very fast backward, in a loop. using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { // Determine what PWM controller is used for specific pins, use the power of intellisense! // start typing FEZSpider.PwmPin. to navigate the options // Motor A var MotorDirA = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket8.Pin6); MotorDirA.SetDriveMode(GpioPinDriveMode.Output); var ControllerA = PwmController.FromId(FEZSpider.PwmPin.Controller1.Id); ControllerA.SetDesiredFrequency(5000); var MotorSpeedA = ControllerA.OpenPin(FEZSpider.PwmPin.Controller1.Socket8.Pin7); // Motor B var MotorDirB = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket8.Pin8); MotorDirB.SetDriveMode(GpioPinDriveMode.Output); var ControllerB = PwmController.FromId(FEZSpider.PwmPin.Controller1.Id); ControllerB.SetDesiredFrequency(5000); var MotorSpeedB = ControllerB.OpenPin(FEZSpider.PwmPin.Controller1.Socket8.Pin9); while (true) { MotorDirA.Write(GpioPinValue.High);// Forward MotorSpeedA.SetActiveDutyCyclePercentage(0.1);// slow 10% Thread.Sleep(500); MotorDirA.Write(GpioPinValue.Low);// Backwards MotorSpeedA.SetActiveDutyCyclePercentage(0.9);// fast 90% Thread.Sleep(500); } } } Schematic Multicolor LED A DaisyLink module, we will not support. Schematic Music The Music Module uses the popular VS1053 decoder chip that decodes MP3, WMA, OGG, MIDI and WAV files. Use the original Gadgteer driver as a reference. Schematic Null Modem No driver is needed. OBD II Use the original Gadgteer driver as a reference. OneWire X1 A breakout with a terminal block for easily connecting OneWire devices, specifically the common temperature probes. OneWire is not supported yet. Schematic PIR Motion detection. Simply pin 3 changes its state when it detects motion. Schematic Parallel CNC A DaisyLink module, we will not support. Schematic Potentiometer The Potentiometer module is simply a variable resistor connected to pin3. Rotating its knob will result in an analog value changing from min to max. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var Ain = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin3); while (true) { Debug.WriteLine(\"Pos: \" + Ain.ReadRatio() + \"%\"); Thread.Sleep(500); } } } Schematic Pulse Count Use the original Gadgteer driver as a reference. Schematic Pulse InOut A DaisyLink module, we will not support. Schematic Pulse Oximeter Use the original Gadgteer driver as a reference. Schematic RFID Reader Use the original Gadgteer driver as a reference. Schematic RS232 Simply a serial port. Schematic RS485 Simply a serial port. Schematic Radio FM1 Use the original Gadgteer driver as a reference. Schematic Reflector R3 Use the original Gadgteer driver as a reference. Schematic Relay ISOx16 An array of 16 relays. Operate similar to the MaxO module. Use the original Gadgteer driver as a reference. Schematic Relay X1 Simply set pin 3 high to activate the relay. Schematic Rotary H1 Use the original Gadgteer driver as a reference. Schematic SD Card File system is not supported yet. Schematic S-Plus We will not support hubs. Schematic Serial Camera Use the original Gadgteer driver as a reference. Stepper L6470 Use the original Gadgteer driver as a reference. Schematic TempHumidity Use the original Gadgteer driver as a reference. Schematic Thermocouple Use the original Gadgteer driver as a reference. Schematic Touch C8 Use the original Gadgteer driver as a reference. Schematic Touch L12 Use the original Gadgteer driver as a reference. Schematic Tunes The Tunes Module is a tiny speaker that is connected to pin 9. Use PWM to generate sounds This example will keep changing the frequency. using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var controller = PwmController.FromId(FEZSpider.PwmPin.Controller0.Id); var buzz = controller.OpenPin(FEZSpider.PwmPin.Controller0.Socket11.Pin9); controller.SetDesiredFrequency(500);// change the frequency for sounds buzz.SetActiveDutyCyclePercentage(0.5);// always use this for sounds buzz.Start(); while (true) { controller.SetDesiredFrequency(500); Thread.Sleep(500); controller.SetDesiredFrequency(200); Thread.Sleep(500); } } } Schematic UC Battery 4xAA No driver is needed. Schematic USB Client DP No driver is needed. Schematic USB Client SP No driver is needed. Schematic USB Host USB Host is not currently supported. Schematic USB Serial Simply, a serial port. Schematic USB Serial SP Simply, a serial port. Schematic VideoOut Use the original Gadgteer driver as a reference. Schematic Wi-Fi RN171 Use the original Gadgteer driver as a reference. Schematic Wi-Fi RS21 Will not be supported, NDA issues. Schematic XBee Adapter Simply, a serial port. From there a driver like https://xbee.codeplex.com/ will help. Schematic"
  },
  "hardware/scm/g400s.html": {
    "href": "hardware/scm/g400s.html",
    "title": "G400S",
    "keywords": "G400S The G400S System on Module (SoM) is the surface mount version of the G400D. Originally designed for .NET Micro Framework, it now runs several other platforms including TinyCLR. Datasheet Pricing, purchasing and other information can be found on the G400S Page on our main website. Getting Started Options for programming the G400S include the following: Microsoft's .NET Micro Framework (NETMF) We discourage the use of NETMF software on our products in favor of TinyCLR OS. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. TinyCLR OS TinyCLR is our own operating system and provides a means of programming embedded devices using .NET and Visual Studio. Visual Studio is widely regarded as one of the best (if not the best) integrated development environments available. The free Community version of Visual Studio can be downloaded here: Visual Studio Downloads . For information on setting up TinyCLR to work in Visual Studio please click here: TinyCLR Introduction Loading Bootloader Version 2 Download the G400 bootloader file . Go to the SAMBA section of the Bootloaders Introduction page for instructions on loading the bootloader. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 (pin 101) signal low while resetting the board. Download the G400 firmware and follow Loading the Firmware steps. Specifications Spec Value Processor Atmel AT91SAM9X35 ARM 926 Speed 400 MHz Internal RAM 32 KByte (SRAM) Internal Flash 0 KByte External RAM 128 MByte (DDR2 SDRAM) External Flash 4 MByte (SPI) Dimensions 48.3 x 33.1 x 4.6 mm Peripherals Note: Many peripherals share I/O pins. Not all peripherals will be available to your application. Peripheral Quantity UART 6 (including HS) UART HS 1 I2C 1 SPI 2 CAN 2 SDIO 1 10 Bit ADC 12 PWM 4 GPIO 89 IRQ 89 USB Client 1 USB Host 2 LCD Supported (16bpp) Ethernet PHY Supported Wi-Fi Not supported DCMI Not supported VBAT Supported JTAG Full JTAG G400S Based Product The G400S is used in the FEZ Raptor TinyCLR lets you program our devices (and others) in C# or Visual Basic using Microsoft's Visual Studio -- and it's all free! Learn more... . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/scm/g80.html": {
    "href": "hardware/scm/g80.html",
    "title": "G80",
    "keywords": "G80 The G80 System on Chip (SoC) is a low-cost chipset running .NET Micro Framework. It is programmed using Microsoft's Visual Studio in C# or Visual Basic which lets developers enjoy a world class development environment with modern event-driven programming languages. Datasheet Pricing, purchasing and other information can be found on the G80 Page on our main website. Getting Started Options for programming the G80 include the following: Microsoft's .NET Micro Framework (NETMF) We discourage the use of NETMF software on our products in favor of TinyCLR OS. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. TinyCLR OS TinyCLR provides a way to program the G80 in C# or Visual Basic using Microsoft Visual Studio. To get started you must first install the firmware on the G80 (instructions below) and then go to the TinyCLR Getting Started page for instructions on setting up the host computer and writing and deploying programs. Loading Bootloader v2 The G80 SoC ships with the Bootloader loaded and locked. No further steps are necessary. Loading the Firmware To activate bootloader v2, the LDR0 input needs to be low while resetting the device. Download the G80 firmware and follow Loading the Firmware steps. G80 Based products G80 Development Board The development system used for evaluating the EMX SoM. Schematics TinyCLR you program our devices (and others) in C# or Visual Basic using Microsoft's Visual Studio -- and it's all free! Learn more... . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/ucm/intro.html": {
    "href": "hardware/ucm/intro.html",
    "title": "Universal Compute Modules",
    "keywords": "Universal Compute Modules Universal Compute Modules are based on a 200 pin SO-DIMM form factor. All models follow a standard pin out making it easy to change modules to fit the needs of your product. A variety of tools and software options are available. Check the individual product documentation for details. The UCM Standard Description, peripherals and pinouts of the standard. Learn more... UC2550 ARM Cortex-M4 based UCM with optional Wi-Fi. Learn more... UC5500 ARM Cortex-M7 based UCM with optional Wi-Fi. Learn more... G400D Based on a 400 MHz Atmel ARM 926. Learn more... UCM Development Options Development boards, breakout boards, displays. Learn more... Learn more about The UCM Standard and check out the UCM Development Options to quickly prototype your project. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/ucm/standard.html": {
    "href": "hardware/ucm/standard.html",
    "title": "The UCM Standard",
    "keywords": "The UCM Standard The UCM Standard defines a consistent hardware and software interface for the most widely used microcontroller peripherals. Universal Compute Modules are based on the 200 pin SO-DIMM form factor. They adhere to a standard pinout across models making it easy to change modules to adapt to the needs of your product. UCM Standard Peripherals* Peripheral Up to Max UART (Universal Asynchronous Receiver/Transmitter) 4 UART HS (Handshaking) 2 I2C (Inter-Integrated Circuit) 2 SPI (Serial Peripheral Interface) 2 CAN (Controller Area Network) 2 SDIO (SD Card) 1 ADC (Analog to Digital Converter) 8 PWM (Pulse Width Modulation) 8 GPIO (General Purpose Input/Output) 12 IRQ (Interrupt Request Capable GPIO) 4 USB Client 1 USB Host 1 LCD (TFT Controller - 16bpp or 24bpp) 1 Ethernet PHY (Ethernet Physical Layer) 1 DCMI (Digital Camera Interface) 1 VBAT (Battery Backup for RTC) 1 JTAG (Debug Serial Port) 1 * Available peripherals vary by model. UART (Universal Asynchronous Receiver/Transmitter) UART is used to implement moderate speed full duplex asynchronous serial communication. It is usually used for peer to peer communication between only two devices. It can transfer data using only one wire for each direction if both devices share a common ground. Sample TinyCLR code UART HS (Handshaking) UART with handshaking is a configuration which allows the host and client to negotiate data transfer via Ready to Send (RTS) and Clear to Send (CTS) signals (two additional wires) to prevent missed data. I2C (Inter-Integrated Circuit) I2C is a multi-master, multi-slave, packet switched, half duplex serial communication bus typically used for attaching peripheral ICs to processors and microcontrollers in short-distance, intra-board communication. It uses two wires and has a slower maximum speed than SPI. Sample TinyCLR code SPI (Serial Peripheral Interface) SPI is a synchronous serial communication interface used for short distance communication. It uses a master-slave protocol. When using TinyCLR, the processor running TinyCLR is always configured as the master. SPI needs at least three wires and usually needs an additional line (chip select) for each slave. It can communicate much faster than either UART or I2C. Sample TinyCLR code CAN (Controller Area Network) A robust bus standard that originated in the automotive field and works very well in high noise environments. It allows microcontrollers and devices to communicate with each other in applications without a host computer. It is a message-based multi-master protocol and generally uses only two wires. Speed is up to one megabit per second but limited by bus length. Sample TinyCLR code SDIO (SD Card) SDIO (Secure Digital Input Output) is an interface used for reading from and writing to SD cards. ADC (Analog to Digital Converter) ADCs are used to measure an analog voltage level by converting it to a digital value. Sample TinyCLR code PWM (Pulse Width Modulation) PWM is a method of generating a square wave signal of uniform frequency with variable duty cycle. PWM is often used to generate analog voltages, but has many other uses such as generating digital pulses for driving servo motors or driving infrared LEDs for communication. Sample TinyCLR code GPIO (General Purpose Input/Output) GPIOs are the digital I/O pins that allow the user to interface with basic devices such as buttons (input) or LEDs (output). GPIOs are very versatile and can also be used to perform more advanced communication and control duties. Sample TinyCLR code IRQ (Interrupt Request Capable GPIO) IRQ capable GPIO pins can be programmed to interrupt a program when the input to the pin changes. For example, an IRQ could be used by a Wi-Fi module to tell the processor that the Wi-Fi module is receiving data. The processor would then stop what it is doing to get the data from the Wi-Fi module. Sample TinyCLR code USB Client Used to communicate with a USB host. Often used to program and debug embedded devices. USB Host Used to communicate with one or more USB clients. Typically used to communicate with various devices such as a mouse, keyboard, camera, etc. LCD (TFT Controller - 16bpp or 24bpp) An interface providing communication with a TFT LCD (thin-film-transistor liquid-crystal display). The number of data lines connected determines the number of bits per pixel (bpp), which determines the number of colors that can be displayed. Sample TinyCLR code Ethernet PHY Ethernet PHY is the Ethernet physical (hardware) layer. It provides the Tx and Rx signals for the Ethernet connector. DCMI (Digital Camera Interface) A standard interface for compatable digital cameras. VBAT (Battery Backup for RTC) VBAT is used to provide battery voltage to a microcontroller's real time clock. It allows the microcontroller to keep the correct time when the main power to the controller is disconnected (the device is turned off). JTAG JTAG is a serial interface which allows communication between the processor and a host computer. It is built into the microcontroller and provides a means of software debugging including the ability to stop program execution, single step through program instructions, and read and write to memory and processor registers. UCM Standard Pin Assignments SO-DIMM Pin Universal Compute Standard 1 AGND 2 Ethernet TX- 3 Module Specific 1 4 Ethernet TX+ 5 Analog VREF- 6 Ethernet RX- 7 Reserved 8 Ethernet RX+ 9 Reserved 10 Indicator A 11 Indicator B 12 Reserved 13 GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND 28 PWM E 29 PWM F 30 PWM G 31 PWM H 32 Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 36 Module Specific 5 37 Module Specific 6 38 Module Specific 7 39 Module Specific 8 40 GND 41 GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND 52 Module Specific 9 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A 58 IRQ B 59 IRQ C 60 3.3V 61 IRQ D 62 GPIO A 63 GPIO B 64 GPIO C 65 GND 66 GPIO D 67 GPIO E 68 GPIO F 69 GPIO G 70 5V 71 Reserved 72 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX 76 UART C RX 77 UART D TX 78 UART D RX 79 GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 89 UART B TX 90 UART B RX 91 ADC A 92 GPIO H 93 SPI B MISO 94 SPI B MOSI 95 GND 96 SPI B SCK 97 ADC B 98 CAN A TD 99 CAN A RD 100 CAN B TD 101 CAN B RD 102 UART HS A TX 103 UART HS A RX 104 ADC C 105 PWM A 106 3.3V 107 System A 108 Module Specific 2 109 Module Specific 3 110 ADC D 111 System C 112 PWM B 113 GND 114 ADC E 115 I2C A SDA 116 I2C A SCL 117 UART A RX 118 UART A TX 119 GPIO I 120 UART HS A RTS 121 UART HS A CTS 122 GPIO J 123 SD Card D0 124 3.3V 125 SD Card CMD 126 SD Card CLK 127 SD Card D1 128 SD Card D2 129 SD Card D3 130 PWM C 131 GND 132 GPIO K 133 PWM D 134 System B 135 System D 136 GPIO L 137 Module Specific 10 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX 141 UART HS B RX 142 3.3V 143 LCD VSYNC 144 LCD HSYNC 145 LCD CLK 146 LCD DE 147 Module Specific 11 148 SD Card CD 149 Module Specific 12 150 Reserved 151 GND 152 LCD B3 153 LCD B4 154 LCD B5 155 LCD B6 156 LCD B7 157 ADC F 158 ADC G 159 ADC H 160 3.3V 161 LCD G2 162 LCD G3 163 LCD G4 164 LCD G5 165 LCD G6 166 Module Specific 13 167 Indicator C 168 LCD R7 169 GND 170 LCD G7 171 LCD R3 172 LCD R4 173 LCD R5 174 LCD R6 175 SPI A SCK 176 SPI A MISO 177 Module Specific 14 178 SPI A MOSI 179 Module Specific 15 180 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT 184 Module Specific 18 185 GND 186 GND 187 RESET 188 USB Host D+ 189 JTAG RTCK 190 USB Host D- 191 JTAG TDO 192 3.3V 193 JTAG NTRST 194 USB Device D+ 195 JTAG TDI 196 USB Device D- 197 JTAG TCK (SWCLK) 198 GND 199 JTAG TMS (SWDIO) 200 Indicator D Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/netmf/getting-started.html": {
    "href": "software/netmf/getting-started.html",
    "title": ".NET Micro Framework Getting Started",
    "keywords": ".NET Micro Framework Getting Started Installation Steps Install Visual Studio Community Edition Download and install Microsoft's Visual Studio 2013 Community Edition . Install Microsoft .NET Micro Framework Uninstall any currently installed NETMF SDKs. Download Microsoft .NET Micro Framework 4.3 (QFE2) and unzip the file. Open the file's folder and install MicroFrameworkSDK.MSI and netmfvs2013.vsix . Install Microsoft .NET Gadgeteer Core (for Gadgeteer users only) Download and install Microsoft .NET Gadgeteer Core . For more information on the future of Gadgeteer, please see this news post . Install GHI Electronic's NETMF SDK Download and install GHI Electronics NETMF SDK 2016 R1 from our NETMF Downloads page. When installing newer GHI NETMF SDKs, click the Advanced button on the opening dialog box and uncheck the boxes to install the FEZ CERB Family and G400/FEZ Hydra loader updaters (the first two options). If needed, these loaders can be installed separately as highlighted in the individual product pages. Older GHI NETMF SDKs are also available on the NETMF Downloads page. Get Started with .NET Micro Framework for Beginners To help you get started we have a free e-book in .pdf format: .NET Micro Framework for Beginners The Emulator The NETMF SDK includes an emulator for running NETMF applications on the PC. For the first part of this project, the emulator will be used to run a very simple application; afterwards the same program is run on NETMF hardware. Create a New Project Open Visual Studio, select File > New Project . There should be a Micro Framework option in the left menu. Click on it and then select Console Application in the center panel. Note The pictures used in this tutorial may vary slightly with different versions of the development platform. Click the OK button to create a new project. The project has only one C# file, called Program.cs . C# source files are listed in the Solution Explorer window. If the Solution Explorer is not open, use the View > Solution Explorer menu to open it. Double click on Program.cs to open the file in the editor. using System; using Microsoft.SPOT; namespace MFConsoleApplication1 { public class Program { public static void Main() { Debug.Print( Resources.GetString(Resources.StringResources.String1)); } } } For simplicity change the code to match the listing below: Tip All example code should be copied directly from this page and pasted into the Visual Studio program editor. using Microsoft.SPOT; public class Program { public static void Main() { Debug.Print(\"Amazing!\"); } } Selecting Transport When compiling a NETMF Console Project, there are options in Video Studio that control where the program is loaded and run. Select the menu item for the project's properties: In the Properties window, on the left side tabs, select .NET Micro Framework and make sure that Transport: is set to Emulator. Console applications have their Debug.Print statements appear in Visual Studio's Output Window. The application in this example uses print statements. If the Output window is not visible, open it by selecting Output in the View menu. Executing Press F5 and Visual Studio will compile the program, load it into the emulator and run it. The emulator displays a hypothetical NETMF device, complete with buttons and a screen. Do not close it. After a few seconds, the program will stop and the Output window will have \"Amazing!\" printed (surrounded by other application information). Introduction to Debugging The following sections are a quick introduction to the power and ease of debugging NETMF applications. Start running the program by pressing F11 (instead of F5 ), this will \"step\" into the application instead of just running it. After deployment, the program starts to run and stops at the very first line of the code. This is indicated by the yellow arrow. Press F11 to step to the \"Debug.Print\" statement. Finally, after pressing F11 one more time, \"Amazing!\" is printed in the Output window. Press F5 to let the program run to completion. Breakpoints Setting breakpoints is simple! -- Click in the bar to the left of the line that prints \"Amazing!\" A red dot appears to mark the breakpoint location. Press F5 to run the software. When the application reaches the breakpoint the debugger will pause: F11 can be used to single step execution line by line. F5 can be used to let the program run. Running on Hardware Deploying and running NETMF applications on hardware is very simple. Just connect the hardware, change an option in Visual Studio, and all loading, running, debugging, etc. are done on the device. The complete procedure is described below. Warning When working with hardware, take care not to expose the hardware to static electricity as it can damage the device. Connect and Power-up Connect the NETMF hardware to the PC using a USB cable. This is done one of two ways. If the processor has an integral USB port and is colored red, plug a USB cable from the computer directly to the board. Processors without an integral USB port will use a Gadgeteer socket to connect the power/USB module to the board. For these boards connect the power module to a \"D\" labeled socket on the board, then connect the power/USB module to the computer. (These circuit boards are black). The first time a processor is connected to the computer, Windows will need to load a driver. Wait until the driver is fully loaded before proceeding. Updating Device Software Before using a NETMF device, the embedded software must match the version of the SDK being used. Instructions for updating the embedded software are found on the Firmware Update page. If necessary, update your firmware, and then return here to continue the tutorial. Skipping the above step is the most common problem faced by beginners . Tip Many USB hubs are poorly implemented in PCs. If Windows failed to recognize the NETMF device or had any connection problems, make sure the device is connected directly to the PC, not through a USB hub. If problems persist, try using a power transformer or powered USB hub to guarantee the device is getting sufficient power (see also the USB sections in NETMF Troubleshooting ). Deploying to Hardware Once the board is connected, Visual Studio has a control to switch back and forth between the emulator and connected hardware. From the project properties, select USB for transport.. Make sure the setup looks similar to the image below: Pressing F5 sends the simple application to the hardware and runs it. Debugging works exactly the same as described above. Next Steps We are currently updating the NETMF documentation found in our NETMF Tutorials . We also have extensive NETMF documentation on our old website which can be viewed here ."
  },
  "software/netmf/intro.html": {
    "href": "software/netmf/intro.html",
    "title": ".NET Micro Framework Introduction",
    "keywords": ".NET Micro Framework Introduction .NET Micro Framework (NETMF) is a subset of the full Microsoft .NET Framework used to make Windows applications. NETMF was started by Microsoft for use in SPOT watches and then later open sourced. The latest version of Visual Studio working with our NETMF products is VS2013. General Resources .NET Micro Framework for Beginners Source code to mainboards and module drivers. The .NET Micro Framework Discussion Forum is monitored by our engineers and active community members. Getting Started Deploy your first NETMF program. Learn more... Tutorials Learn NETMF embedded programming. Learn more... Downloads Visual Studio and device downloads. Learn more... Tip We discourage the use of NETMF on our products in favor of TinyCLR OS . Learn more about using NETMF devices with TinyCLR OS ."
  },
  "software/netmf/tutorials/digital-outputs.html": {
    "href": "software/netmf/tutorials/digital-outputs.html",
    "title": "Digital Outputs",
    "keywords": "Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered off of 3.3 V, then the state high means that there is 3.3 V on the output pin. It is not going to be exactly 3.3 V but very close. When the pin is set to low then it is voltage is very close to zero volts. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. The digital pins on micro-controllers are very weak. They can not be used to drive devices that require a lot of power. Tip All the examples shown below require the Microsoft.SPOT.Hardware assembly. Consult the device schematics or manual for specific pin numbers. Light Up an LED This example turns a LED on. The initial state of the pin (true or false) must be specified when creating the OutputPort. This example makes the pin true which will cause the LED to be on by default. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); Thread.Sleep(Timeout.Infinite); } } Blink an LED To blink an LED, the pin is toggled between high and low. Due to the high speed of the microcontroller (it can flash the LED millions of times per second) a delay needs to be added between ON and OFF to see the blinking. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); while (true) { LED.Write(!LED.Read()); Thread.Sleep(200); } } }"
  },
  "software/netmf/tutorials/display-nhvn-developers-guide.html": {
    "href": "software/netmf/tutorials/display-nhvn-developers-guide.html",
    "title": "Display NHVN Developers' Guide",
    "keywords": "Display NHVN Developers' Guide While the Display NHVN is legacy and will be discontinued, it is available for the time being until a suitable replacement is available for NETMF devices. The Display NHVN is a display module that allows users to connect select Newhaven displays to their mainboard. It includes Gadgeteer sockets for connecting to Gadgeteer mainboards and a 40 pin 0.1\" spaced through-hole header for connecting to boards that have a compatible header. The following displays are supported: NHD-4.3-480272EF-ATXL# NHD-4.3-480272EF-ATXL#-CTP NHD-4.3-480272EF-ATXL#-T NHD-7.0-800480EF-ATXL# NHD-7.0-800480EF-ATXL#-CTP NHD-7.0-800480EF-ATXV# NHD-7.0-800480EF-ATXV#-CTP Currently you can connect the Display NHVN to the 40 pin header on the following products: FEZ Cobra III G120 TH G400 TH OSD3358 TH Make sure to provide adequate separation from the back of the display and the through-hole headers after soldering. A piece of thick tape covering the headers should be enough. The below video talks about one of the ways you can connect this display to our products. If you are using .NET Gadgeteer, you can tell the Gadgeteer driver for the Display NHVN which screen size and touch controller you are using and it will automatically configure it for you like every other Gadgeteer display. If you are not using .NET Gadgeteer, example code for setting the display timings for the two supported screen sizes is listed below. You can also set these timings using FEZ Config. The graphics document has more information on configuring the display. There is also a sample capacitive touch controller below. The interrupt pin is pin 36 on the 40 pin header. If you are using resistive touch, see the touch document for more information. 4.3\" Display Display.Width = 480; Display.Height = 272; Display.OutputEnableIsFixed = false; Display.OutputEnablePolarity = true; Display.PixelPolarity = false; Display.PixelClockRateKHz = 20000; Display.HorizontalSyncPolarity = false; Display.HorizontalSyncPulseWidth = 41; Display.HorizontalBackPorch = 2; Display.HorizontalFrontPorch = 2; Display.VerticalSyncPolarity = false; Display.VerticalSyncPulseWidth = 10; Display.VerticalBackPorch = 2; Display.VerticalFrontPorch = 2; Display.Type = Display.DisplayType.Lcd; Display.CurrentRotation = Display.Rotation.Normal; if (Display.Save()) PowerState.RebootDevice(false); 7\" Display Display.Width = 800; Display.Height = 480; Display.OutputEnableIsFixed = false; Display.OutputEnablePolarity = true; Display.PixelPolarity = false; Display.PixelClockRateKHz = 20000; Display.HorizontalSyncPolarity = false; Display.HorizontalSyncPulseWidth = 48; Display.HorizontalBackPorch = 88; Display.HorizontalFrontPorch = 40; Display.VerticalSyncPolarity = false; Display.VerticalSyncPulseWidth = 3; Display.VerticalBackPorch = 32; Display.VerticalFrontPorch = 13; Display.Type = Display.DisplayType.Lcd; Display.CurrentRotation = Display.Rotation.Normal; if (Display.Save()) PowerState.RebootDevice(false); Capacitive Touch Controller Driver Note The displays do not seem to raise the TouchUp event in our tests. public class FT5306Controller { private InterruptPort touchInterrupt; private I2CDevice i2cBus; private I2CDevice.I2CTransaction[] transactions; private byte[] addressBuffer; private byte[] touchDataBuffer; private byte[] touchCountBuffer; public delegate void TouchEventHandler(FT5306Controller sender, TouchEventArgs e); public event TouchEventHandler TouchDown; public event TouchEventHandler TouchUp; public event TouchEventHandler TouchMove; public FT5306Controller(Cpu.Pin interruptPin) { this.transactions = new I2CDevice.I2CTransaction[2]; this.addressBuffer = new byte[1]; this.touchDataBuffer = new byte[4]; this.touchCountBuffer = new byte[1]; this.i2cBus = new I2CDevice(new I2CDevice.Configuration(0x38, 400)); this.touchInterrupt = new InterruptPort(interruptPin, false, Port.ResistorMode.Disabled, Port.InterruptMode.InterruptEdgeBoth); this.touchInterrupt.OnInterrupt += (a, b, c) => this.OnTouchEvent(); } private void OnTouchEvent() { var points = this.ReadData(2, this.touchCountBuffer)[0]; for (var i = 0; i < points; i++) { var data = this.ReadData(i * 6 + 3, this.touchDataBuffer); var flag = (data[0] & 0xC0) >> 6; var x = ((data[0] & 0x0F) << 8) | data[1]; var y = ((data[2] & 0x0F) << 8) | data[3]; var handler = flag == 0 ? this.TouchDown : flag == 1 ? this.TouchUp : flag == 2 ? this.TouchMove : null; if (handler != null) handler(this, new TouchEventArgs { X = x, Y = y }); } } private byte[] ReadData(int address, byte[] resultBuffer) { this.addressBuffer[0] = (byte)address; this.transactions[0] = I2CDevice.CreateWriteTransaction(this.addressBuffer); this.transactions[1] = I2CDevice.CreateReadTransaction(resultBuffer); this.i2cBus.Execute(this.transactions, 500); return resultBuffer; } public class TouchEventArgs : EventArgs { public int X { get; internal set; } public int Y { get; internal set; } } }"
  },
  "software/netmf/tutorials/i2c.html": {
    "href": "software/netmf/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips to allow multiple chipsets to communicate on a 2-wire bus in home consumer devices. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves using a digital pin like SPI (consuming an additional I/O pin), I2C uses an addressing mechanism to communicate to the selected device. Before data is transferred, the master sends out a 7-bit address address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the device or receive data from the device. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start\" condition before it sends any address or data and then end it with \"stop\" condition. The I2C uses two wires to communicate between the I2C Master and the I2C device. These two wires are known as the SDA and SCL lines. SDA stands for Serial Data, and SCL is Serial Clock. The I2C NETMF driver is based on transactions. If we want to read from a register on a sensor, we would first need to send it the register number we wish to read from, and then we need to read the register. Those are two transactions; a write followed by a read. Addressing One very important point about I2C is that I2C devices have a 7-bit address, but 8-bits are sent on the wire in the \"control byte\" when communicating with the I2C bus. The 8th bit tells the device whether the operation will be a read operation (the 8th bit is a 1) or a write operation (the 8th bit is a 0). When discussing I2C you should always make sure you are clear about the 7-bit address that your device uses, rather than stating your 8-bit read or write address. Software I2C When using I2C, it is highly recommended that you use the built-in hardware support for I2C. In some cases though it may be necessary to have another I2C bus or it is necessary to use specific pins that are not I2C pins. In this case, I2C can be handled completely in software, though performance will be lower. The GHI libraries include a software I2C implementation in the GHI.Hardware assembly (GHI.IO.SoftwareI2CBus). An I2C Example This example will read the value of the register on an I2C device with the 7-bit address of 0x38. As discussed above, you first have to write the register number you want to read, two in this case, and then read the value back. using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //create I2C object //note that the netmf i2cdevice configuration requires a 7-bit address! It set the 8th R/W bit automatically. I2CDevice.Configuration con = new I2CDevice.Configuration(0x38, 400); I2CDevice MyI2C = new I2CDevice(con); // Create transactions // We need 2 in this example, we are reading from the device // First transaction is writing the \"read command\" // Second transaction is reading the data I2CDevice.I2CTransaction[] xActions = new I2CDevice.I2CTransaction[2]; // create write buffer (we need one byte) byte[] RegisterNum = new byte[1] { 2 }; xActions[0] = I2CDevice.CreateWriteTransaction(RegisterNum); // create read buffer to read the register byte[] RegisterValue = new byte[1]; xActions[1] = I2CDevice.CreateReadTransaction(RegisterValue); // Now we access the I2C bus using a timeout of one second // if the execute command returns zero, the transaction failed (this // is a good check to make sure that you are communicating with the device correctly // and don�t have a wiring issue or other problem with the I2C device) if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } } } Multiple Devices The I2C object on NETMF is a representation of the \"bus\" and not the \"device\" so you can't construct multiple I2C objects. To access multiple I2C devices you need to have multiple configurations and then when accessing device \"A\" we need to use configuration \"A\" and when accessing device \"B\" we need to use configuration \"B\". using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //create I2C Device object representing both devices on our bus I2CDevice.Configuration conDeviceA = new I2CDevice.Configuration(0x38, 400); I2CDevice.Configuration conDeviceB = new I2CDevice.Configuration(0x48, 400); //create I2C Bus object using one of the devices on the bus I2CDevice MyI2C = new I2CDevice(conDeviceA); // Note you could have chosen to create the bus using the conDeviceB parameter, which ever you choose it will be the \"selected\" device on the bus to start with. Here's how you would do that: // I2CDevice MyI2C = new I2CDevice(conDeviceB); //create transactions (we need 2 in this example) I2CDevice.I2CTransaction[] xActions = new I2CDevice.I2CTransaction[2]; // create write buffer (we need one byte) byte[] RegisterNum = new byte[1] { 2 }; xActions[0] = I2CDevice.CreateWriteTransaction(RegisterNum); // create read buffer to read the register byte[] RegisterValue = new byte[1]; xActions[1] = I2CDevice.CreateReadTransaction(RegisterValue); // Explicitly set the I2C bus to access device A by setting the I2C Config to the Device A's config. MyI2C.Config = conDeviceA; if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } // Explicitly set the I2C bus to access device B by setting the I2C Config to the Device B's config. MyI2C.Config = conDeviceB; if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } } }"
  },
  "software/netmf/tutorials/in-field-update.html": {
    "href": "software/netmf/tutorials/in-field-update.html",
    "title": "In-Field Update",
    "keywords": "In-Field Update One of GHI Electronics's additions to NETMF includes the In-Field Update (IFU) class allowing devices to be updated in the field. Updates can be obtained over the network or via USB memory, an SD card, or even through a serial port. File encryption and integrity checking can be implemented if desired. Once the data is available, it is passed on to IFU and then stored internally in RAM. Once all of the data is received and loaded by the developer, a single call will wipe the flash and write the new files. Only the regions that are being updated are erased. Warning The final stage will erase the flash and write the new data. This can take some time depending on the board. Losing power during this process will cause the update to fail and require the device to be updated manually. Extracting an Existing Application Creating a hex file to flash to your deployed board is easy. For example, if you have a board in the field (mall kiosk, traffic signal, etc) that is difficult to access, just deploy the new version of your program to another board of the same type. Then open MFDeploy, select USB, and select Target > Application Deployment > Create Application Deployment as shown below. Tip If you would like the next version of your application to have the same update ability, be sure to include the update code in it as well. Now select the name of the file that you would like to use and where to save it. Once this is done, you can place this file on an SD card and insert it into your device, or you can send it to you device over a network. The next section will demonstrate how to load the files and perform the update. Getting Started The following example shows you how to load data into IFU and then flash the device. It requires the GHI.Hardware assembly and assumes that you have already mounted an SD card. Since firmware files can large and often cannot be held in entirely in memory we only load portions of the file at a time. using GHI.Processor; using System.IO; public class Program { public const int BLOCK_SIZE = 65536; public static void FlashFirmware() { // Reserve the memory needed to buffer the update. // A lot of RAM is needed so it is recommended to do this at the program start. InFieldUpdate.Initialize(InFieldUpdate.Types.Firmware | InFieldUpdate.Types.Configuration); // Start loading the new firmware on the RAM reserved in last step. // Nothing is written to FLASH in this stage. Power loss and failures are okay. // Simply abort this stage any way you like! // Files can come from storage, from network, from serial bus or any other way. LoadFile(\"\\\\SD\\\\Config.hex\", InFieldUpdate.Types.Configuration); LoadFile(\"\\\\SD\\\\Firmware.hex\", InFieldUpdate.Types.Firmware); LoadFile(\"\\\\SD\\\\Firmware2.hex\", InFieldUpdate.Types.Firmware); //Only if your device has two firmware files. // This method will copy The new firmware from RAM to FLASH. // This function will not return but will reset the system when done. // Power loss before this function resets the system will result in corrupted firmware. // A manual update will be needed if this method fails (due to power loss for example). InFieldUpdate.FlashAndReset(); } public static void LoadFile(string filename, InFieldUpdate.Types type) { using (var stream = new FileStream(filename, FileMode.Open)) { var data = new byte[BLOCK_SIZE]; for (int i = 0; i < stream.Length / BLOCK_SIZE; i++) { stream.Read(data, 0, BLOCK_SIZE); InFieldUpdate.Load(type, data, BLOCK_SIZE); } stream.Read(data, 0, (int)stream.Length % BLOCK_SIZE); InFieldUpdate.Load(type, data, (int)stream.Length % BLOCK_SIZE); } } }"
  },
  "software/tinyclr/roadmap.html": {
    "href": "software/tinyclr/roadmap.html",
    "title": "Roadmap",
    "keywords": "Roadmap Below is an outline of our goals for a stable and production-ready 1.0 release of TinyCLR OS. Of course, this is subject to change and does not include many smaller improvements and features. With the latest alpha release, TinyCLR has all of the major features we plan to include in the final 1.0 release. Now we are focusing on bugs fixes and final polish. We plan to have a first preview release candidate in early August and a second to follow later that month. If everything goes well, we are aiming for the final release in September. While we will continue to support and fix bugs in 1.0, we're not done there! High on our list for 2.0 are several important features like improved networking, in field update, even easier interops, and USB host and client. We hope to get as many of these out as soon as we can, in preview form at least. More details will follow after 1.0. Longer term we do plan to investigate support for generics and, once we have that, alignment with .NET Standard. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/supported-devices.html": {
    "href": "software/tinyclr/supported-devices.html",
    "title": "Supported Devices",
    "keywords": "Supported Devices TinyCLR OS can be ported to almost any device running an ARM processor, but it is also already ported to many devices. Available options fall under three different tiers: official reference, commercially supported, and community supported. Official Reference The port for FEZ is the official reference port for TinyCLR OS. We recommend using it as a starting point to learn how to build and modify TinyCLR OS. Grab one of the ultra-low-cost FEZ boards and start porting today. Tip BrainPad uses the same port as FEZ. The reference port includes these libraries: Memory Management Threading Events Digital Input Digital Output Interrupts PWM ADC DAC UART SPI I2C GPIO Change Writer GPIO Change Reader GPIO Pulse Reader Writer Keep in mind that while the above features are available not every device will support every feature because the processor itself may not support it or resources are not available. Commercially Supported We also provide a pre-compiled firmware for our Cortex-M SCM and UCM modules. This is a commercially supported TinyCLR OS firmware that includes additional features suited for commercial designs -- features only found in the pre-compiled firmware you receive from us. We understand that commercial customers want things to just work and so we handle all testing and validation of the provided firmware. It is possible to extend this firmware with additional native functionality using native interops loaded at runtime. The firmware for these devices include all features found in the official reference port, plus the following additional commercial features: UC5550 UC2550 G120 G400 G80 G30 File System Y Y Y Y Y D Graphics Y Y Y Y N N USB Client F F F F F N USB Host F F F F F N IFU F F F F F N Y = Supported N = Not Supported D = In Development F = Future Plan The above list is subject to change and is not a guarantee. Community Supported The community supported ports are the joint effort of the community and GHI Electronics to bring TinyCLR OS to many popular products. While these ports may be incomplete or broken, we encourage you to try them and contribute. These ports also include some of the discontinued GHI Electronics products, like the Cerb family and the FEZ Hydra. Take a look at the devices on our GitHub to see what's available!"
  },
  "software/tinyclr/tutorials/spi.html": {
    "href": "software/tinyclr/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three, sometimes four, wires for transferring data. The bus on SPI consists of a single master and one or more slaves. The master will send clock to the slaves over the SCK pin. It will also send date over MOSI pin, while reading incoming data on the MISO pin. The SCK clock is used to determine how fast the data is moved. If you know electronics, this is simply a shift register. The master selects which slave it will swap the data with using the SSEL pin, sometimes called CS. In its simplest terms, the master will swap data between itself and the slave. You cannot write data without reading at the same time. However, a lot of time you need to write data and you do not care about the incoming data. For that, there is a Write method. But keep in mind that the Write method is also reading, and discarding, whatever the slave is sending. Tip Some SPI devices (slaves) can have more than one select-pin, like the VS1053 MP3 decoder chip that uses one select pin for data and other for commands. Both share the 3 data transfer pins (SCK, >MOSI, MISO). Tip SPI needs more wires than other similar buses but it can transfer data very fast. A 50Mhz clock is possible on SPI, that is 50 million bits in one second. Tip Note that a board running TinyCLR OS is always a SPI masters, not slaves. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var settings = new SpiConnectionSettings(FEZ.GpioPin.PB6) // the slave's select pin { Mode = SpiMode.Mode1, ClockFrequency = 4 * 1000 * 1000, //4Mhz DataBitLength = 8, }; var device = SpiDevice.FromId(FEZ.SpiBus.Spi1, settings); device.Write(new byte[] { 1, 2 }); // write something device.TransferSequential(...) // this is good for reading registers device.TransferFullDuplex(...) // this is the only one that trully represents how SPI works } }"
  },
  "software/tinyclr/tutorials/uart.html": {
    "href": "software/tinyclr/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART Serial data ports, called UARTs, transfer data between devices using two pins: TXD (transmit data) and RXD (receive data). UART stands for Universal Asynchronous Receiver Transmitter. Asynchronous means there is no clock signal to synchronize the two devices. The devices agree on a data rate, called the baud rate, and send a start bit the beginning of each transmitted character to keep the devices synchronized. Tip the TXD on one end (output) goes to the RXD on the other side (input) and vice versa. The easiest way to test a UART is by wiring a device's TXD to its RXD so any transmitted data is received by the same device. This is called a \"loopback\" test. This demo will transmit and receive a number every half second. Tip UART serial communication uses Storage Streams to handle the data. Don't forget to add the Storage NuGet package. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Storage.Streams; using GHIElectronics.TinyCLR.Devices.SerialCommunication; using GHIElectronics.TinyCLR.Pins; class Program { static DataReader serReader; static DataWriter serWriter; static void Sender() { byte b = 0; while(true) { serWriter.WriteByte(b++); serWriter.Store(); Debug.WriteLine(\"Sent: \" + b); Thread.Sleep(500); } } static void Main() { SerialDevice ser = SerialDevice.FromId(FEZ.UartPort.Usart1); ser.BaudRate = 115200; ser.ReadTimeout = TimeSpan.Zero; serReader = new DataReader(ser.InputStream); serWriter = new DataWriter(ser.OutputStream); Thread SenderT = new Thread(Sender); SenderT.Start(); while (true) { var i = serReader.Load(1); if(i>0) { byte b = serReader.ReadByte(); Debug.WriteLine(\"Recieved: \" + b); } Thread.Sleep(10);// always give the system time to think! } } } RS232 UART uses the processor's voltage levels (logic levels) for transferring data. On the FEZ this is 0 to 3.3 volts. In the early days of computers UARTs used -12 to 12 volts to communicate reliably over longer distances. This is known as the RS232 standard. Some PCs still include serial ports, but those are RS232 serial ports. A voltage level shifter is needed to properly connect a logic level UART to an RS232 device. Warning Connecting your device to an RS232 port without a proper voltage level shifter can damage your device."
  },
  "hardware/imaging.html": {
    "href": "hardware/imaging.html",
    "title": "Imaging",
    "keywords": "Imaging ALCAM-OEM is a small yet powerful imaging hardware. It could capture stills and videos to SD card and able to fetch images using serial commands. It started in a successful Kickstarter campaign Resources Examples ALCAM Explorer User Manual We have worked on similar custom commercial designs with imaging needs but decided to proceed with a one-size-fits-all. Please contact us to discuss your imaging needs. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/breakout/fez-cerb40.html": {
    "href": "hardware/breakout/fez-cerb40.html",
    "title": "FEZ Cerb40",
    "keywords": "FEZ Cerb40 DIP40 form factor board. Not really a Gadgeteer board but it is very small! Schematic FEZ Cerb40 II Same as the FEZ Cerb40 with an added regulator chip. Schematic"
  },
  "hardware/breakout/g120-hdr.html": {
    "href": "hardware/breakout/g120-hdr.html",
    "title": "G120HDR Modules",
    "keywords": "G120HDR Modules The G120HDR Module is a through-hole version of the G120 Module G120HDR G120HDR Rev2 Resources Schematic"
  },
  "hardware/breakout/g80-th.html": {
    "href": "hardware/breakout/g80-th.html",
    "title": "G80 TH Module",
    "keywords": "G80 TH Module A through-hole version of the G80. Resources Schematics Software For information on programming the G80 TH Module, please go to the G80 page."
  },
  "hardware/duino/fez-cerbuino-net.html": {
    "href": "hardware/duino/fez-cerbuino-net.html",
    "title": "FEZ Cerbuino Net",
    "keywords": "FEZ Cerbuino Net An Arduino-pinout compatible single board computer with Gadgeteer sockets. Resources Schematic Software For information on programming the FEZ Cerbuino Net, please go to the FEZ Cerberus page."
  },
  "hardware/duino/fez-lemur.html": {
    "href": "hardware/duino/fez-lemur.html",
    "title": "FEZ Lemur",
    "keywords": "FEZ Lemur A Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Lemur, please go to the G30 page."
  },
  "hardware/fez/arduino.html": {
    "href": "hardware/fez/arduino.html",
    "title": "Arduino",
    "keywords": "Arduino Arduino is simplified multi-platform IDE/C++ combo, with a community supported STM32 option. This video shows the use of Arduino (The FEZ and the BrainPad share the same hardware core). Arduino Website Arduino STM32 GitHub Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/fez/python.html": {
    "href": "hardware/fez/python.html",
    "title": "MicroPython",
    "keywords": "MicroPython MicroPython allows tiny systems to run Python 3, with a small subset of the standard library. The STM32F4 is already one of available ports, making it easier to run MicroPython on FEZ. This video shows the steps needed to use MicroPython on the FEZ (The FEZ and the BrainPad share the same processor). MicroPyho Website GitHub Repo Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/fez/shields/adafruit-display-shield.html": {
    "href": "hardware/fez/shields/adafruit-display-shield.html",
    "title": "Adafruit Display Shield",
    "keywords": "Adafruit Display Shield The Adafruit 1.8\" Color TFT Shield w/microSD and Joystick plugs right on top of FEZ, or any other Arduino-pinout compatible board. To use this shield, just plug it on top of your FEZ. The driver is found here ."
  },
  "hardware/fez/shields/shields.html": {
    "href": "hardware/fez/shields/shields.html",
    "title": "Shields",
    "keywords": "Shields Shields are standard plug-in accesories that expand an arduino-pinout-compatible board with additional functionality. There are hundreds of available shields that can be used with FEZ . Here we have hand picked a few of our favorite shields from some of the most respected companies supporting makers. Adafruit Display Shield MikroElektronika Arduino UNO Click Shield Pololu Zumo Robot Seeed Grove Starter Kit Sparkfun Ardumoto Shield Kit Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/fez/shields/sparkfun-ardumoto-shield-kit.html": {
    "href": "hardware/fez/shields/sparkfun-ardumoto-shield-kit.html",
    "title": "Sparkfun Ardumoto Shield Kit",
    "keywords": "Sparkfun Ardumoto Shield Kit The sparkfun Sparkfun Ardumoto Shield Kit is a low cost way to quickly build a robot. Plug the shield on top of your FEZ , or any other Arduino-pinout compatible board. You are now ready for some serious dancing! public static void Main() { var GPIO = GpioController.GetDefault(); var DIRA = GPIO.OpenPin(FEZ.GpioPin.D2); var DIRB = GPIO.OpenPin(FEZ.GpioPin.D4); DIRA.SetDriveMode(GpioPinDriveMode.Output); DIRB.SetDriveMode(GpioPinDriveMode.Output); var PWM1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); var PWM3 = PwmController.FromId(FEZ.PwmPin.Controller3.Id); PWM1.SetDesiredFrequency(5000); PWM3.SetDesiredFrequency(5000); var PWMA = PWM1.OpenPin(FEZ.PwmPin.Controller1.D3); var PWMB = PWM3.OpenPin(FEZ.PwmPin.Controller3.D11); PWMA.Start(); PWMB.Start(); // reverse direction every one second! // Do not foget the shield needs power. Thsi can come from VIN, meaning plug a power pack into your *duino board. PWMB.SetActiveDutyCyclePercentage(0.9); while (true) { DIRA.Write(GpioPinValue.High); DIRB.Write(GpioPinValue.High); System.Threading.Thread.Sleep(1000); //change speed PWMA.SetActiveDutyCyclePercentage(0.9); DIRA.Write(GpioPinValue.Low); DIRB.Write(GpioPinValue.Low); System.Threading.Thread.Sleep(1000); //change speed PWMA.SetActiveDutyCyclePercentage(0.5); } }"
  },
  "hardware/ucm/uc5550.html": {
    "href": "hardware/ucm/uc5550.html",
    "title": "UC5550",
    "keywords": "UC5550 Overview Our UC5550 module is a step up from the UC2550 in terms of processor speed, internal flash, external RAM and available peripherals. Unlike the UC2550, the UC5550 has USB host, parallel LCD, DCMI interfaces and Ethernet PHY support. We currently stock the UC5550 both with and without Wi-Fi depending on the model. The current models are shipping with 32 MByte of external RAM and 4 MByte of external flash. We also offer customized, non-stock versions of our SoMs. See Options below for more information. Getting Started The UCM development options can greatly simplify the process of building a product or prototype using the UC5550. Options include a development board and displays which can get you programming in minutes. Please refer to the Development Options page for more information. Using TinyCLR OS TinyCLR provides a way to program the UC5550 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the bootloader and firmware on the UC5550 (instructions below) and then go to the TinyCLR Getting Started page for instructions on setting up the host computer and writing and deploying programs. Loading Bootloader Version 2 Download the UC5550 bootloader here . Go to the Uploading DFU Files section of the STM32 Bootloader page for instructions on installing the bootloader. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 signal low (press BOOT B on UCM Dev and Breakout boards) while resetting the board. Download the UC5550 firmware and follow Loading the Firmware steps. Setup the Host Computer and Start Coding Now that you have installed the bootloader and firmware on the UC5550, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Schematic The schematic for the UC5550 can be found here . Options Model Number Wi-Fi Ethernet PHY External SDRAM External QSPI Flash UC5550-67HFN no no 32 MByte 4 MByte UC5550-67HFW yes no 32 MByte 4 MByte Customization We also offer customized, non-stock versions of our SoMs. Many options are available, such as various sizes of external QSPI flash. Please contact us for details. We will always do our best to provide you with a module to fit your exact needs. Specifications Spec UC5550 Processor ST STM32F767 32-bit ARM Cortex-M7 Speed 216 MHz Internal RAM 512 KByte (SRAM) Internal Flash 2 MByte External RAM 32 MByte (SDRAM) External Flash 4 MByte (QSPI) Peripherals Peripheral UCM Standard Overall* UART 4 5 (including HS) UART HS 1 2 I2C 1 2 SPI 2 3 CAN 2 2 SDIO 1 1 ADC 8 9 PWM 8 20 GPIO 12 103 IRQ 4 103 USB Client Supported Supported USB Host Supported Supported LCD Supported (16bpp & 24bpp) Supported (16bpp & 24bpp) Ethernet PHY Supported Supported Wi-Fi Supported Supported DCMI Supported Supported VBAT Supported Supported JTAG SWD SWD * The \"Overall\" column includes peripherals that fall outside of the UCM standard definition. Using these peripherals may reduce code portability with our other UCM models. Also, as many of these non-standard peripherals share I/O pins, not all of them will be available to your application. Pin Assignments SO-DIMM Pin Universal Compute Standard Function Name 1 AGND AGND 2 Ethernet TX- ETH PHY TX- 3 Module Specific 1 (Wi-Fi Module PIN14) GPIO4 (LED WPWR) 4 Ethernet TX+ ETH PHY TX+ 5 Analog VREF- Analog VREF- 6 Ethernet RX- ETH PHY RX- 7 Reserved 8 Ethernet RX+ ETH PHY RX+ 9 Reserved PH7, DCMI GP 10 Indicator A ETH PHY LED SPEED 11 Indicator B ETH PHY LED LINK 12 Reserved 13 GND GND 14 DCMI D0 PH9, DCMI D0 15 DCMI D1 PH10, DCMI D1 16 DCMI D2 PG10, DCMI D2 17 DCMI D3 PH12, DCMI D3 18 DCMI D4 PE4, DCMI D4 19 DCMI D5 PI4, DCMI D5 20 Analog 3.3V Analog 3.3V 21 DCMI D6 PE5, DCMI D6 22 DCMI D7 PE6, DCMI D7 23 DCMI VSYNC PG9, DCMI VSYNC 24 DCMI HSYNC PH8, DCMI HSYNC 25 DCMI PIXCLK PA6, DCMI PIXCLK 26 DCMI XCLK PA8, DCMI XCLK, MCO1 27 GND GND 28 PWM E PI6, T8C2 29 PWM F PI7, T8C3 30 PWM G PI2, T8C4 31 PWM H PA3, T9C2, ADC3 32 Analog VREF+ Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 (Wi-Fi Module PIN13) GPIO7 36 Module Specific 5 (Wi-Fi Module PIN16) GPIO0 37 Module Specific 6 (Wi-Fi Module PIN22) GPIO6 38 Module Specific 7 39 Module Specific 8 40 GND GND 41 GND GND 42 LCD 24bpp R0 PI15, LCD R0 43 LCD 24bpp R1 PJ0, LCD R1 44 LCD 24bpp R2 PJ1, LCD R2 45 LCD 24bpp G0 PJ7, LCD G0 46 3.3V 3.3V 47 LCD 24bpp G1 PJ8, LCD G1 48 LCD 24bpp B0 PJ12, LCD B0 49 LCD 24bpp B1 PJ13, LCD B1 50 LCD 24bpp B2 PJ14, LCD B2 51 GND GND 52 Module Specific 9 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A PI8 58 IRQ B PI11 59 IRQ C PH14 60 3.3V 3.3V 61 IRQ D PH15 62 GPIO A PD7 63 GPIO B PE3 64 GPIO C PG3 65 GND GND 66 GPIO D PG6 67 GPIO E PG7 68 GPIO F PH4 69 GPIO G PI0 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX PF7, UART7 TX 76 UART C RX PF6, UART7 RX 77 UART D TX PB10, USART3 TX, T2C3, I2C2 SCL (Wi-Fi) 78 UART D RX PB11, USART3 RX, T2C4, I2C2 SDA (Wi-Fi) 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX PC6, USART6 TX, T3C1 90 UART B RX PC7, USART6 RX, T3C2 91 ADC A PA0, ADC0, T5C1 92 GPIO H PA1, ETH RMII REF CLK 93 SPI B MISO PF8, SPI5 MISO, T13C1, UART7 RTS 94 SPI B MOSI PF9, SPI5 MOSI, T14C1, UART7 CTS 95 GND GND 96 SPI B SCK PH6, SPI5 SCK, T12C1 97 ADC B PA4, ADC4, DAC1 98 CAN A TD PH13, CAN1 TX 99 CAN A RD PI9, CAN1 RX 100 CAN B TD PB13, CAN2 TX 101 CAN B RD PB12, CAN2 RX 102 UART HS A TX PD5, USART2 TX 103 UART HS A RX PD6, USART2 RX 104 ADC C PA5, ADC5, DAC2 105 PWM A PA15, T2C1 106 3.3V 3.3V 107 System A BOOT 108 Module Specific 2 (Wi-Fi Module PIN2) BOOT0 109 Module Specific 3 (Wi-Fi Module PIN4) GPIO8 (Mini Python) 110 ADC D PB0, ADC8, T3C3 111 System C PI1 112 PWM B PB7, T4C2 113 GND GND 114 ADC E PB1, ADC9, T3C4 115 I2C A SDA PB9, I2C1 SDA, T4C4 116 I2C A SCL PB8, I2C1 SCL, T4C3 117 UART A RX PA10, USART1 RX 118 UART A TX PA9, USART1 TX 119 GPIO I PA2, ETH MDIO 120 UART HS A RTS PD4, USART2 RTS 121 UART HS A CTS PD3, USART2 CTS 122 GPIO J PA7, ETH RMII CRS DV 123 SD Card D0 PC8, SD D0 124 3.3V 3.3V 125 SD Card CMD PD2, SD CMD 126 SD Card CLK PC12, SD CLK, SPI3 MOSI 127 SD Card D1 PC9, SD D1 128 SD Card D2 PC10, SD D2, SPI3 SCK 129 SD Card D3 PC11, SD D3, SPI3 MISO 130 PWM C PH11, T5C2 131 GND GND 132 GPIO K PC4, ETH RMII RXD0 133 PWM D PI5, T8C1 134 System B PB2 135 System D PI3 136 GPIO L PC5, ETH RMII RXD1 137 Module Specific 10 (ETH PHY OSCILLATOR PIN1) OE OFF# 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX 141 UART HS B RX 142 3.3V 3.3V 143 LCD VSYNC PI13, LCD VSYNC 144 LCD HSYNC PI12, LCD HSYNC 145 LCD CLK PI14, LCD CLK 146 LCD DE PK7, LCD DE 147 Module Specific 11 148 SD Card CD PC13 149 Module Specific 12 150 Reserved 151 GND GND 152 LCD B3 PJ15, LCD B3 153 LCD B4 PK3, LCD B4 154 LCD B5 PK4, LCD B5 155 LCD B6 PK5, LCD B6 156 LCD B7 PK6, LCD B7 157 ADC F PC0, ADC10 158 ADC G PC2, ADC12 159 ADC H PC3, ADC13 160 3.3V 3.3V 161 LCD G2 PJ9, LCD G2 162 LCD G3 PJ10, LCD G3 163 LCD G4 PJ11, LCD G4 164 LCD G5 PK0, LCD G5 165 LCD G6 PK1, LCD G6 166 Module Specific 13 167 Indicator C (Wi-Fi Module PIN15) GPIO3 (LED LINK) 168 LCD R7 PJ6, LCD R7 169 GND GND 170 LCD G7 PK2, LCD G7 171 LCD R3 PJ2, LCD R3 172 LCD R4 PJ3, LCD R4 173 LCD R5 PJ4, LCD R5 174 LCD R6 PJ5, LCD R6 175 SPI A SCK PB3, SPI1 SCK 176 SPI A MISO PB4, SPI1 MISO 177 Module Specific 14 178 SPI A MOSI PB5, SPI1 MOSI 179 Module Specific 15 180 3.3V 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT VBAT 184 Module Specific 18 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ PB15, USBH D+ 189 JTAG RTCK 190 USB Host D- PB14, USBH D- 191 JTAG TDO 192 3.3V 3.3V 193 JTAG NTRST 194 USB Device D+ PA12, USB D+ 195 JTAG TDI 196 USB Device D- PA11, USB D- 197 JTAG TCK (SWCLK) PA14, JTCK, SWCLK 198 GND GND 199 JTAG TMS (SWDIO) PA13, JTMS, SWDIO 200 Indicator D (Wi-Fi Module PIN5) GPIO10 (LED ACT) Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "legacy/intro.html": {
    "href": "legacy/intro.html",
    "title": "Legacy Products Introduction",
    "keywords": "Legacy Products Introduction This section covers GHI's legacy products. These products are not recommended for new designs and are no longer covered by our free support. Please contact us directly for details on our paid support services. SoMs Learn more... Gadgeteer Learn more... Gadgeteering Learn more... File System Learn more... Imaging Learn more... Raspberry PI Hats Learn more... mBuino Learn more... Tip Our community forum is a great place to get help from our engineers and from thousands of community members: https://forums.ghielectronics.com/ Producing Legacy Products GHI Electronic's products are all engineered and manufactured in-house. While some of our older products are deemed legacy and not recommended for new designs, we can still produce them, however a minimum order may be required. We understand the need for continued product support and availability. Please contact us to discuss ways to fulfill your immediate needs and also to discuss upgrade options. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/netmf/tutorials/analog-in.html": {
    "href": "software/netmf/tutorials/analog-in.html",
    "title": "Analog Inputs",
    "keywords": "Analog Inputs Unlike digital input pins which can only read high or low, analog pins can read a range of voltage levels. Micro-controllers based on 3.3V can read voltages anywhere between zero and 3.3V. In contrast to digital input pins that are 5V tolerant; the maximum applied voltage for analog input must not exceed 3.3V (for higher voltages a voltage divider or an op-amp circuit can be used). Using a Light Sensor to Demonstrate Analog Input This example uses a light sensor. Its output voltage varies with light intensity -- the darker the light the higher the voltage output. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the Developers' Guide or the product manual for specific channels. using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { AnalogInput lightSensor = new AnalogInput((Cpu.AnalogChannel)Cpu.AnalogChannel.ANALOG_7); double lightSensorReading = 0; while (true) { lightSensorReading = lightSensor.Read(); Debug.Print(lightSensorReading.ToString()); Thread.Sleep(500); } } }"
  },
  "hardware/gadgeteer/fez-spider-ii.html": {
    "href": "hardware/gadgeteer/fez-spider-ii.html",
    "title": "FEZ Spider II",
    "keywords": "FEZ Spider II FEZ Spider II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider II is the G120E System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Download the bootloader file Set the board's configuration switches in boot mode. That is by setting switches #1 and #2 to the on position. Connect the FEZ Spider to a power module (red module) and then to a PC. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set the configuration switch #1 to the on position and then reset your board. Make sure to set back to off after loading the firmware. Download the G120 firmware and follow Loading the Firmware steps."
  },
  "hardware/scm/g30.html": {
    "href": "hardware/scm/g30.html",
    "title": "G30",
    "keywords": "G30 The G30 System on Chip (SoC) is a low-cost chipset running .NET Micro Framework. It is programmed using Microsoft's Visual Studio in C# or Visual Basic which lets developers enjoy a world class development environment with modern event-driven programming languages. Datasheet Pricing, purchasing and other information can be found on the G30 Page on our main website. Getting Started Options for programming the G30 include the following: Microsoft's .NET Micro Framework (NETMF) We discourage the use of NETMF software on our products in favor of TinyCLR OS. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. TinyCLR OS TinyCLR provides a way to program the G30 in C# or Visual Basic using Microsoft Visual Studio. To get started you must first install the firmware on the G30 (instructions below) and then go to the TinyCLR Getting Started page for instructions on setting up the host computer and writing and deploying programs. Loading Bootloader v2 The G30 SoC ships with the Bootloader loaded and locked. No further steps are necessary. Loading the Firmware To activate bootloader v2, the LDR0 signal needs to be low while resetting the board. Download the G30 firmware and follow Loading the Firmware steps. G30 Based products G30 Development Board The development system used for evaluating the EMX SoM. Schematic TinyCLR lets you program our devices (and others) in C# or Visual Basic using Microsoft's Visual Studio -- and it's all free! Learn more... . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/netmf/downloads.html": {
    "href": "software/netmf/downloads.html",
    "title": "NETMF Downloads",
    "keywords": "NETMF Downloads Microsoft Visual Studio The lastest version of Visual Studio that works with NETMF is VS2013. The Community Version can be downloaded from the following link: Microsoft Visual Studio 2013 Community Edition Available NETMF SDKs Release notes are found within the SDKs. Date NETMF Core Rev SDK Jun 27, 2016 4.3 QFE2 GHI Electronics NETMF SDK 2016 R1 Aug 31, 2015 4.3 QFE2 GHI Electronics NETMF SDK 2015 R1 Oct 29, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R5 Oct 8, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R4 Sep 15, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R3 Jul 31, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R2 Jan 29, 2014 4.3 RTM NETMF and Gadgeteer Package 2014 R1 Oct 23, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R3 Aug 27, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R2 Apr 30, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R1 Update 1 Feb 14, 2013 4.2 QFE2 NETMF and Gadgeteer Package 2013 R1 Feb 17, 2012 4.1 RTM NETMF 4.1 SDK, for Embedded Master, USBizi and ChipworkX (Includes IoT book for FEZ Panda) Microsoft .NET Gadgeteer Core Microsoft .NET Gadgeteer Core"
  },
  "software/netmf/tutorials/fez-cerb-developers-guide.html": {
    "href": "software/netmf/tutorials/fez-cerb-developers-guide.html",
    "title": "FEZ Cerb Family Developers' Guide",
    "keywords": "FEZ Cerb Family Developers' Guide The powerful firmware on a single chip design of the Cerb Family makes this core ideal for many uses. GHI offers the following Cerb Family products that all share the exact same processor (STM32F405RGT6) and firmware: FEZ Cerberus FEZ Cerbuino Bee FEZ Cerbuino Net FEZ Cerb40 II Memory Constraints Due to the limited amount of memory on the Cerb Family, the following features are not supported: Wi-Fi RS9110 PPP SQLite USB Host Webcam and Hub USB Client Extended Weak References InField Update Serial debugging SSL Cryptography Real Time Clock To enable the Real Time Clock, you must connect a crystal with frequency 32.768KHz and load capacitance of 6pF between PC14 and PC15. VT200F-6PF20PPM from DigiKey will work. You must also supply the VBAT pin with 3V. The FEZ Cerb40 II already does this. The FEZ Cerbuino Net and Bee expose PC14 and PC15 on pins D3 and D4 respectively on their headers. For the FEZ Cerberus, since PC14 and PC15 are not exposed, you must connect the crystal between C10 and C11 on the board on the side closest to the processor. Loader Update The loader on the Cerb Family is updated using ST Microelectronics's STDFU Tester program. This program is installed by default with our SDK. Under STMicroelectronics in the start menu, run the STDFU Tester program. The board must be put in a special mode for the STDFU tool to recognize it. To do so, hold the LDR button on your board, power it, then release LDR. If your board lacks an LDR button, short the two pads labeled either LDR or BOOT (depending on your board) together and then power your board. If you have a FEZ Cerb40 II, hold the LODR pin high and then power the board. Next, you will see \"STM Device in DFU Mode\" appear under Device in the STDFU tool. Click the Protocol tab. Click the Create from Map button, select the Erase radio button, and then click Go. The program will take a few moments to erase the board. Once it has finished, select the download option on the left before downloading the loader file: Click the Load DFU File button and select the C:\\Program Files (x86)\\GHI Electronics\\NETMF v4.3 SDK\\Firmwares\\Cerb Family\\Loader.dfu file. Click the Download radio button and then click Go. The program will quickly load the new loader onto your board. Reboot your board after it finishes and proceed to update the firmware using FEZ Config as detailed on the Firmware Update page. Warning Make sure to follow these steps exactly. You could corrupt the loader file or overwrite certain parts of your device if you are not careful. PWMs On the Cerb Family of products, the underlying processor groups PWMs in such a way that a change to the frequency in one PWM affects all PWMs in that group. The below list shows the groups of PWMs: PWM_3, PWM_11, PWM_12 PWM_8, PWM_9, PWM_10, PWM_13 PWM_4, PWM_5, PWM_6, PWM_7 PWM_14, PWM_15 PWM_0, PWM_2 PWM_1 FEZ Cerbuino Net Ethernet Initialization The below code shows how to initialize the onboard Ethernet on the FEZ Cerbuino Net from a plain NETMF project. It requires the GHI.Networking, GHI.Pins, and Microsoft.SPOT.Net libraries. If you are using Gadgeteer, you can find the Ethernet object pre-created on the Mainboard.Ethernet object. using GHI.Networking; using GHI.Pins; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.Net.NetworkInformation; public class Program { private static EthernetENC28J60 netif; public static void Main() { NetworkChange.NetworkAvailabilityChanged += NetworkChange_NetworkAvailabilityChanged; NetworkChange.NetworkAddressChanged += NetworkChange_NetworkAddressChanged; netif = new EthernetENC28J60(SPI.SPI_module.SPI1, Generic.GetPin('A', 13), Generic.GetPin('A', 14), Generic.GetPin('B', 10)); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); } private static void NetworkChange_NetworkAddressChanged(object sender, Microsoft.SPOT.EventArgs e) { Debug.Print(\"Network address changed\"); if (netif.IPAddress != \"0.0.0.0\") { //The network is now ready to use. } } private static void NetworkChange_NetworkAvailabilityChanged(object sender, NetworkAvailabilityEventArgs e) { Debug.Print(\"Network availability: \" + e.IsAvailable.ToString()); } } FEZ Cerbuino Bee and FEZ Cerbuino Net SD Card Detect To detect whether or not an SD card is inserted in the onboard connector, you can sample pin PC2 with the pull-up resistor enabled. You can also use an interrupt to signal when the insertion state changes. Once you detect the presence of a card, you can create and mount the SDCard object. Known Issues Socket 5 and 6 on the FEZ Cerberus are both marked as S and P (among others) and use the same SPI bus. The 3 main SPI pins and the 3 PWM pins both use the physical pins 7, 8, and 9 on a socket. As a result, when you use SPI or PWM on those sockets, neither SPI nor PWM will function on the other socket."
  },
  "software/netmf/tutorials/fez-hydra-firmware.html": {
    "href": "software/netmf/tutorials/fez-hydra-firmware.html",
    "title": "FEZ Hydra Firmware",
    "keywords": "FEZ Hydra Firmware Since the FEZ Hydra is open source, its firmware is available and can be built by end users who wish to customize it. To begin, make sure you have the following installed: Visual Studio 2012 Express for Desktop The GNU GCC toolchain Only Visual Studio 2012 is supported due to a requirement in NETMF itself. You may continue to use Visual Studio 2013 or newer for deploying programs to the board. You may use other compilers or toolchains, but they are not covered in this guide and may require a number of changes to the sources to use correctly. Additionally, compiling the firmware requires the path to the compiler to not have any spaces in it. If you install the above toolchain to the default location in Program Files, you must create a shortcut to it that has no spaces. To do so, assuming the default install path, execute the below command from an elevated command prompt. It will create a shortcut to the install directory in C:\\ called gcc. mklink /D C:\\gcc \"C:\\Program Files (x86)\\GNU Tools ARM Embedded\\4.9 2015q2\" Getting the Sources After you have installed the above tools, you need to download the source code for the firmware. It can be found on Bitbucket. If you are familiar with git, you can clone is to a local directory. If not, you can download the latest version from the downloads page. In either case, make sure you extract it to a folder with no spaces in its path just like the compiler. Unfortunately, a shortcut like we created above will not work. For this guide, we will assume you cloned or downloaded and extracted it to C:\\netmf-open-firmware. One important thing to keep in mind is that we do not release the C# sources to our extensions. However, the firmware does include the native interop code. As such, if you wish to use our libraries, you must match the libraries found in an SDK with the firmware version you are compiling. For example, when we released the 2014 R5 SDK, we tagged that commit as SDK-2014-R5 to easily find it later. Pre-releases are not tagged but just have a commit message of the form \"Commit for SDK release 2015.1.9.0\". If you try to compile a firmware version that came after the SDK version you got our libraries from, it will likely not work. Compiling Once you have all of the tools installed and the firmware source code downloaded, you are ready to compile. Begin by opening a command prompt and navigating to the directory with the firmware source, for example: C:\\netmf-open-firmware. Once in that directory, execute the below command. Make sure that the last parameter matches the directory you installed the GCC toolchain to or the shortcut you created. setenv_gcc 4.9.3 C:\\gcc After that, to build TinyBooter, execute: msbuild Solutions\\FEZ_Hydra\\TinyBooter\\TinyBooter.proj /t:cleanbuild /p:flavor=release Once compilation finishes, you will find the final binary at C:\\netmf-open-firmware\\BuildOutput\\ARM\\GCC4.9\\le\\FLASH\\release\\FEZ_Hydra\\bin\\TinyBooter.bin. You can then use the loader updater that comes with our SDK to deploy that TinyBooter to your board (make sure to rename it to Loader.bin for the script to find.) Next, you can compile TinyCLR (the main firmware). Execute the same command as above, except change TinyBooter to TinyCLR: msbuild Solutions\\FEZ_Hydra\\TinyCLR\\TinyCLR.proj /t:cleanbuild /p:flavor=release Once that finishes, the final firmware can be found in \"C:\\netmf-open-firmware\\BuildOutput\\ARM\\GCC4.9\\le\\FLASH\\release\\FEZ_Hydra\\bin\\tinyclr.hex\". ER_CONFIG is the same as Config.hex in our SDK and ER_FLASH is the same as Firmware.hex. You can deploy those files using MFDeploy or FEZ Config. You now have your own firmware running on your FEZ Hydra and can deploy to it from Visual Studio."
  },
  "software/netmf/tutorials/intro.html": {
    "href": "software/netmf/tutorials/intro.html",
    "title": ".NET Micro Framework Tutorials",
    "keywords": ".NET Micro Framework Tutorials Note We are currently updating our NETMF documentation. We have extensive NETMF documentation on our old website which can be viewed here . Topics Analog Inputs Analog Outputs CAN Digital Inputs Digital Outputs Files Firmware Update I2C In-Field Update PWM SPI UART USB Client USB Host What is .NET Micro Framework? Learn more about .NET Micro Framework . If you are new to NETMF you might want to take a look at our free e-book .NET Micro Framework for Beginners"
  },
  "software/netmf/tutorials/pwm.html": {
    "href": "software/netmf/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM PWM is used to control of the ratio of a pin's high and low state, the \"duty cycle.\" This can be done using software or using built-in PWM pins on the processor. PWM pins have the advantage over Software PWM because the toggling is independent of the CPU. Software PWM is performed using the SignalGenerator class. PWM objects are constructed with the period and duration of the pulse. The duration is how long the pin is high or active while the period is the time between one duration and the next. \"Duty Cycle\" is the ratio of the duration and the period -- as a convenience, a scale can be set. The scale is applied to the numbers assigned to the PWM's properties. A pin with duty cycle 0.5 will be high half the time and low the other half. Some common uses of PWM: control the intensity of lights and the speed of motors by changing the duty-cycle. generate audio tones by keeping the duty-cycle at 50% and changing the frequency. positioning of a servo by using a pulse with a specific duration or width. .NET Micro Framework PWM Channels In NETMF, the PWM pins are defined in the \"Cpu.PWMChannel\" enumeration. As the enumeration has a limited number of members, the number of PWM pins may exceed the members. Casting can be used for those extra PWMs. // Using the enumeration PWM MyServo = new PWM(Cpu.PWMChannel.PWM_3, 2175, 175, PWM.ScaleFactor.Microseconds, false); // Lots of PWMs on processor, use a cast to access an extra PWM PWM LED = new PWM((Cpu.PWMChannel)9, 10000, 0.10, false); > [!Tip] > The examples shown below require the Microsoft.SPOT.Hardware.PWM assembly; > [!Warning] > Some or all PWM pins share the same timers internally. This means the changing frequency on one pin will also effect the others. However, the duty cycle can be different on all pins. Users needing to determine which pins share the same timer have two options. Either use trial and error on all PWM pins or check the processor manual. ## Controlling LEDs Brightness This example starts the LED at 0% intensity then slowly steps up to full intensity, after which it reverts to 0% and starts over. ```c# using System.Threading; using Microsoft.SPOT.Hardware; public class Program { static PWM MyFader = new PWM(Cpu.PWMChannel.PWM_0, 10000, 0.1, false); public static void Main() { double i = 0.0; while (true) { MyFader.DutyCycle = i; /* DutyCycle is not dynamic so make a call to * Start() to refresh the object */ MyFader.Start(); if ((i += 0.1) >= 1.0) { i = 0.0; } Thread.Sleep(10); } } } Musical Tones Music notes have specific frequencies, for example C is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 1000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //make sure the two below arrays match in length. each duration element corresponds to //one note element. static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; public static void Main() { PWM MyPWM = new PWM(Cpu.PWMChannel.PWM_3, 261, 0.50, false); while (true) { for (int i = 0; i < note.Length; i++) { MyPWM.Stop(); MyPWM.Frequency = note[i]; MyPWM.Start(); Thread.Sleep(duration[i]); } Thread.Sleep(100); } } } Servos For the servo in this example, if the pulse width is about 1.25ms then the servo is at 0 degrees. Increasing the pulse width to 1.50ms will move the servo to 90 degrees (neutral). A wider pulse of 1.75ms will move the servo to 180 degrees. Servos expect a pulse every 20ms to 30ms. It is important for the high pulse to be between 1.25ms and 1.75ms so that the servo's position is set properly. The code below will move the position of the servo to 180 degrees (using a pulse of 1.75ms). It uses a pause time between pulses of 20ms. So the period is 21.75ms and a duration of 1.75ms. Note the use of \"scale\". using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { PWM MyServo = new PWM(Cpu.PWMChannel.PWM_3, 2175, 1750, PWM.ScaleFactor.Microseconds, false); while (true) { // 0 degrees. 20ms period and 1.25ms high pulse MyServo.Duration = 1250; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); // 90 degrees. 20ms period and 1.50ms high pulse MyServo.Duration = 1500; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); // 180 degrees. 20ms period and 1.75ms high pulse MyServo.Duration = 1750; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); } } }"
  },
  "software/tinyclr/getting-started.html": {
    "href": "software/tinyclr/getting-started.html",
    "title": "Getting Started",
    "keywords": "Getting Started This page explains how to set up the TinyCLR programming environment. It covers device and computer setup and deployment of a \"hello world\" program. Tip If you're an existing user of NETMF and still want to use it in addition to TinyCLR OS, don't worry. TinyCLR is completely independent of NETMF and works side-by-side with no issues. TinyCLR Device Setup To use TinyCLR with a device you must first install the latest versions of the GHI bootloader and TinyCLR firmware on the device. The bootloader is installed first and provides a way to install the firmware and to execute programs which are uploaded to the device. The TinyCLR firmware includes the Common Language Runtime (CLR) which converts compiled code into machine instructions and manages program execution. The TinyCLR firmware is also responsible for interacting with Microsoft Visual Studio to load and debug your application programs. Instructions for installing the bootloader and firmware are provided on the documentation page for each device. If you want to use your own device, visit our porting guide for information on how to get started. TinyCLR Computer Setup Download and Install Visual Studio and the TinyCLR Extension If you don't already have Visual Studio 2017, download and install the free version from here: Visual Studio Community 2017 . Make sure to select the .NET desktop development workload when installing Visual Studio. Download and install the newest TinyCLR Visual Studio Project System . Download and Install the TinyCLR Nuget Packages Since TinyCLR OS is still so new, we haven't yet uploaded any packages to NuGet. Download the newest libraries , extract the archive, and place them in a local NuGet feed . Connect your device to your PC using a USB cable (make sure your device has the latest firmware installed). Start Visual Studio and create a new TinyCLR Application under C# > TinyCLR . New to Visual Studio or C#? Take a look at the getting started guide from Microsoft . Right click on your Project in the Solution Explorer and select Manage NuGet Packages . If the Solution Explorer window is not visible, open it by selecting `Solution Explorer' in the 'View' menu. Select the Package Source settings icon. Click the + button to add a new Package source. Select the location where the NuGet packages are stored locally by pressing the ... button. After Selecting the local folder where the downloaded NuGet packages are, you can select the Installed Tab to view the installed NuGet Packages. Selecting the Browse tab will show all the NuGet packages located in your local NuGet feed. Those installed are noted with a green check mark in front of the name. To install one of the packages click on the package name, click the check box to the right under \"Version(s),\" and click on the Install button. Accept the licensing agreement to install the package. And, that's it! You're now ready to start programming using TinyCLR OS. Starting a New Project Let's make a \"hello world\" program and deploy it on the FEZ Cobra III. Open Visual Studio and select File > New > Project . There should be a TinyCLR option under Visual C# . Click on TinyCLR in the left panel, and TinyCLR Application in the center panel. Name the project and hit the OK button to create a new project. The project will have a single C# file named Program.cs whose contents are shown below. C# source files are listed in the Solution Explorer window. If the Solution Explorer window is not visible, click on View > Solution Explorer to open it. If you right click on the project name in the Solution Explorer window a drop down menu will appear. Select Manage NuGet Packages... from the menu. Now you should see the installed TinyCLR NuGet library (GHIElectronics.TinyCLR.Core). This is the only library we will need for our \"hello world\" program. Close the NuGet... tab or click on the Program.cs tab to edit the source code. Change the contents as shown below. Make sure your device is plugged into the computer's USB port. Now hit the start button as shown on the above image (or hit the F5 key). If you've done everything correctly the program will compile and deploy to your device. The message \"Hello World!\" should appear in the output window as shown below. Congratulations! You're on your way to becoming a TinyCLR embedded developer! To learn more about TinyCLR embedded programming check out our tutorials . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/intro.html": {
    "href": "software/tinyclr/intro.html",
    "title": "TinyCLR OS Introduction",
    "keywords": "TinyCLR OS Introduction TinyCLR OS started with Microsoft's .NET Micro Framework and continues to enable managed .NET development and debugging using Visual Studio on embedded devices. All you need to get started is Visual Studio (free version available), a TinyCLR device, and a USB cable. Getting Started Deploy your first TinyCLR program. Learn more... Tutorials Learn TinyCLR embedded programming. Learn more... Native Run native code on your device and port to other targets. Learn more... Release Notes Find the latest changes to TinyCLR. Learn more... Downloads Visual Studio and device downloads. Learn more... Roadmap The future of TinyCLR. Learn more... Supported Devices Some boards that run TinyCLR. Learn more... Bootloaders Learn more... TinyCLR Config Our device configuration program. Learn more... Tip TinyCLR OS is still an alpha so there is still a lot more to come! Take a look at the release notes to see what's new and the roadmap to see what we have planned. To learn more about TinyCLR embedded programming check out our tutorials . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/native/apis.html": {
    "href": "software/tinyclr/native/apis.html",
    "title": "Native APIs in TinyCLR",
    "keywords": "Native APIs in TinyCLR The TinyCLR runtime provides several built in APIs for you to use and allows you to register APIs of your own that other parts of the system can later use. These APIs are also exposed to managed code to query and use. Looking inside the TinyCLR.h file provided in the porting repo, you'll see several types defined under TinyCLR_Api_Type . Each of those types has an associated provider somewhere else in the file that defines its API. The GPIO API for example allows you to read and write a pin that that provider has. APIs can also be set as the default API for a given type. This makes it easier for managed code to get access to a resource without knowing the exact name. Notice also that APIs are all defined as a struct with a field to access the owning API and a number of function pointers that provide the API. Most function pointers in avaialble APIs take a pointer to the owning struct as a this reference, since one is not implicitly provided because they're not traditional classes with instance members. Ports will register various providers to expose some functionality to other parts of the system, including native code. Our GHIElectronics.TinyCLR.Devices library allows you to specify which native provider you want to use and will automatically acquire and interface with it. It also uses the default API functionality to power the various GetDefault methods. All access to APIs is handled by the TinyCLR_Api_Manager type that is passed to the TinyCLR_Startup_SoftResetHandler you register. You can also find a reference to it on the TinyCLR_Interop_MethodData that gets passed to interops. The base function to find APIs is Find . You provide it an API name and the type that API should be and then it returns a TinyCLR_Api_Info type if it is found, or nullptr otherwise. The info struct contains information on the API like name, author, version, and type. It may also provide zero or one implementations. When providing zero implementations, Implementation is nullptr . When providing one, Implementation points direcetly to the an instance of the corresponding API struct. The functions SetDefaultName and GetDefaultName allow you to set and get the default name used for a given API type. FindDefault finds the API with the name registered as the default for the type if present and returns the API implementation it corresponds to. You can also add your own API using the Add function. Just provide it with a pointer to a TinyCLR_Api_Info struct that is properly constructed and it can later be found by calls to Find . You can add APIs from within native interops or your own native code if you're building your own firmware. The below code shows you how to find and interact with the default GPIO provider in the system. It assumes one is present and that the the function is an interop and thus has access to the method data. TinyCLR_Result Interop_Interop_SomeClass::SomeFunc___STATIC___VOID(TinyCLR_Interop_MethodData md) { auto apiManager = md.ApiManager; auto gpioController = reinterpret_cast<const TinyCLR_Gpio_Provider*>(apiManager->FindDefault(apiManager, TinyCLR_Api_Type::GpioController)); auto pin = 0U; if (gpioController != nullptr) { gpioController->Acquire(gpioController); gpioController->OpenPin(gpioController, pin); gpioController->SetDriveMode(gpioController, pin, TinyCLR_Gpio_PinDriveMode::Output); gpioController->WritePin(gpioController, pin, TinyCLR_Gpio_PinValue::High); gpioController->ClosePin(gpioController, pin); gpioController->Release(gpioController); } return TinyCLR_Result::Success; }"
  },
  "software/tinyclr/native/interops.html": {
    "href": "software/tinyclr/native/interops.html",
    "title": "Native Interops in TinyCLR",
    "keywords": "Native Interops in TinyCLR Interops allow you to write a class in managed code that is partially or entirely implemented in native code. This is useful for time critical tasks, things that would take too long in managed code, or interacting with native functionality not exposed through managed code. Keep in mind that while native code executes, all managed threads are blocked and if you crash in native code, managed code also crashes. To get started, create a TinyCLR project called InteropTest . In the project properties window, go to the TinyCLR OS tab. Check both the Generate native stubs for internal methods and the Generate bare native stubs checkboxes. Next, define your native API. Any method that you plan to implement in native code must be declared extern and be decorated with the System.Runtime.CompilerServices.MethodImpl attribute that is constructed with MethodImplOptions.InternalCall . Static and instance functions, static and instance constructors, finalizers, and property set and get bodies can all be implemented native. They can have any visibility, can take any number or types of parameters, and can return any type. For example: class MyNativeClass { private int field = 5; [MethodImpl(MethodImplOptions.InternalCall)] public extern int MyNativeFunc(int arg0); public extern int MyNativeProperty { [MethodImpl(MethodImplOptions.InternalCall)] get; } } Once you have your native API defined, build your project. In the output folder, find and open pe and then Interop . In there are three files that let TinyCLR connect the managed methods to the native methods. There are two main files that have the same name as your project. These define the entire API. Importantly, there is an object that has the assembly name, its checksum, and an array of its methods. The remaining file contains function stubs for each native method you need to implement from the MyNativeClass class. Each function has a single parameter of type TinyCLR_Interop_MethodData that can be found in the TinyCLR.h file. This type has two memebers: an opaque stack type that you pass to other interop functions and the API provider that gives you access to the runtime. You can use this API provider to find the interop provider. The interop provider allows you to read and write object fields, read arguments passed to the function, write to reference arguments, set the return value, raise other events, and create new managed objects. The following code shows reading from a field and setting it as the return value of the property: TinyCLR_Result InteropTest_InteropTest_MyNativeClass::MyNativeFunc___I4__I4(const TinyCLR_Interop_MethodData md) { auto ip = md.InteropManager; TinyCLR_Interop_ClrValue arg; TinyCLR_Interop_ClrValue ret; ip->GetArgument(ip, 0, arg); ip->GetReturn(ip, md.Stack, ret); ret.Data.Numeric->I4 = arg.Data.Numeric->I4 * arg.Data.Numeric->I4; return TinyCLR_Result::Success; } TinyCLR_Result InteropTest_InteropTest_MyNativeClass::MyNativeProperty___I4(const TinyCLR_Interop_MethodData md) { auto ip = md.InteropManager; const TinyCLR_Interop_ClrObject* self; TinyCLR_Interop_ClrValue field; TinyCLR_Interop_ClrValue ret; ip->GetThisObject(ip, md.Stack, self); ip->GetField(ip, self, InteropTest_InteropTest_MyNativeClass::FIELD___field___I4, field); ip->GetReturn(ip, md.Stack, ret); ret.Data.Numeric->I4 = field.Data.Numeric->I4; return TinyCLR_Result::Success; } Now you need to compile these files. If you don't have GCC yet, see the porting guide to find out how to install GCC. To compile using GCC, the easiest way is to use a makefile and a scatterfile. We've provided samples of each below. The makefile is setup to compile all cpp in the same directory it is and to do using for a Cortex M4 architecture. If you're not on CortexM4, change the MCU_FLAGS parameter accordingly. The output file is InteropTest.bin . You can change that with the OUTPUT_NAME property. OUTPUT_NAME = InteropTest LINKERSCRIPT_NAME = scatterfile MCU_FLAGS = -mcpu=cortex-m4 -mthumb INC_DIRS = -I. CC = arm-none-eabi-g++.exe LD = arm-none-eabi-g++.exe OC = arm-none-eabi-objcopy.exe CC_FLAGS = $(INC_DIRS) $(MCU_FLAGS) -Os -std=c++11 -xc++ -Wall -Wabi -w -mabi=aapcs -fPIC -fno-exceptions -fno-rtti -fno-use-cxa-atexit -fno-threadsafe-statics LD_FLAGS = $(MCU_FLAGS) -nostartfiles -lc -lgcc -T $(LINKERSCRIPT_NAME) -Wl,-Map,$(OUTPUT_NAME).map -Wl,--oformat -Wl,elf32-littlearm OC_FLAGS = -S -O binary SRC_FILES = $(wildcard *.cpp) OBJ_FILES = $(patsubst %.cpp, %.obj, $(SRC_FILES)) rebuild: clean build clean: del $(OBJ_FILES) $(OUTPUT_NAME).bin $(OUTPUT_NAME).elf $(OUTPUT_NAME).map build: $(OBJ_FILES) $(LD) $(LD_FLAGS) -o $(OUTPUT_NAME).elf $^ $(OC) $(OC_FLAGS) $(OUTPUT_NAME).elf $(OUTPUT_NAME).bin %.obj: %.cpp $(CC) -c $(CC_FLAGS) -o $@ $^ Because TinyCLR can't currently dynamically relocate your code, you'll need to provide the proper base and length values for the RLI region in the scatterfile by changing the RLI_BASE and RLI_LENGTH placeholders. You can find the RLI region for your device, if it has one, in the device's specifications. MEMORY { SDRAM (wx) : ORIGIN = RLI_BASE, LENGTH = RLI_LENGTH } SECTIONS { . = ALIGN(4); .text : { *(.text) } .rodata ALIGN(4): { *(.rodata ) } .data ALIGN(4): { *(.data) } .bss ALIGN(4): { *(.bss) } } Lastly, make sure that you place TinyCLR.h in the folder so that the interop files can see it. You need to use the file that corresponds to the release of the firmware you are running. To execute the makefile, you'll need to have make installed. You can get it from a toolkit like MinGW or, if you're on Windows 10, the Windows Subsystem for Linux. Once you have make installed, just navigate to the folder with the makefile and interop files in a shell and execute make build . Tip If you use the Windows Subsystem for Linux, you'll need to change del in the makefile to rm . Once you have a compiled image, look in the map file to find out where the interop definition variable Interop_InteropTest (if you're using the default names) got placed. You'll need to pass this address to the managed function that registers the interop. In managed code, add the compiled binary image as a resource and use the Marshal class to copy it into the correct location in memory. Then call System.Runtime.InteropServices.Interop.Add and pass it the address of the Interop_InteropTest object from the map file. You need to do this every time your program runs and before you call any of the native methods in your interop class. var interop = Resources.GetBytes(Resources.BinaryResources.InteropTest); Marshal.Copy(interop, 0, new IntPtr(0x20016000), interop.Length); Interop.Add(new IntPtr(0x2001607C)); var cls = new MyNativeClass(); var prop = cls.MyNativeProperty; var func = cls.MyNativeFunc(2);"
  },
  "software/tinyclr/tutorials/gpio-pulse-reader-writer.html": {
    "href": "software/tinyclr/tutorials/gpio-pulse-reader-writer.html",
    "title": "Gpio Pulse Reader Writer",
    "keywords": "Gpio Pulse Reader Writer Gpio Pulse Reader Writer works in the current release. Documentation is coming soon. var pulse = new GpioPulseReaderWriter(GpioPulseReaderWriter.Mode.DrainDuration, true, 100, FEZ.GpioPin.A1); See this for now https://old.ghielectronics.com/docs/326/pulse-feedback"
  },
  "software/tinyclr/tutorials/gpio.html": {
    "href": "software/tinyclr/tutorials/gpio.html",
    "title": "General Purpose Input Output (GPIO)",
    "keywords": "General Purpose Input Output (GPIO) Microcontrollers include pins that can be controlled through software. They can be inputs or outputs, hence the name general purpose input/output, or GPIO for short. Tip GPIO is handled by using GHIElectronics.TinyCLR.Devices.Gpio through the NuGet Devices package. Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered from 3.3V, then the state high means that there is 3.3V on the output pin. It is not going to be exactly 3.3V but very close. When the pin is set to low it's voltage will be very close to zero. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. Warning Digital pins on microcontrollers are weak. They can only be used to control small LEDs or transistors. Those transistors can, in turn, control devices with high power needs like a motor. This example will blink an LED on the FEZ. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { static void Main() { GpioPin led = GpioController.GetDefault().OpenPin( GHIElectronics.TinyCLR.Pins.FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); while (true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } } The previous example uses the FEZ pins class that enumerates all pins available on the FEZ. To blink an LED on hardware that does not have a pins class, you must use the GPIO pin's number to refer to it. This example can work on any STM32 chip. As every port has 16 pins, we calculate the pin number as shown. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { static int PinNumber(char port, byte pin) { if (port < 'A' || port > 'E') throw new ArgumentException(); return ((port - 'A')*16) + pin; } static void Main() { var led = GpioController.GetDefault().OpenPin( //PinNumber('E', 2)); // Buggy bot right flash //PinNumber('C', 4)); // Buggy bot left flash //PinNumber('C', 12)); // mini M4 //PinNumber('B', 2)); // Cerbuino //PinNumber('A', 1)); // clicker //PinNumber('E', 12)); // clicker2 //PinNumber('E', 15)); // Quail //PinNumber('A', 10)); //netduino 3 //PinNumber('D', 5)); //411 red Discovery //PinNumber('D', 15)); //411 blue Discovery STM32F4.GpioPin.PA15); led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } } Digital Inputs Digital inputs sense the state of an input pin based on its voltage. The pin can be high or low. Every pin has a maximum and minimum supported voltage. For example, the typical minimum voltage on most pins is 0 volts; a negative voltage may damage the pin or the processor. Also, the maximum that can be applied to most pins must be less than or equal to the processor's power supply voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V. However, some processors that are powered by 3.3V are 5V tolerant -- they can withstand up to 5V on their inputs. The FEZ is 5V tolerant. Warning 5V tolerant doesn't mean the processor can be powered by 5V, only that the input pins can tolerate 5V. Unconnected input pins are called \"floating.\" They are in a high impedance state and are susceptible to surrounding noise which can make the pin read high or low. A resistor can be added to pull the pin high or low. Modern processors include internal pull-down or pull-up resistors that are controlled by software. Note that a pull-up resistor doesn't necessarily make a pin high -- something connected to the pin can still pull it low. In this example, a button is connected between ground and an input pin. We will enable the pull-up resistor making that pin high when the button is not pressed. When the button is pressed it will overpower the pull-up and make the input low. We will read the status of the button and pass its state to an LED. Tip Never use an infinite loop without giving the system time to think, use events or simply add a short sleep. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { GpioController GPIO = GpioController.GetDefault(); GpioPin led = GPIO.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); GpioPin button = GPIO.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); while(true) { if(button.Read() == GpioPinValue.Low) { // button is pressed led.Write(GpioPinValue.High); } else { led.Write(GpioPinValue.Low); } Thread.Sleep(10); //always give the system time to think! } } } Tip if you are not using a FEZ, see the Output Port example above to see how to determine the pin number. Digital Input Events In the previous example the program looped forever. The input attached to the button was checked during each iteration of the loop. The pin may be checked millions of times before the button is pressed! This method of checking inputs is called \"polled input.\" Using events to check an input instead of polling the input is often preferred. Once an event is set up it will automatically check the input on its own, freeing up the program to do other things. Also, it is possible to miss a change in input if you don't check (or poll) the input often enough. Events use interrupts to check inputs so you don't have to worry about missing anything. When an event occurs, the program stops what it is doing and control is transferred to an event handler. An event handler is code you write that responds to the event. Let's use event driven programming to respond to a button and turn and LED on and off. We will raise an event when the value on the button's input pin changes because the button is pressed or released. You will see a reference to a \"falling edge\" in the following code. A falling edge occurs when the state of a pin goes from high to low. A rising edge is just the opposite -- it occurs when a pin goes from low to high. This is a button controlled LED using events. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static GpioPin led; static void Main() { GpioController GPIO = GpioController.GetDefault(); led = GPIO.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); GpioPin button = GPIO.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); button.ValueChanged += Button_ValueChanged; Thread.Sleep(-1);// sleep for low power, or do other tasks here! } private static void Button_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e) { if (e.Edge == GpioPinEdge.FallingEdge) led.Write(GpioPinValue.Low); else led.Write(GpioPinValue.High); } } Tip Once you type += after the event, hit the tab key twice and Visual Studio will automatically create the event for you. UCM Standard Pins The UCM Standard provides a consistent mapping of pins to enable easily swapping out the underlying SoM. While the standard assigns a consistent name to each pin, the underlying pin on the processor is different, so it is helpful to use the UCMStandard class available in the GHIElectronics.TinyCLR.Pins.UCM library. Once you specify the device model to use it'll map the pins for you automatically. For example: using GHIElectronics.TinyCLR.Pins; using GHIElectronics.TinyCLR.Devices.Gpio; UCMStandard.SetModel(UCMModel.UC5550); var controller = GpioController.GetDefault(); var pin = controller.OpenPin(UCMStandard.GpioPin.A);"
  },
  "README.html": {
    "href": "README.html",
    "title": "Docs",
    "keywords": "Docs This is the repository for all of our docs. To generate the docs locally: Clone/Fork the repo Open the command prompt in the documents' root folder (\"Run as Administrator\" may be necessary) Execute docfx --serve"
  },
  "hardware/breakout/fez-cobra.html": {
    "href": "hardware/breakout/fez-cobra.html",
    "title": "FEZ Cobra",
    "keywords": "FEZ Cobra Resources Schematic Software For information about programming the FEZ Cobra, please visit our EMX page."
  },
  "hardware/breakout/g120-th.html": {
    "href": "hardware/breakout/g120-th.html",
    "title": "G120 TH Module",
    "keywords": "G120 TH Module A through-hole version of the G120. Resources Schematic Software For information on programming the G120 TH Module, please go to the G120 page."
  }
}