{
  "hardware/legacy/netmf/g30.html": {
    "href": "hardware/legacy/netmf/g30.html",
    "title": "G30",
    "keywords": "G30"
  },
  "hardware/legacy/netmf/emx.html": {
    "href": "hardware/legacy/netmf/emx.html",
    "title": "EMX",
    "keywords": "EMX"
  },
  "hardware/legacy/filesystem.html": {
    "href": "hardware/legacy/filesystem.html",
    "title": "File System",
    "keywords": "File System"
  },
  "hardware/fez.html": {
    "href": "hardware/fez.html",
    "title": "FEZ",
    "keywords": "FEZ"
  },
  "brainpad/courses/csharp/threading_and_events.html": {
    "href": "brainpad/courses/csharp/threading_and_events.html",
    "title": "Threading and Events",
    "keywords": "Threading and Events"
  },
  "hardware/scm/intro.html": {
    "href": "hardware/scm/intro.html",
    "title": "SCM Intro",
    "keywords": "SCM Intro"
  },
  "hardware/legacy/netmf/g80.html": {
    "href": "hardware/legacy/netmf/g80.html",
    "title": "G80",
    "keywords": "G80"
  },
  "hardware/legacy/netmf/g400.html": {
    "href": "hardware/legacy/netmf/g400.html",
    "title": "G400",
    "keywords": "G400"
  },
  "hardware/legacy/netmf/g120.html": {
    "href": "hardware/legacy/netmf/g120.html",
    "title": "G120",
    "keywords": "G120"
  },
  "hardware/legacy/netmf/fez_hydra.html": {
    "href": "hardware/legacy/netmf/fez_hydra.html",
    "title": "FEZ Hydra",
    "keywords": "FEZ Hydra"
  },
  "hardware/legacy/netmf/chipworkx.html": {
    "href": "hardware/legacy/netmf/chipworkx.html",
    "title": "ChipworkX",
    "keywords": "ChipworkX"
  },
  "hardware/legacy/raspberrypi_hats.html": {
    "href": "hardware/legacy/raspberrypi_hats.html",
    "title": "Raspberry Pi Hats",
    "keywords": "Raspberry Pi Hats"
  },
  "hardware/legacy/imaging.html": {
    "href": "hardware/legacy/imaging.html",
    "title": "Imaging",
    "keywords": "Imaging"
  },
  "brainpad/courses/vb/variables_and_nested_statements.html": {
    "href": "brainpad/courses/vb/variables_and_nested_statements.html",
    "title": "Variables and Nested Statements",
    "keywords": "Variables and Nested Statements"
  },
  "hardware/legacy/intro.html": {
    "href": "hardware/legacy/intro.html",
    "title": "Legacy Intro",
    "keywords": "Legacy Intro"
  },
  "hardware/legacy/gadgeteer.html": {
    "href": "hardware/legacy/gadgeteer.html",
    "title": "Gadgeteer",
    "keywords": "Gadgeteer"
  },
  "hardware/intro.html": {
    "href": "hardware/intro.html",
    "title": "Hardware Introduction",
    "keywords": "Hardware Introduction These pages provide specific details on each of our devices such as technical specifications, schematics, manuals, and datasheets. Products are grouped under the chip family they're based on, so for example FEZ Panda II can be found under the USBizi."
  },
  "hardware/brainpad.html": {
    "href": "hardware/brainpad.html",
    "title": "BrainPad",
    "keywords": "BrainPad"
  },
  "brainpad/drivers/radio_click.html": {
    "href": "brainpad/drivers/radio_click.html",
    "title": "Radio Click",
    "keywords": "Radio Click"
  },
  "brainpad/courses/vb/intro.html": {
    "href": "brainpad/courses/vb/intro.html",
    "title": "Intro",
    "keywords": "Intro"
  },
  "brainpad/intro.html": {
    "href": "brainpad/intro.html",
    "title": "BrainPad Intro",
    "keywords": "BrainPad Intro"
  },
  "tinyclr/tutorials/intro.html": {
    "href": "tinyclr/tutorials/intro.html",
    "title": "TinyCLR Tutorials",
    "keywords": "TinyCLR Tutorials"
  },
  "tinyclr/porting/contributing.html": {
    "href": "tinyclr/porting/contributing.html",
    "title": "Contributing",
    "keywords": "Contributing We are taking contributions to the TinyCLR OS ports and documentation, but we don't have an established process just yet, so standard contributing practices apply. Create a fork of the repo, create a new branch from dev, work on your changes, then submit a PR. Make sure to follow the existing style for the project and keep your changes easily reviewable. Your changes will need to be licensed under Apache 2 and you need to sign a Contributor License Agreement with us before your PR can be accepted."
  },
  "hardware/legacy/netmf/usbizi.html": {
    "href": "hardware/legacy/netmf/usbizi.html",
    "title": "USBizi",
    "keywords": "USBizi"
  },
  "hardware/legacy/netmf/fez_cerberus.html": {
    "href": "hardware/legacy/netmf/fez_cerberus.html",
    "title": "FEZ Cerberus",
    "keywords": "FEZ Cerberus"
  },
  "brainpad/courses/csharp/variables_and_nested_statements.html": {
    "href": "brainpad/courses/csharp/variables_and_nested_statements.html",
    "title": "Variables and Nested Statements",
    "keywords": "Variables and Nested Statements"
  },
  "tinyclr/tutorials/gpio.html": {
    "href": "tinyclr/tutorials/gpio.html",
    "title": "General Purpose Input Output (GPIO)",
    "keywords": "General Purpose Input Output (GPIO)"
  },
  "hardware/ucm/pinout.html": {
    "href": "hardware/ucm/pinout.html",
    "title": "UCM Pinout",
    "keywords": "UCM Pinout"
  },
  "hardware/ucm/intro.html": {
    "href": "hardware/ucm/intro.html",
    "title": "UCM Intro",
    "keywords": "UCM Intro"
  },
  "hardware/legacy/netmf/shields.html": {
    "href": "hardware/legacy/netmf/shields.html",
    "title": "Shields",
    "keywords": "Shields"
  },
  "hardware/legacy/netmf/intro.html": {
    "href": "hardware/legacy/netmf/intro.html",
    "title": "NETMF Intro",
    "keywords": "NETMF Intro"
  },
  "hardware/legacy/netmf/embedded_master.html": {
    "href": "hardware/legacy/netmf/embedded_master.html",
    "title": "Embedded Master",
    "keywords": "Embedded Master"
  },
  "hardware/legacy/outrageous_circuits.html": {
    "href": "hardware/legacy/outrageous_circuits.html",
    "title": "Outrageous Circuits",
    "keywords": "Outrageous Circuits"
  },
  "hardware/legacy/gadgeteering.html": {
    "href": "hardware/legacy/gadgeteering.html",
    "title": "Gadgeteering",
    "keywords": "Gadgeteering"
  },
  "brainpad/drivers/intro.html": {
    "href": "brainpad/drivers/intro.html",
    "title": "Drivers Intro",
    "keywords": "Drivers Intro"
  },
  "brainpad/courses/intro.html": {
    "href": "brainpad/courses/intro.html",
    "title": "Courses Intro",
    "keywords": "Courses Intro"
  },
  "README.html": {
    "href": "README.html",
    "title": "Docs",
    "keywords": "Docs This is the repository for all of our docs."
  },
  "brainpad/courses/vb/threading_and_events.html": {
    "href": "brainpad/courses/vb/threading_and_events.html",
    "title": "Threading and Events",
    "keywords": "Threading and Events"
  },
  "brainpad/courses/electronics/intro.html": {
    "href": "brainpad/courses/electronics/intro.html",
    "title": "Intro",
    "keywords": "Intro"
  },
  "brainpad/courses/csharp/intro.html": {
    "href": "brainpad/courses/csharp/intro.html",
    "title": "Intro",
    "keywords": "Intro"
  },
  "tinyclr/roadmap.html": {
    "href": "tinyclr/roadmap.html",
    "title": "Roadmap",
    "keywords": "Roadmap Since TinyCLR OS is still so new, we will be adding more libraries and functionality over time. Some of the things on our wish list in no particular order: USB host and client File system Graphics Secure networking Device updating Controller Area Network Runtime Loadable Procedures Generics .NET Standard"
  },
  "tinyclr/release_notes.html": {
    "href": "tinyclr/release_notes.html",
    "title": "Release Notes",
    "keywords": "Release Notes 0.4.0 on 2017-05-10 Notes This release primarily fixes several bugs; implements more of the serial API; adds DataReader , DataWriter , and Marshal classes; and reworks a lot of the BrainPad API. A new Storage library was added that moves some large members (like DataReader ) out of Devices that you may not always needed. There is more to be added to this library down the road. SignalGenerator , SignalCapture , and PulseFeedback were renamed to match the Windows 10 counterparts. Their API will be updated to match as well in a future release. The Marshal class under System.Runtime.InteropServices can be used like the old Register and AddressSpace classes to read and write memory. It also adds allocating and releasing unmanaged memory from the managed side that can be manipulated from the other members. You can see a quick example on using the new serial API here . You must use either the DataReader and DataWriter classes or use the WindowsRuntimeBufferExtensions to manipulate a Buffer since the internal array is no longer publicly accessible to match the UWP API. Pay attention to the Load and Store members. You can't read before calling Load and writes do not get flushed until you call Store . There has been no change to the G120 and G400 bootloaders in this release so you do not need to update them if you already have them on your device from the 0.3.0 release. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Fixed GpioPin.ValueChanged sender parameter type to be GpioPin. Fixed many of the Debug and Trace members not functioning properly. Fixed LowLevelDevicesController.DefaultProvider throwing an exception when null instead of falling back to the built-in providers. Fixed SerialDevice.Read not respecting the ReadTimeout value. Fixed SerialDevice.BytesReceived and IBuffer.Length not getting updated when reading. Fixed the exception that was thrown in BrainPad.Buttons when buttons are pressed. Fixed the exception that was thrown when using BrainPad.ServoMotor . Fixed PWM glicthing other pins on the same controller when changing one pin. Fixed Thread.Sleep not always sleeping for the proper amount of time. Fixed SerialDevice.ErrorReceived not being raised. Added EventArgs . Added WindowsRuntimeBufferExtensions . Added DataReader and DataWriter . Added various From methods to TimeSpan . Added InteropServices.Marshal . Added EditorBrowsable attribute to several members inherited from object to the BrainPad members. Added GHIElectronics.TinyCLR.Storage with WindowsRuntimeBufferExtensions , DataReader , and DataWriter in it. Updated the underlying value of the SerialError enum. Updated the BrainPad to be based around instance properties rather than static classes. Updated SerialDevice.Read to only support InputStreamOptions.Partial and InputStreamOptions.None . Moved InputStreamOptions , IInputStream , IOutputStream , IBuffer , and Buffer to the GHIElectronics.TinyCLR.Core assembly. Moved the BrainPad expansion pins to the pins library. Improved support for the original BrainPad in the driver. Improved many of the BrainPad APIs. Removed the members of Buffer that don't conform to the UWP API. Renamed SignalGenerator to GpioChangeWriter , SignalCapture to GpioChangeReader , and PulseFeedback to GpioPulseReaderWriter . Known Issues The original BrainPad display does not currently work with the GHIElectronics.TinyCLR.BrainPad library. Software I2C can lock up the board if a slave device isn't connected or responds improperly. ServoMotors.SetMaxPulseWidth has an invalid range in the exception message. Formatting numbers that cross an assembly boundary can throw an exception. Opening a non-existent UART will only throw when it is used. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Firmware Changes Fixed the G30 sometimes getting stuck during deployment. Added another sector to the G30 deployment region. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. Gpio interrupts may be slow when Visual Studio is connected. Some frequencies may round up instead of down if the requested frequency cannot be met. An 0xA2000000 error is sent over the debug transport when there is no deployment present. GpioChangeWriter does not generate proper signals for periods above 50ms on G400. Extension Changes Added a flag on the TinyCLR OS property page to control stub generation style. Added the DebuggerNonUserCode attribute to the startup code in BrainPad templates. Removed the public modifier from the C# application template. Known Issues The Visual Basic BrainPad template has a semicolon in the startup file. The device may not load drivers on Windows 7 preventing Visual Studio from seeing it. Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.3.0 on 2017-04-06 Notes This release has several API additions. Some were added as features themselves (software SPI, SignalGenerator, etc) while others were added to support certain features (the VB runtime, string.Format, MemoryStream and IntPtr for Drawing, etc). We're working to align ourselves with the various .NET Reference Sources available. You'll also see many new icons throughout, application templates for the BrainPad, and common item templates. The NuGet packages that have dependencies (such as on Core), now require the major and minor versions to match. For example, the 0.3.0 Devices library depends on Core [0.3.0,0.4.0). This is to further our use of SemVer so that the native interop checksum only changes in major and minor versions. See the NuGet docs for more information. The biggest addition is the drawing library. It was designed to mirror System.Drawing from the desktop. The basic API is there but there is still more work to be done. To support this, a DisplayController was added to the devices library to configure the display. Since there is no config yet you need to configure the display every time your program starts. A notable change from NETMF is calling flush on a drawing surface the size of the display will no longer draw to the display. Only drawing surfaces created from the FromHdc method passing in the Hdc value from the DisplayController will flush to the display. At this time, only bmp images are supported. Make sure you add a reference to GHIElectronics.TinyCLR.Drawing if using bitmap or font resources. Since it's in NuGet now it isn't automatically added. Support for Visual Basic has also been reenabled. One important thing to keep in mind is that there is no longer a Microsoft.VisualBasic assembly. We are using the embedded runtime option provided by Roslyn. It relies on several APIs being present in the core library. We added several of the key APIs needed to enable common usage scenarios. If you find you're getting cryptic compile errors from locations not in your code, let us know so we can evaluate what additional APIs are required. Since the UWP API only supports a controller wide frequency, we had to rework PWM a little bit. There is no longer one controller like there is for GPIO, instead one controller exists for each frequency source. On devices like the G30 and G80, this is a timer. On devices like the G400, there are independent registers for each channel (so unfortunately there will be one controller per channel). The pins library has been updated to organize PwmPin around controllers. SignalGenerator, SignalCapture, and PulseFeedback have also been added, but their APIs will change in a future release to match the UWP style. You can also now change what gets returned by GetDefault calls on the various controllers by updating LowLevelDevicesController.DefaultProvider. The Diagnostics namespace now matches the desktop version more closely. WriteLineIf and Assert were added to Debug and Trace was added as well. All methods on Debug and Trace are marked with the Conditional attribute as expected using the DEBUG and TRACE constants respectively. There's also now a Listeners property on each. This is a collection that you can add to so you can receive whatever is written to Trace or Debug by registering a class derived from TraceListener. As on the desktop, both Trace and Debug share the same listener collection. By default, the collection is populated with a listener that prints to the debug transport which is now at Debugger.Log. Collect and GetTotalMemory were added to GC. Note that GetTotalMemory returns the amount of memory used, not free, to match the desktop. We're investigating APIs to return the amount free. The last notable change is that we implemented IntPtr and UIntPtr. For now, they're only used as the type of the Hdc property in drawing. We expect them to be used in more places going forward. Since these two types map to native int and native unsigned int in the CLR and the managed compilers emit those types when they encounter IntPtr or UIntPtr, we have also added initial support for those types in the interpreter and runtime as well. Let us know if you encounter any weird or hard to explain runtime issues. This release also includes the firmware for the G400. It requires an updated bootloader from the one provided on the G400 bootloader installation page . Simply download the bootloader installer from the installation page and replace Bootloader.bin with the bootloader provided in the TinyCLR download package (making sure to rename it to Bootloader.bin). This updated bootloader can still be used to install the NETMF G400 firmware. It will eventually replace the one provided on the installation page. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . You can see some examples of the new APIs added in this release here . Libraries Changes PWM now has one controller per frequency source (usually a hardware timer) allowing different frequencies for each controller. string.Format should now work in all cases. Formatting numbers (ToString(\"N2\"), etc) should now work in all cases. I2C read/write partial functions now return the proper result. Opening non-existent ports no longer crashes the firmware. CultureInfo, NumberFormatInfo, and DateTimeFormatInfo now implement IFormatProvider. Primitives (except Boolean), DateTime, TimeSpan, Guid, and Enum now implement IFormattable. Added the == and != operators to Guid. Added a drawing library and display configuration. Added Enum.GetUnderlyingType Added LowLevelDevicesController and the provider API model for SPI, I2C, GPIO. Added SignalGenerator, SignalCapture, and PulseFeedback. Added software providers for I2C and SPI. Added CompilerGenerated, SuppressMessage, and In attributes. Added class target to Conditional attribute. Added FormatException and OverflowException. Added InvariantCulture and CurrentCulture to CultureInfo. Added FormattableString and FormattableStringFactory. Added Collect and GetTotalMemory to GC. Added MemoryStream. Added parts of the CodeContracts namespace. Added implementations to IntPtr and UIntPtr. Added Debugger.Log. Added Trace. Added Assert and WriteLineIf to Debug. Added listeners collection to Trace and Debug and a default listener mapped to Debugger.Log. Added BrainPad. Known Issues The sender parameter in the ValueChanged event on GpioPin is an instance of IGpioPinProvider, not GpioPin. Opening a non-existent UART will only throw when it is used. SignalGenerator may fail for small durations. An exception is thrown in BrainPad.Buttons when buttons are pressed. An exception is thrown when using BrainPad.ServoMotor. Some frequencies may round up instead of down if the requested frequency cannot be met. In the Debug class, only WriteLine(string) functions correctly. Firmware Changes G30 should no longer get stuck at waiting for device to initialize. PWM no longer takes 40 seconds to start on the G30 and G80. GPIO interrupts now work on the G120E. Added support for native int and native unsigned int in runtime Added G400 firmware. Known Issues Deploying to the G30 sometimes fails when writing a sector. An 0xA2000000 error is sent over the debug transport when there is no deployment present. Extension Changes Assemblies larger than sector size can now be deployed. Added Visual Basic support. Added BrainPad Application templates Added common item templates. Added icons throughout. NuGet packages now have a better range dependency for dealing with assembly checksums. Known Issues Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.2.0 on 2017-03-07 Notes You cannot use projects you made for the 0.1.0 version. You must recreate them and re-add your code files because of the changes to the project templates to make them more closely align them with the desktop .NET templates -- you'll notice the only difference is a few properties which prevent inclusion of reference assemblies. The templates also use the .NET Framework 4.5.2 target framework. This is only for NuGet compatibility going forward and does not mean you can use other libraries targeting that framework. This was done in anticipation of broader project system support of the new PackageReference format currently used in .NET Core which fails with unknown target frameworks. The MSBuild package is no longer provided or required. The metadata processor tool has moved internally to the extension and is invoked during deployment to the device. This means that pe and pdbx files are no longer redistributed with their assemblies -- they appear in a pe folder under the output directory when you deploy. We have also rewritten how dependencies are detected for deployment. If you notice any weird failures around assembly resolution or deployment, let us know and send us the entire project as-is so we can diagnose it. The information displayed while deploying to the device has also been improved to show more information about what is going on and what stage the deployment is in. We've also reworked incremental deployment so that assemblies are deployed one to a flash sector (if space allows) to enable re-deploying only the assemblies that have changed on a sector by sector basis. This greatly increases deployment speed on devices which a large number of flash sectors allocated to deployment. This release also includes the firmware for the G120 and G120E. Because the current GHI bootloader on the G120 expects to load TinyBooter, we have provided a second stage bootloader with this preview that you must deploy using the existing GHI bootloader as if you were deploying TinyBooter. Once it is deployed and you restart the device, you'll notice that it starts our newer GHI bootloader 2.0 . You can then use this second bootloader to deploy the TinyCLR OS firmware. Asserting LDR0 will enter the second bootloader while asserting both LDR0 and LDR1 will enter the original bootloader and allow you to return to NETMF. After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Formatting numbers works in more cases. The built in \"en\" culture has been removed. The dependency on GHIElectronics.TinyCLR.MsBuild has been removed. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. The duty cycle and polarity can now be set when the PWM pin is stopped. The frequency for the PWM controller can now be set at any time. PwmController.SetDesiredFrequency and PwmController.ActualFrequency now return the actual frequency the device was able to meet. The min and max frequency for PWM is now returned correctly. Removed analog input and output precision. Added G120, G120E, and FEZ Cobra III. CAN bus definitions now return a friendly name instead of an integer. Renamed Gpio to GpioPin, AnalogInput to AdcChannel, AnalogOutput to DacChannel, and PwmOutput to PwmPin. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. Known Issues Formatting numbers sometimes returns incorrect values. string.Format fails for non-trivial cases. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. Some frequencies may round up instead of down if the requested frequency cannot be met. Firmware Changes Added G120/G120E firmware. Flushing over USB is quicker. GPIO interrupts are now raised reliably. The maximum allocation is now 51,539,607,484 bytes. Known Issues PWM frequencies beyond 45MHz on G80 and 21MHz on G30 can fail. PWM may take up to a minute to start on G30 and G80. Extension Changes Breakpoints and the commands dependent on them now function properly. References no longer need a solution reload to deploy. The GHIElectronics.TinyCLR.MsBuild package has been removed. PDBX and PE files are now generated at deploy time. The deployment progress log shows more information. Incremental deployment is now better about deploying only what has changed. Debugging stops quicker after all threads in the application exit. The project templates now mirror the desktop templates much more closely. The Visual Studio projects now target .NET Framework v4.5.2. Known Issues Deploying an assembly larger than the flash sector size fails. An 0xA2000000 error will get sent over the debug transport whenever there is no app present. 0.1.0 on 2016-12-16 Known Issues After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Breakpoints and the commands dependent on them (run to cursor, others) do not work. As a work around, add a class library project called mscorlib to your solution and add a project reference to it or insert calls to System.Diagnostics.Debugger.Break. References can fail to deploy unless a solution close and open occurs after adding the reference. Re-deploying immediately after stopping debugging can fail. Try again to work around it. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. PwmController.SetDesiredFrequency must be called before any call to PwmController.OpenPin. PwmPin.SetActiveDutyCyclePercentage must be called after Start. GPIO interrupts do not always trigger. PWM may take up to a minute to start. Formatting numbers yields incorrect results in some cases. string.Format fails for non-trivial cases. Only Core, Devices, and Pins libraries are available. Only G30 and G80 are available. Packages are not uploaded to the NuGet public gallery. Additions TimeSpan.Total* {int/long/double/...}.TryParse(string source, out value) string.Format(string format, param object[] args) System.Diagnostics.WriteLine(string message)"
  },
  "hardware/bootloader.html": {
    "href": "hardware/bootloader.html",
    "title": "Bootloader",
    "keywords": "Bootloader The GHI Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device if present. The bootloader communicates over a USB virtual serial port or a regular serial port. The interface used is usually controlled by a MODE pin. See your device specifications for details on interface configuration and selection and for which version of the bootloader it runs. Version 2.0 All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: returns the current version. N: returns the current device type. E: erases all user sectors of the device. R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. U: upload a file to the device using 1K XMODEM. Only send *.glb files meant for your device. Version 1.0 Currently the EMX, G120, and G120E use this version of the bootloader. All results are terminated with LF (\\n). Commands are executed as soon as they entered without waiting for a new-line. \"BL\" or \"Done.\" will be sent after each command. On startup, a banner is sent that is terminated by \"BL\". Once the banner is received, you are free to enter any of the case-sensitive single-character commands described below. V: returns the current version. E: erases all user sectors of the device (* is sent while erasing). R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. The firmware is automatically run after a successful upload."
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "keywords": "http://docs.ghielectronics.com is where you can find tutorials, samples, documentation, and API references for all GHI Electronics products. The available docs are not yet complete and those that are present are very rough, so please check back frequently."
  },
  "tinyclr/porting/native_apis.html": {
    "href": "tinyclr/porting/native_apis.html",
    "title": "Native APIs in TinyCLR",
    "keywords": "Native APIs in TinyCLR The TinyCLR runtime provides several built in APIs for you to use and allows you to register APIs of your own that other parts of the system can later use. These APIs are also exposed to managed code to query and use. Looking inside the TinyCLR.h file provided in the porting repo, you'll see several types defined under TinyCLR_Api_Type . Each of those types has an associated provider somewhere else in the file that defines its API. The GPIO API for example allows you to read and write a pin that that provider has. APIs can also be set as the default API for a given type. This makes it easier for managed code to get access to a resource without knowing the exact name. Notice also that APIs are all defined as a struct with a field to access the owning API and a number of function pointers that provide the API. Most function pointers in avaialble APIs take a pointer to the owning struct as a this reference, since one is not implicitly provided because they're not traditional classes with instance members. Ports will register various providers to expose some functionality to other parts of the system, including native code. Our GHIElectronics.TinyCLR.Devices library allows you to specify which native provider you want to use and will automatically acquire and interface with it. It also uses the default API functionality to power the various GetDefault methods. All access to APIs is handled by the TinyCLR_Api_Provider type that is passed to the TinyCLR_Startup_SoftResetHandler you register. The base function to find APIs is Find . You provide it an API name and the type that API should be and then it returns a TinyCLR_Api_Info type if it is found, or nullptr otherwise. The info struct contains information on the API like name, author, version, and type. It may also provide zero or more implementations specified by the Count field. When providing zero implementations, Implementation is nullptr . When providing one, Implementation points direcetly to the an instance of the corresponding API struct. If providing more than one, it points to an array of pointers, each of which its a pointer to an instance of the corresponding API struct. The functions SetDefaultSelector and GetDefaultSelector allow you to set and get the default selector used for a given API type. A selector takes the form \"{API name}{API index}\" (excluding the braces). This selector can be used by the FindBySelector method. It'll look for an API with the given name and then find the implementation with the given index, making sure not to go out of bounds for the specified API. FindByIndex does the same thing except you manually provide it with the name and index. FindByDefault finds the default selector for the type if present and returns the API implementation it corresponds to. You can also add your own API using the Add function. Just provide it with a pointer to a TinyCLR_Api_Info struct that is properly constructed and it can later be found by calls to Find . You can add APIs from within native interops or your own native code if you're building your own firmware. The below code shows you how to find and interact with the default GPIO provider in the system. It assumes one is present and that the API provider is available as a global variable in your code. void gpioTest() { auto gpioProvider = (const TinyCLR_Gpio_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::GpioProvider); if (gpioProvider != nullptr) { gpioProvider->AcquirePin(gpioProvider, 0); gpioProvider->WritePin(gpioProvider, 0, TinyCLR_Gpio_PinValue::High); gpioProvider->ReleasePin(gpioProvider, 0); } }"
  },
  "tinyclr/porting/native_interops.html": {
    "href": "tinyclr/porting/native_interops.html",
    "title": "Native Interops in TinyCLR",
    "keywords": "Native Interops in TinyCLR Interops allow you to write a class in managed code that is partially or entirely implemented in native code. This is useful for time critical tasks, things that would take too long in managed code, or interacting with native functionality not exposed through managed code. Keep in mind that while native code executes, all managed threads are blocked and if you crash in native code, managed code also crashes. To get started, create a TinyCLR project called InteropTest . In the project properties window, go to the TinyCLR OS tab. Check both the Generate native stubs for internal methods and the Generate bare native stubs checkboxes. Next, define your native API. Any method that you plan to implement in native code must be declared extern and be decorated with the System.Runtime.CompilerServices.MethodImpl attribute that is constructed with MethodImplOptions.InternalCall . Static and instance functions, static and instance constructors, finalizers, and property set and get bodies can all be implemented native. They can have any visibility, can take any number or types of parameters, and can return any type. For example: class MyNativeClass { private int field = 5; [MethodImpl(MethodImplOptions.InternalCall)] public extern string MyNativeFunc(uint param1); public extern int MyNativeProperty { [MethodImpl(MethodImplOptions.InternalCall)] get; } } Once you have your native API define, build your project. In the output folder, find and open pe and then Interop . In there are three files that let TinyCLR connect the managed methods to the native methods. There are two main files that have the same name as your project. These define the entire API. Importantly, there is an object that has the assembly name, its checksum, and an array of its methods. The remaining file contains function stubs for each native method you need to implement from the MyNativeClass class. Each function has a single parameter of type TinyCLR_Interop_MethodData that can be found in the TinyCLR.h file. This type has two memebers: an opaque stack type that you pass to other interop functions and the API provider that gives you access to the runtime. You can use this API provider to find the interop provider. The interop provider allows you to read and write object fields, read arguments passed to the function, write to reference arguments, set the return value, raise other events, and create new managed objects. The following code shows reading from a field and setting it as the return value of the property: TinyCLR_Result InteropTest_InteropTest_MyNativeClass::MyNativeProperty___I4(const TinyCLR_Interop_MethodData md) { auto ip = (const TinyCLR_Interop_Provider*)md.ApiProvider.FindDefault(&md.ApiProvider, TinyCLR_Api_Type::InteropProvider); TinyCLR_Interop_ManagedValue self; TinyCLR_Interop_ManagedValue ret; TinyCLR_Interop_ManagedValue field; ret.Type = TinyCLR_Interop_ManagedValueType::I4; ip->GetThisObject(ip, md.Stack, self); ip->GetField(ip, self, InteropTest_InteropTest_MyNativeClass::FIELD___field___I4, field); ip->GetReturn(ip, md.Stack, ret); ret.Data.Numeric->I4 = field.Data.Numeric->I4; return TinyCLR_Result::Success; } Now you can compile these files using GCC. If you don't have GCC yet, see the porting guide to find out how to install GCC. To compile, you can use the sample build and linker scripts from here . Because TinyCLR can't currently dynamically relocate your code, you'll need to tell the scatterfile where to place the final binary image in memory. The sample files automatically place the image in the region dedicated for native interops for the FEZ . Make sure to adjust it for your device and that you don't overlap other images. Once you have a compiled image, look in the map file to find out where the interop definition variable Interop_InteropTest got placed. You'll need to pass this address to the managed function that registers the interop. In managed code, add the compiled binary image as a resource and use the Marshal class to copy it into the correct location in memory. Then call System.Runtime.InteropServices.Interop.Add and pass it the address of the Interop_InteropTest object from the map file. You need to do this every time your program runs and before you call any of the native methods in your interop class._"
  },
  "tinyclr/intro.html": {
    "href": "tinyclr/intro.html",
    "title": "TinyCLR OS Introduction",
    "keywords": "TinyCLR OS Introduction TinyCLR OS is our take on the .NET Micro Framework to enable managed .NET development using Microsoft's Visual Studio on embedded devices -- including debugging! All you need to get started is Visual Studio, a TinyCLR device, and a USB cable. TinyCLR OS is made for .NET developers. Threading, memory management, timers, event handlers, and many more exist in TinyCLR OS just like they do on full .NET. For interacting with hardware, TinyCLR OS has an API similar to the Windows 10 IoT Core Extensions API you may already be familiar with. GPIO, UART, SPI, I2C, ADC, DAC, PWM, and more are all available for you to interact with the embedded world. Better yet, all libraries are available through NuGet. Because of this, there will be no SDK to install or machines to lock to specific versions. Simply use NuGet to download any needed version of any needed library on a per-project basis. If you don't already have Visual Studio 2017, download and install the freely available Visual Studio Community 2017 . Download and install the TinyCLR OS Visual Studio extension . Connect your device to your PC using a USB cable. Don't have a TinyCLR OS device yet? Take a look at the FEZ : the board made for TinyCLR OS. Start Visual Studio and create a new TinyCLR Application under C# > TinyCLR . New to Visual Studio or C#? Take a look at the getting started guide from Microsoft . Add some code and press F5 to deploy and begin debugging your application! Since TinyCLR OS is still so new, we haven't yet uploaded any packages to NuGet, so make sure to download the available libraries , extract the archive, and place them in a local NuGet feed . If you're an existing user of NETMF and still want to use it in addition to TinyCLR OS, don't worry. TinyCLR OS is completely independent of NETMF and works side-by-side with no issues or changes required. TinyCLR OS is still very new and there is a lot more we have planned for it so some libraries and functionality may be missing. Take a look at the release notes to see what's new and roadmap to see what we have planned. Interested in running TinyCLR OS on your own device? Take a look at the porting guide for information on how to get started."
  },
  "tinyclr/porting/intro.html": {
    "href": "tinyclr/porting/intro.html",
    "title": "Porting TinyCLR",
    "keywords": "Porting TinyCLR"
  }
}